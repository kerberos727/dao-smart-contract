{
  "language": "Solidity",
  "sources": {
    "contracts/airdrop/interfaces/IMerkleDistributor.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n// Allows anyone to claim a token if they exist in a merkle root.\ninterface IMerkleDistributor {\n    // Returns the address of the token distributed by this contract.\n    function token() external view returns (address);\n    // Returns the merkle root of the merkle tree containing account balances available to claim.\n    function merkleRoot() external view returns (bytes32);\n    // Returns true if the index has been marked claimed.\n    function isClaimed(uint256 _index) external view returns (bool);\n    // Claim the given amount of the token to the given address. Reverts if the inputs are invalid.\n    function claim(uint256 _index, address _account, uint256 _amount, bytes32[] calldata _merkleProof) external;\n    // Withdraw the unclaimed tokens after the claim period ends\n    function withdrawUnclaimed() external;\n    // Transfers an amount of an ERC20 from this contract to an address\n    function transfer(IERC20 _token, address _to, uint256 _amount) external;\n\n\n    // This event is triggered whenever a call to #claim succeeds.\n    event Claimed(uint256 _index, address _account, uint256 _amount);\n    // This event is triggered whenever the unclaimed tokens are withdrawn\n    event Withdrawn(address _treasury, uint256 _amount);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/airdrop/MerkleDistributor.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IMerkleDistributor.sol\";\n\ncontract MerkleDistributor is IMerkleDistributor, Ownable {\n    using SafeERC20Upgradeable for IERC20;\n\n    address public immutable override token;\n    bytes32 public immutable override merkleRoot;\n    uint256 public claimPeriodEndBlock;\n    uint256 private constant CLAIM_PERIOD_BLOCKS = 17280 * 365;\n\n    // This is a packed array of booleans.\n    mapping(uint256 => uint256) private claimedBitMap;\n\n    modifier withinClaimPeriod() {\n        require(block.number <= claimPeriodEndBlock, \"MerkleDistributor: Claim period has ended\");\n        _;\n    }\n\n    modifier claimPeriodEnded() {\n        require(\n            block.number > claimPeriodEndBlock,\n            \"MerkleDistributor: Claim period has not ended\"\n        );\n        _;\n    }\n\n    constructor(address _token, bytes32 _merkleRoot) {\n        token = _token;\n        merkleRoot = _merkleRoot;\n        claimPeriodEndBlock = block.number + CLAIM_PERIOD_BLOCKS;\n    }\n\n    function isClaimed(uint256 _index) public view override returns (bool) {\n        uint256 _claimedWordIndex = _index / 256;\n        uint256 _claimedBitIndex = _index % 256;\n        uint256 _claimedWord = claimedBitMap[_claimedWordIndex];\n        uint256 _mask = (1 << _claimedBitIndex);\n        return _claimedWord & _mask == _mask;\n    }\n\n    function _setClaimed(uint256 _index) private returns (bool) {\n        uint256 _claimedWordIndex = _index / 256;\n        uint256 _claimedBitIndex = _index % 256;\n        uint256 _claimedWord = claimedBitMap[_claimedWordIndex];\n        uint256 _mask = (1 << _claimedBitIndex);\n\n        if (_claimedWord & _mask == _mask) {\n            // If already claimed signify failure\n            return false;\n        } else {\n            // Else claim and return success\n            claimedBitMap[_claimedWordIndex] = _claimedWord | _mask;\n            return true;\n        }\n    }\n\n    function claim(\n        uint256 _index,\n        address _account,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) external override withinClaimPeriod {\n        // Set it claimed (returns false if already claimed)\n        require(_setClaimed(_index), \"MerkleDistributor: Drop already claimed.\");\n\n        // Verify the merkle proof.\n        bytes32 _node = keccak256(abi.encodePacked(_index, _account, _amount));\n        require(\n            MerkleProof.verify(_merkleProof, merkleRoot, _node),\n            \"MerkleDistributor: Invalid proof.\"\n        );\n\n        // Send the token\n        IERC20Upgradeable(token).safeTransfer(_account, _amount);\n\n        emit Claimed(_index, _account, _amount);\n    }\n\n    function withdrawUnclaimed() external override onlyOwner claimPeriodEnded {\n        uint256 _unclaimedBalance = IERC20(token).balanceOf(address(this));\n        IERC20Upgradeable(token).safeTransfer(msg.sender, _unclaimedBalance);\n        emit Withdrawn(msg.sender, _unclaimedBalance);\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from this contract to an address\n     *\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyOwner {\n        IERC20Upgradeable(address(_token)).safeTransfer(_to, _amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n        return computedHash;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/token/SPACTToken.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IMintableToken.sol\";\nimport \"./VotingToken.sol\";\n\ncontract SPACTToken is IMintableToken, VotingToken, Ownable {\n    /**\n     * @notice Construct a Staking PACT Token\n     */\n    constructor() VotingToken(\"StakingPactToken\", \"SPACT\", 18) {}\n\n    /**\n     * @notice Mint new voting power\n     * @param _account     The address of the destination account\n     * @param _amount      The amount of voting power to be minted\n     */\n    function mint(address _account, uint96 _amount) external override onlyOwner {\n        _mintVotes(_account, _amount);\n    }\n\n    /**\n     * @notice Burn voting power\n     * @param _account     The address of the source account\n     * @param _amount      The amount of voting power to be burned\n     */\n    function burn(address _account, uint96 _amount) external override onlyOwner {\n        _burnVotes(_account, _amount);\n    }\n}\n"
    },
    "contracts/token/interfaces/IMintableToken.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\ninterface IMintableToken {\n    function mint(address _account, uint96 _amount) external;\n    function burn(address _account, uint96 _amount) external;\n}\n"
    },
    "contracts/token/VotingToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.3;\n\nimport \"./interfaces/INonTransferrableToken.sol\";\nimport \"./VotingPower.sol\";\n\n/**\n * A non-transferrable token that can vote.\n */\ncontract VotingToken is INonTransferrableToken, VotingPower {\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) VotingPower(name_) {\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    function name()\n        public\n        view\n        override(INonTransferrableToken, VotingPower)\n        returns (string memory)\n    {\n        return VotingPower.name();\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return totalVotingPower();\n    }\n\n    function balanceOf(address _account) public view override returns (uint256) {\n        return votingPower(_account);\n    }\n}\n"
    },
    "contracts/token/interfaces/INonTransferrableToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.3;\n\n/**\n * A token that cannot be transferred.\n */\ninterface INonTransferrableToken {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    // Views\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _account) external view returns (uint256);\n}\n"
    },
    "contracts/token/VotingPower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.3;\n\nimport \"./interfaces/IHasVotes.sol\";\nimport \"./interfaces/IVotingDelegates.sol\";\n\n/**\n * Power to vote. Heavily based on Uni.\n */\ncontract VotingPower is IHasVotes, IVotingDelegates {\n    // Name of the token. This cannot be changed after creating the token.\n    string private _name;\n\n    // Total amount of voting power available.\n    uint96 private totalVotingPowerSupply;\n\n    constructor(string memory name_) {\n        _name = name_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @notice Mint new voting power\n     * @param dst The address of the destination account\n     * @param amount The amount of voting power to be minted\n     */\n    function _mintVotes(address dst, uint96 amount) internal {\n        require(dst != address(0), \"VotingPower::_mintVotes: cannot mint to the zero address\");\n\n        // transfer the amount to the recipient\n        balances[dst] = add96(\n            balances[dst],\n            amount,\n            \"VotingPower::_mintVotes: mint amount overflows\"\n        );\n        totalVotingPowerSupply = add96(\n            totalVotingPowerSupply,\n            amount,\n            \"VotingPower::_mintVotes: total supply overflows\"\n        );\n        emit Transfer(address(0), dst, amount);\n\n        // move delegates\n        _moveDelegates(address(0), delegates[dst], amount);\n    }\n\n    /**\n     * @notice Burn voting power\n     * @param src The address of the source account\n     * @param amount The amount of voting power to be burned\n     */\n    function _burnVotes(address src, uint96 amount) internal {\n        require(src != address(0), \"VotingPower::_burnVotes: cannot burn from the zero address\");\n\n        // transfer the amount to the recipient\n        balances[src] = sub96(\n            balances[src],\n            amount,\n            \"VotingPower::_burnVotes: burn amount underflows\"\n        );\n        totalVotingPowerSupply = sub96(\n            totalVotingPowerSupply,\n            amount,\n            \"VotingPower::_burnVotes: total supply underflows\"\n        );\n        emit Transfer(src, address(0), amount);\n\n        // move delegates\n        _moveDelegates(delegates[src], address(0), amount);\n    }\n\n    /**\n     * @notice Get the amount of voting power of an account\n     * @param account The address of the account to get the balance of\n     * @return The amount of voting power held\n     */\n    function votingPower(address account) public view override returns (uint96) {\n        return balances[account];\n    }\n\n    function totalVotingPower() public view override returns (uint96) {\n        return totalVotingPowerSupply;\n    }\n\n    ////////////////////////////////\n    //\n    // The below code is copied from ../uniswap-governance/contracts/Uni.sol.\n    // Changes are marked with \"XXX\".\n    //\n    ////////////////////////////////\n\n    // XXX: deleted name, symbol, decimals, totalSupply, minter, mintingAllowedAfter,\n    // minimumTimeBetweenMints, mintCap, allowances\n\n    // Official record of token balances for each account\n    // XXX: internal => private visibility\n    mapping(address => uint96) private balances;\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) public override delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    // XXX: deleted PERMIT_TYPEHASH\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    // XXX: deleted MinterChanged\n\n    // XXX: deleted DelegateChanged, DelegateVotesChanged, Transfer and moved them to IVotingPower\n\n    // XXX: deleted Approval\n\n    // XXX: deleted constructor, setMinter, mint, allowance, approve, permit, balanceOf\n\n    // XXX: deleted transfer, transferFrom\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public override {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public override {\n        // XXX_CHANGED: name => _name\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(_name)), getChainId(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Uni::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"Uni::delegateBySig: invalid nonce\");\n        // XXX: added linter disable\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp <= expiry, \"Uni::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view override returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint256 blockNumber)\n        public\n        view\n        override\n        returns (uint96)\n    {\n        require(blockNumber < block.number, \"Uni::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _transferTokens(\n        address src,\n        address dst,\n        uint96 amount\n    ) internal {\n        require(src != address(0), \"Uni::_transferTokens: cannot transfer from the zero address\");\n        require(dst != address(0), \"Uni::_transferTokens: cannot transfer to the zero address\");\n\n        balances[src] = sub96(\n            balances[src],\n            amount,\n            \"Uni::_transferTokens: transfer amount exceeds balance\"\n        );\n        balances[dst] = add96(\n            balances[dst],\n            amount,\n            \"Uni::_transferTokens: transfer amount overflows\"\n        );\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    }\n\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint96 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(\n                    srcRepOld,\n                    amount,\n                    \"Uni::_moveVotes: vote amount underflows\"\n                );\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(\n                    dstRepOld,\n                    amount,\n                    \"Uni::_moveVotes: vote amount overflows\"\n                );\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint96 oldVotes,\n        uint96 newVotes\n    ) internal {\n        uint32 blockNumber = safe32(\n            block.number,\n            \"Uni::_writeCheckpoint: block number exceeds 32 bits\"\n        );\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function getChainId() internal view returns (uint256) {\n        uint256 chainId;\n        // XXX: added linter disable\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
    },
    "contracts/token/interfaces/IHasVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.3;\n\n/**\n * Reads the votes that an account has.\n */\ninterface IHasVotes {\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96);\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint256 blockNumber)\n        external\n        view\n        returns (uint96);\n}\n"
    },
    "contracts/token/interfaces/IVotingDelegates.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.3;\n\n/**\n * Interface for a contract that keeps track of voting delegates.\n */\ninterface IVotingDelegates {\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(\n        address indexed delegator,\n        address indexed fromDelegate,\n        address indexed toDelegate\n    );\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    /// @notice An event emitted when an account's voting power is transferred.\n    // - If `from` is `address(0)`, power was minted.\n    // - If `to` is `address(0)`, power was burned.\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice Name of the contract.\n    // Required for signing.\n    function name() external view returns (string memory);\n\n    /// @notice A record of each accounts delegate\n    function delegates(address delegatee) external view returns (address);\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @notice Get the amount of voting power of an account\n     * @param account The address of the account to get the balance of\n     * @return The amount of voting power held\n     */\n    function votingPower(address account) external view returns (uint96);\n\n    /// @notice Total voting power in existence.\n    function totalVotingPower() external view returns (uint96);\n}\n"
    },
    "contracts/governor/interfaces/PACTDelegateStorageV1.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"../../token/interfaces/IHasVotes.sol\";\nimport \"./TimelockInterface.sol\";\n\n/**\n * @title Storage for Governor Delegate\n * @notice For future upgrades, do not change PACTDelegateStorageV1. Create a new\n * contract which implements PACTDelegateStorageV1 and following the naming convention\n * PACTDelegateStorageVX.\n */\ncontract PACTDelegateStorageV1 {\n    /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\n    uint256 public votingDelay;\n\n    /// @notice The duration of voting on a proposal, in blocks\n    uint256 public votingPeriod;\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    uint256 public proposalThreshold;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    uint256 public quorumVotes;\n\n    /// @notice The address of the Governance Timelock\n    TimelockInterface public timelock;\n\n    /// @notice The address of the governance token\n    IHasVotes public token;\n\n    /// @notice The address of the \"Release\" governance token\n    IHasVotes public releaseToken;\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n    /// @notice The official each proposal's targets:\n    /// An ordered list of target addresses for calls to be made\n    mapping(uint256 => address[]) public proposalTargets;\n    /// @notice The official each proposal's values:\n    /// An ordered list of values (i.e. msg.value) to be passed to the calls to be made\n    mapping(uint256 => uint256[]) public proposalValues;\n    /// @notice The official each proposal's signatures:\n    /// An ordered list of function signatures to be called\n    mapping(uint256 => string[]) public proposalSignatures;\n    /// @notice The official each proposal's calldatas:\n    /// An ordered list of calldata to be passed to each call\n    mapping(uint256 => bytes[]) public proposalCalldatas;\n    /// @notice The official each proposal's receipts:\n    /// Receipts of ballots for the entire set of voters\n    mapping(uint256 => mapping(address => Receipt)) public proposalReceipts;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    struct Proposal {\n        // Unique id for looking up a proposal\n        uint256 id;\n        // Creator of the proposal\n        address proposer;\n        // The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n        // The block at which voting begins: holders must delegate their votes prior to this block\n        uint256 startBlock;\n        // The block at which voting ends: votes must be cast prior to this block\n        uint256 endBlock;\n        // Current number of votes in favor of this proposal\n        uint256 forVotes;\n        // Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n        // Current number of votes for abstaining for this proposal\n        uint256 abstainVotes;\n        // Flag marking whether the proposal has been canceled\n        bool canceled;\n        // Flag marking whether the proposal has been executed\n        bool executed;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        // Whether or not a vote has been cast\n        bool hasVoted;\n        // Whether or not the voter supports the proposal or abstains\n        uint8 support;\n        // The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n}\n"
    },
    "contracts/governor/interfaces/TimelockInterface.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\ninterface TimelockInterface {\n  function admin() external view returns (address);\n\n  function delay() external view returns (uint256);\n\n  function GRACE_PERIOD() external view returns (uint256);\n\n  function acceptAdmin() external;\n\n  function queuedTransactions(bytes32 _hash) external view returns (bool);\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external returns (bytes32);\n\n  function cancelTransaction(\n    address _target,\n    uint256 _value,\n    string calldata _signature,\n    bytes calldata _data,\n    uint256 _eta\n  ) external;\n\n  function executeTransaction(\n    address _target,\n    uint256 _value,\n    string calldata _signature,\n    bytes calldata _data,\n    uint256 _eta\n  ) external payable returns (bytes memory);\n}\n"
    },
    "contracts/mocks/governor/PACTDelegateOld.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"../../governor/interfaces/PACTDelegateStorageV1.sol\";\nimport \"../../governor/interfaces/PACTEvents.sol\";\n\ncontract PACTDelegateOld is\n    PACTEvents,\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    PACTDelegateStorageV1\n{\n    using SafeERC20Upgradeable for IERC20;\n\n    /// @notice The name of this contract\n    string public constant NAME = \"PACT\";\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD = 100_000_000e18; // 100,000,000 Tokens\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD = 500_000_000e18; // 500,000,000 Tokens\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 720; // About 1 hour\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 241920; // About 2 weeks\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 1;\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 120960; // About 1 week\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant PROPOSAL_MAX_OPERATIONS = 10; // 10 actions\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n\n    /**\n     * @notice Used to initialize the contract during delegator contructor\n     * @param _timelock The address of the Timelock\n     * @param _token The address of the voting token\n     * @param _releaseToken The address of the \"Release\" voting token. If none, specify the zero address.\n     * @param _votingPeriod The initial voting period\n     * @param _votingDelay The initial voting delay\n     * @param _proposalThreshold The initial proposal threshold\n     * @param _quorumVotes The initial quorum votes\n     */\n    function initialize(\n        address _timelock,\n        address _token,\n        address _releaseToken,\n        uint256 _votingPeriod,\n        uint256 _votingDelay,\n        uint256 _proposalThreshold,\n        uint256 _quorumVotes\n    ) public initializer {\n        require(\n            TimelockInterface(_timelock).admin() == address(this),\n            \"PACT::initialize: timelock admin is not assigned to PACTDelegate\"\n        );\n        require(\n            _votingPeriod >= MIN_VOTING_PERIOD && _votingPeriod <= MAX_VOTING_PERIOD,\n            \"PACT::initialize: invalid voting period\"\n        );\n        require(\n            _votingDelay >= MIN_VOTING_DELAY && _votingDelay <= MAX_VOTING_DELAY,\n            \"PACT::initialize: invalid voting delay\"\n        );\n        require(\n            _proposalThreshold >= MIN_PROPOSAL_THRESHOLD &&\n                _proposalThreshold <= MAX_PROPOSAL_THRESHOLD,\n            \"PACT::initialize: invalid proposal threshold\"\n        );\n        require(_quorumVotes >= _proposalThreshold, \"PACT::initialize: invalid quorum votes\");\n        timelock = TimelockInterface(_timelock);\n        require(\n            timelock.admin() == address(this),\n            \"PACT::initialize: timelock admin is not assigned to PACTDelegate\"\n        );\n\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        token = IHasVotes(_token);\n        releaseToken = IHasVotes(_releaseToken);\n        votingPeriod = _votingPeriod;\n        votingDelay = _votingDelay;\n        proposalThreshold = _proposalThreshold;\n        quorumVotes = _quorumVotes;\n\n        // Create dummy proposal\n        Proposal memory _dummyProposal = Proposal({\n            id: proposalCount,\n            proposer: address(this),\n            eta: 0,\n            startBlock: 0,\n            endBlock: 0,\n            forVotes: 0,\n            againstVotes: 0,\n            abstainVotes: 0,\n            canceled: true,\n            executed: false\n        });\n        proposalCount++;\n\n        proposals[_dummyProposal.id] = _dummyProposal;\n        latestProposalIds[_dummyProposal.proposer] = _dummyProposal.id;\n\n        emit ProposalCreated(\n            _dummyProposal.id,\n            address(this),\n            proposalTargets[_dummyProposal.id],\n            proposalValues[_dummyProposal.id],\n            proposalSignatures[_dummyProposal.id],\n            proposalCalldatas[_dummyProposal.id],\n            0,\n            0,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold.\n     * @param _targets Target addresses for proposal calls.\n     * @param _values Eth values for proposal calls.\n     * @param _signatures Function signatures for proposal calls.\n     * @param _calldatas Calldatas for proposal calls.\n     * @param _description String description of the proposal.\n     * @return Proposal id of new proposal.\n     */\n    function propose(\n        address[] memory _targets,\n        uint256[] memory _values,\n        string[] memory _signatures,\n        bytes[] memory _calldatas,\n        string memory _description\n    ) public returns (uint256) {\n        require(\n            getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold,\n            \"PACT::propose: proposer votes below proposal threshold\"\n        );\n        require(\n            _targets.length == _values.length &&\n                _targets.length == _signatures.length &&\n                _targets.length == _calldatas.length,\n            \"PACT::propose: proposal function information arity mismatch\"\n        );\n        require(_targets.length != 0, \"PACT::propose: must provide actions\");\n        require(_targets.length <= PROPOSAL_MAX_OPERATIONS, \"PACT::propose: too many actions\");\n\n        uint256 _latestProposalId = latestProposalIds[msg.sender];\n        if (_latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(_latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                \"PACT::propose: one live proposal per proposer, found an already active proposal\"\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                \"PACT::propose: one live proposal per proposer, found an already pending proposal\"\n            );\n        }\n\n        uint256 _startBlock = add256(block.number, votingDelay);\n        uint256 _endBlock = add256(_startBlock, votingPeriod);\n\n        Proposal memory _newProposal = Proposal({\n            id: proposalCount,\n            proposer: msg.sender,\n            eta: 0,\n            startBlock: _startBlock,\n            endBlock: _endBlock,\n            forVotes: 0,\n            againstVotes: 0,\n            abstainVotes: 0,\n            canceled: false,\n            executed: false\n        });\n        proposalCount++;\n\n        proposals[_newProposal.id] = _newProposal;\n        proposalTargets[_newProposal.id] = _targets;\n        proposalValues[_newProposal.id] = _values;\n        proposalSignatures[_newProposal.id] = _signatures;\n        proposalCalldatas[_newProposal.id] = _calldatas;\n        latestProposalIds[_newProposal.proposer] = _newProposal.id;\n\n        emit ProposalCreated(\n            _newProposal.id,\n            msg.sender,\n            _targets,\n            _values,\n            _signatures,\n            _calldatas,\n            _startBlock,\n            _endBlock,\n            _description\n        );\n        return _newProposal.id;\n    }\n\n    /**\n     * @notice Queues a proposal of state succeeded\n     * @param _proposalId The id of the proposal to queue\n     */\n    function queue(uint256 _proposalId) external {\n        require(\n            state(_proposalId) == ProposalState.Succeeded,\n            \"PACT::queue: proposal can only be queued if it is succeeded\"\n        );\n        Proposal storage _proposal = proposals[_proposalId];\n        uint256 _eta = add256(block.timestamp, timelock.delay());\n        for (uint256 i = 0; i < proposalTargets[_proposalId].length; i++) {\n            queueOrRevertInternal(\n                proposalTargets[_proposalId][i],\n                proposalValues[_proposalId][i],\n                proposalSignatures[_proposalId][i],\n                proposalCalldatas[_proposalId][i],\n                _eta\n            );\n        }\n        _proposal.eta = _eta;\n        emit ProposalQueued(_proposalId, _eta);\n    }\n\n    function queueOrRevertInternal(\n        address _target,\n        uint256 _value,\n        string memory _signature,\n        bytes memory _data,\n        uint256 _eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(\n                keccak256(abi.encode(_target, _value, _signature, _data, _eta))\n            ),\n            \"PACT::queueOrRevertInternal: identical proposal action already queued at eta\"\n        );\n        timelock.queueTransaction(_target, _value, _signature, _data, _eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param _proposalId The id of the proposal to execute\n     */\n    function execute(uint256 _proposalId) external payable {\n        require(\n            state(_proposalId) == ProposalState.Queued,\n            \"PACT::execute: proposal can only be executed if it is queued\"\n        );\n        Proposal storage _proposal = proposals[_proposalId];\n        _proposal.executed = true;\n        for (uint256 i = 0; i < proposalTargets[_proposalId].length; i++) {\n            timelock.executeTransaction{value: proposalValues[_proposalId][i]}(\n                proposalTargets[_proposalId][i],\n                proposalValues[_proposalId][i],\n                proposalSignatures[_proposalId][i],\n                proposalCalldatas[_proposalId][i],\n                _proposal.eta\n            );\n        }\n        emit ProposalExecuted(_proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param _proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 _proposalId) external {\n        require(\n            state(_proposalId) != ProposalState.Executed,\n            \"PACT::cancel: cannot cancel executed proposal\"\n        );\n\n        Proposal storage _proposal = proposals[_proposalId];\n        require(\n            msg.sender == _proposal.proposer ||\n                getPriorVotes(_proposal.proposer, sub256(block.number, 1)) < proposalThreshold,\n            \"PACT::cancel: proposer above threshold\"\n        );\n\n        _proposal.canceled = true;\n        for (uint256 i = 0; i < proposalTargets[_proposalId].length; i++) {\n            timelock.cancelTransaction(\n                proposalTargets[_proposalId][i],\n                proposalValues[_proposalId][i],\n                proposalSignatures[_proposalId][i],\n                proposalCalldatas[_proposalId][i],\n                _proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(_proposalId);\n    }\n\n    /**\n     * @notice Gets actions of a proposal.\n     * @param _proposalId Proposal to query.\n     * @return targets Target addresses for proposal calls.\n     * @return values Eth values for proposal calls.\n     * @return signatures Function signatures for proposal calls.\n     * @return calldatas Calldatas for proposal calls.\n     */\n    function getActions(uint256 _proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        return (\n            proposalTargets[_proposalId],\n            proposalValues[_proposalId],\n            proposalSignatures[_proposalId],\n            proposalCalldatas[_proposalId]\n        );\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param _proposalId the id of proposal\n     * @param _voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 _proposalId, address _voter)\n        external\n        view\n        returns (Receipt memory)\n    {\n        return proposalReceipts[_proposalId][_voter];\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param _proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 _proposalId) public view returns (ProposalState) {\n        require(proposalCount > _proposalId, \"PACT::state: invalid proposal id\");\n        Proposal storage _proposal = proposals[_proposalId];\n\n        if (_proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= _proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= _proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (\n            _proposal.forVotes <= _proposal.againstVotes || _proposal.forVotes < quorumVotes\n        ) {\n            return ProposalState.Defeated;\n        } else if (_proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (_proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(_proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param _proposalId The id of the proposal to vote on\n     * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 _proposalId, uint8 _support) external {\n        emit VoteCast(\n            msg.sender,\n            _proposalId,\n            _support,\n            castVoteInternal(msg.sender, _proposalId, _support),\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param _proposalId The id of the proposal to vote on\n     * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param _reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(\n        uint256 _proposalId,\n        uint8 _support,\n        string calldata _reason\n    ) external {\n        emit VoteCast(\n            msg.sender,\n            _proposalId,\n            _support,\n            castVoteInternal(msg.sender, _proposalId, _support),\n            _reason\n        );\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n     */\n    function castVoteBySig(\n        uint256 _proposalId,\n        uint8 _support,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        require(_v == 27 || _v == 28, \"PACT::castVoteBySig: invalid v value\");\n        require(\n            _s < 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A1,\n            \"PACT::castVoteBySig: invalid s value\"\n        );\n        bytes32 _domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainIdInternal(), address(this))\n        );\n        bytes32 _structHash = keccak256(abi.encode(BALLOT_TYPEHASH, _proposalId, _support));\n        bytes32 _digest = keccak256(abi.encode(\"\\x19\\x01\", _domainSeparator, _structHash));\n        address _signatory = ecrecover(_digest, _v, _r, _s);\n        require(_signatory != address(0), \"PACT::castVoteBySig: invalid signature\");\n        emit VoteCast(\n            _signatory,\n            _proposalId,\n            _support,\n            castVoteInternal(_signatory, _proposalId, _support),\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param _voter The voter that is casting their vote\n     * @param _proposalId The id of the proposal to vote on\n     * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(\n        address _voter,\n        uint256 _proposalId,\n        uint8 _support\n    ) internal returns (uint96) {\n        require(\n            state(_proposalId) == ProposalState.Active,\n            \"PACT::castVoteInternal: voting is closed\"\n        );\n        require(_support <= 2, \"PACT::castVoteInternal: invalid vote type\");\n        Proposal storage _proposal = proposals[_proposalId];\n        Receipt storage _receipt = proposalReceipts[_proposalId][_voter];\n        require(_receipt.hasVoted == false, \"PACT::castVoteInternal: voter already voted\");\n        uint96 _votes = getPriorVotes(_voter, _proposal.startBlock);\n\n        if (_support == 0) {\n            _proposal.againstVotes = add256(_proposal.againstVotes, _votes);\n        } else if (_support == 1) {\n            _proposal.forVotes = add256(_proposal.forVotes, _votes);\n        } else if (_support == 2) {\n            _proposal.abstainVotes = add256(_proposal.abstainVotes, _votes);\n        }\n\n        _receipt.hasVoted = true;\n        _receipt.support = _support;\n        _receipt.votes = _votes;\n\n        return _votes;\n    }\n\n    /**\n     * @notice Owner function for setting the voting delay\n     * @param _newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint256 _newVotingDelay) external virtual onlyOwner {\n        require(\n            _newVotingDelay >= MIN_VOTING_DELAY && _newVotingDelay <= MAX_VOTING_DELAY,\n            \"PACT::_setVotingDelay: invalid voting delay\"\n        );\n        uint256 _oldVotingDelay = votingDelay;\n        votingDelay = _newVotingDelay;\n\n        emit VotingDelaySet(_oldVotingDelay, _newVotingDelay);\n    }\n\n    /**\n     * @notice Owner function for setting the quorum votes\n     * @param _newQuorumVotes new quorum votes\n     */\n    function _setQuorumVotes(uint256 _newQuorumVotes) external onlyOwner {\n        require(\n            _newQuorumVotes >= proposalThreshold,\n            \"PACT::_setQuorumVotes: invalid quorum votes\"\n        );\n\n        uint256 _oldQuorumVotes = votingDelay;\n        quorumVotes = _newQuorumVotes;\n\n        emit QuorumVotesSet(_oldQuorumVotes, _newQuorumVotes);\n    }\n\n    /**\n     * @notice Owner function for setting the voting period\n     * @param _newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint256 _newVotingPeriod) external virtual onlyOwner {\n        require(\n            _newVotingPeriod >= MIN_VOTING_PERIOD && _newVotingPeriod <= MAX_VOTING_PERIOD,\n            \"PACT::_setVotingPeriod: invalid voting period\"\n        );\n        uint256 _oldVotingPeriod = votingPeriod;\n        votingPeriod = _newVotingPeriod;\n\n        emit VotingPeriodSet(_oldVotingPeriod, _newVotingPeriod);\n    }\n\n    /**\n     * @notice Owner function for setting the proposal threshold\n     * @dev _newProposalThreshold must be greater than the hardcoded min\n     * @param _newProposalThreshold new proposal threshold\n     */\n    function _setProposalThreshold(uint256 _newProposalThreshold) external onlyOwner {\n        require(\n            _newProposalThreshold >= MIN_PROPOSAL_THRESHOLD &&\n                _newProposalThreshold <= MAX_PROPOSAL_THRESHOLD,\n            \"PACT::_setProposalThreshold: invalid proposal threshold\"\n        );\n        uint256 _oldProposalThreshold = proposalThreshold;\n        proposalThreshold = _newProposalThreshold;\n\n        emit ProposalThresholdSet(_oldProposalThreshold, _newProposalThreshold);\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from this contract to an address\n     *\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner nonReentrant {\n        _token.safeTransfer(_to, _amount);\n\n        emit TransferERC20(address(_token), _to, _amount);\n    }\n\n    function add256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 _c = _a + _b;\n        require(_c >= _a, \"addition overflow\");\n        return _c;\n    }\n\n    function sub256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, \"subtraction underflow\");\n        return _a - _b;\n    }\n\n    function getChainIdInternal() internal view returns (uint256) {\n        uint256 _chainId;\n        assembly {\n            _chainId := chainid()\n        }\n        return _chainId;\n    }\n\n    function getPriorVotes(address _voter, uint256 _beforeBlock) internal view returns (uint96) {\n        if (address(releaseToken) == address(0)) {\n            return token.getPriorVotes(_voter, _beforeBlock);\n        }\n        return\n            add96(\n                token.getPriorVotes(_voter, _beforeBlock),\n                releaseToken.getPriorVotes(_voter, _beforeBlock),\n                \"getPriorVotes overflow\"\n            );\n    }\n\n    function add96(\n        uint96 _a,\n        uint96 _b,\n        string memory _errorMessage\n    ) internal pure returns (uint96) {\n        uint96 _c = _a + _b;\n        require(_c >= _a, _errorMessage);\n        return _c;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/governor/interfaces/PACTEvents.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\ncontract PACTEvents {\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    /// @param voter The address which casted a vote\n    /// @param proposalId The proposal id which was voted on\n    /// @param support Support value for the vote. 0=against, 1=for, 2=abstain\n    /// @param votes Number of votes which were cast by the voter\n    /// @param reason The reason given for the vote by the voter\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 votes, string reason);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    /// @notice An event emitted when the voting delay is set\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n\n    /// @notice An event emitted when the voting period is set\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n\n    /// @notice Emitted when implementation is changed\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /// @notice Emitted when proposal threshold is set\n    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n\n    /// @notice Emitted when release token is set\n    event ReleaseTokenSet(address oldReleaseToken, address newReleaseToken);\n\n    /// @notice An event emitted when the quorum votes is set\n    event QuorumVotesSet(uint256 oldQuorumVotes, uint256 newQuorumVotes);\n\n    /// @notice Emitted when pendingAdmin is changed\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @notice Triggered when an amount of an ERC20 has been transferred from this contract to an address\n     *\n     * @param token               ERC20 token address\n     * @param to                  Address of the receiver\n     * @param amount              Amount of the transaction\n     */\n    event TransferERC20(address indexed token, address indexed to, uint256 amount);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "contracts/governor/PACTDelegate.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./interfaces/PACTDelegateStorageV1.sol\";\nimport \"./interfaces/PACTEvents.sol\";\n\ncontract PACTDelegate is\n    PACTEvents,\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    PACTDelegateStorageV1\n{\n    using SafeERC20Upgradeable for IERC20;\n\n    /// @notice The name of this contract\n    string public constant NAME = \"PACT\";\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD = 100_000_000e18; // 100,000,000 Tokens\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD = 500_000_000e18; // 500,000,000 Tokens\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 720; // About 1 hour\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 241920; // About 2 weeks\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 1;\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 120960; // About 1 week\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant PROPOSAL_MAX_OPERATIONS = 10; // 10 actions\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n\n    /**\n     * @notice Used to initialize the contract during delegator constructor\n     * @param _timelock The address of the Timelock\n     * @param _token The address of the voting token\n     * @param _releaseToken The address of the \"Release\" voting token. If none, specify the zero address.\n     * @param _votingPeriod The initial voting period\n     * @param _votingDelay The initial voting delay\n     * @param _proposalThreshold The initial proposal threshold\n     * @param _quorumVotes The initial quorum votes\n     */\n    function initialize(\n        address _timelock,\n        address _token,\n        address _releaseToken,\n        uint256 _votingPeriod,\n        uint256 _votingDelay,\n        uint256 _proposalThreshold,\n        uint256 _quorumVotes\n    ) public initializer {\n        require(\n            TimelockInterface(_timelock).admin() == address(this),\n            \"PACT::initialize: timelock admin is not assigned to PACTDelegate\"\n        );\n        require(\n            _votingPeriod >= MIN_VOTING_PERIOD && _votingPeriod <= MAX_VOTING_PERIOD,\n            \"PACT::initialize: invalid voting period\"\n        );\n        require(\n            _votingDelay >= MIN_VOTING_DELAY && _votingDelay <= MAX_VOTING_DELAY,\n            \"PACT::initialize: invalid voting delay\"\n        );\n        require(\n            _proposalThreshold >= MIN_PROPOSAL_THRESHOLD &&\n                _proposalThreshold <= MAX_PROPOSAL_THRESHOLD,\n            \"PACT::initialize: invalid proposal threshold\"\n        );\n        require(_quorumVotes >= _proposalThreshold, \"PACT::initialize: invalid quorum votes\");\n        timelock = TimelockInterface(_timelock);\n        require(_token != address(0), \"PACT::initialize: invalid _token address\");\n\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        transferOwnership(_timelock);\n\n        token = IHasVotes(_token);\n        releaseToken = IHasVotes(_releaseToken);\n        votingPeriod = _votingPeriod;\n        votingDelay = _votingDelay;\n        proposalThreshold = _proposalThreshold;\n        quorumVotes = _quorumVotes;\n\n        // Create dummy proposal\n        Proposal memory _dummyProposal = Proposal({\n            id: proposalCount,\n            proposer: address(this),\n            eta: 0,\n            startBlock: 0,\n            endBlock: 0,\n            forVotes: 0,\n            againstVotes: 0,\n            abstainVotes: 0,\n            canceled: true,\n            executed: false\n        });\n        proposalCount++;\n\n        proposals[_dummyProposal.id] = _dummyProposal;\n        latestProposalIds[_dummyProposal.proposer] = _dummyProposal.id;\n\n        emit ProposalCreated(\n            _dummyProposal.id,\n            address(this),\n            proposalTargets[_dummyProposal.id],\n            proposalValues[_dummyProposal.id],\n            proposalSignatures[_dummyProposal.id],\n            proposalCalldatas[_dummyProposal.id],\n            0,\n            0,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold.\n     * @param _targets Target addresses for proposal calls.\n     * @param _values Eth values for proposal calls.\n     * @param _signatures Function signatures for proposal calls.\n     * @param _calldatas Calldatas for proposal calls.\n     * @param _description String description of the proposal.\n     * @return Proposal id of new proposal.\n     */\n    function propose(\n        address[] memory _targets,\n        uint256[] memory _values,\n        string[] memory _signatures,\n        bytes[] memory _calldatas,\n        string memory _description\n    ) public returns (uint256) {\n        require(\n            getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold,\n            \"PACT::propose: proposer votes below proposal threshold\"\n        );\n        require(\n            _targets.length == _values.length &&\n                _targets.length == _signatures.length &&\n                _targets.length == _calldatas.length,\n            \"PACT::propose: proposal function information arity mismatch\"\n        );\n        require(_targets.length != 0, \"PACT::propose: must provide actions\");\n        require(_targets.length <= PROPOSAL_MAX_OPERATIONS, \"PACT::propose: too many actions\");\n\n        uint256 _latestProposalId = latestProposalIds[msg.sender];\n        if (_latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(_latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                \"PACT::propose: one live proposal per proposer, found an already active proposal\"\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                \"PACT::propose: one live proposal per proposer, found an already pending proposal\"\n            );\n        }\n\n        uint256 _startBlock = add256(block.number, votingDelay);\n        uint256 _endBlock = add256(_startBlock, votingPeriod);\n\n        Proposal memory _newProposal = Proposal({\n            id: proposalCount,\n            proposer: msg.sender,\n            eta: 0,\n            startBlock: _startBlock,\n            endBlock: _endBlock,\n            forVotes: 0,\n            againstVotes: 0,\n            abstainVotes: 0,\n            canceled: false,\n            executed: false\n        });\n        proposalCount++;\n\n        proposals[_newProposal.id] = _newProposal;\n        proposalTargets[_newProposal.id] = _targets;\n        proposalValues[_newProposal.id] = _values;\n        proposalSignatures[_newProposal.id] = _signatures;\n        proposalCalldatas[_newProposal.id] = _calldatas;\n        latestProposalIds[_newProposal.proposer] = _newProposal.id;\n\n        emit ProposalCreated(\n            _newProposal.id,\n            msg.sender,\n            _targets,\n            _values,\n            _signatures,\n            _calldatas,\n            _startBlock,\n            _endBlock,\n            _description\n        );\n        return _newProposal.id;\n    }\n\n    /**\n     * @notice Queues a proposal of state succeeded\n     * @param _proposalId The id of the proposal to queue\n     */\n    function queue(uint256 _proposalId) external {\n        require(\n            state(_proposalId) == ProposalState.Succeeded,\n            \"PACT::queue: proposal can only be queued if it is succeeded\"\n        );\n        Proposal storage _proposal = proposals[_proposalId];\n        uint256 _eta = add256(block.timestamp, timelock.delay());\n        uint256 _i;\n        uint256 _numberOfActions = proposalTargets[_proposalId].length;\n        for (; _i < _numberOfActions; _i++) {\n            queueOrRevertInternal(\n                proposalTargets[_proposalId][_i],\n                proposalValues[_proposalId][_i],\n                proposalSignatures[_proposalId][_i],\n                proposalCalldatas[_proposalId][_i],\n                _eta\n            );\n        }\n        _proposal.eta = _eta;\n        emit ProposalQueued(_proposalId, _eta);\n    }\n\n    function queueOrRevertInternal(\n        address _target,\n        uint256 _value,\n        string memory _signature,\n        bytes memory _data,\n        uint256 _eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(\n                keccak256(abi.encode(_target, _value, _signature, _data, _eta))\n            ),\n            \"PACT::queueOrRevertInternal: identical proposal action already queued at eta\"\n        );\n        timelock.queueTransaction(_target, _value, _signature, _data, _eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param _proposalId The id of the proposal to execute\n     */\n    function execute(uint256 _proposalId) external payable {\n        require(\n            state(_proposalId) == ProposalState.Queued,\n            \"PACT::execute: proposal can only be executed if it is queued\"\n        );\n        Proposal storage _proposal = proposals[_proposalId];\n        _proposal.executed = true;\n        uint256 _i;\n        uint256 _numberOfActions = proposalTargets[_proposalId].length;\n        for (; _i < _numberOfActions; _i++) {\n            timelock.executeTransaction{value: proposalValues[_proposalId][_i]}(\n                proposalTargets[_proposalId][_i],\n                proposalValues[_proposalId][_i],\n                proposalSignatures[_proposalId][_i],\n                proposalCalldatas[_proposalId][_i],\n                _proposal.eta\n            );\n        }\n        emit ProposalExecuted(_proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param _proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 _proposalId) external {\n        require(\n            state(_proposalId) != ProposalState.Executed,\n            \"PACT::cancel: cannot cancel executed proposal\"\n        );\n\n        Proposal storage _proposal = proposals[_proposalId];\n        require(\n            msg.sender == _proposal.proposer ||\n                getPriorVotes(_proposal.proposer, sub256(block.number, 1)) < proposalThreshold,\n            \"PACT::cancel: proposer above threshold\"\n        );\n\n        _proposal.canceled = true;\n        uint256 _i;\n        uint256 _numberOfActions = proposalTargets[_proposalId].length;\n        for (; _i < _numberOfActions; _i++) {\n            timelock.cancelTransaction(\n                proposalTargets[_proposalId][_i],\n                proposalValues[_proposalId][_i],\n                proposalSignatures[_proposalId][_i],\n                proposalCalldatas[_proposalId][_i],\n                _proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(_proposalId);\n    }\n\n    /**\n     * @notice Gets actions of a proposal.\n     * @param _proposalId Proposal to query.\n     * @return targets Target addresses for proposal calls.\n     * @return values Eth values for proposal calls.\n     * @return signatures Function signatures for proposal calls.\n     * @return calldatas Calldatas for proposal calls.\n     */\n    function getActions(uint256 _proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        return (\n            proposalTargets[_proposalId],\n            proposalValues[_proposalId],\n            proposalSignatures[_proposalId],\n            proposalCalldatas[_proposalId]\n        );\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param _proposalId the id of proposal\n     * @param _voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 _proposalId, address _voter)\n        external\n        view\n        returns (Receipt memory)\n    {\n        return proposalReceipts[_proposalId][_voter];\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param _proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 _proposalId) public view returns (ProposalState) {\n        require(proposalCount > _proposalId, \"PACT::state: invalid proposal id\");\n        Proposal storage _proposal = proposals[_proposalId];\n\n        if (_proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= _proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= _proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (\n            _proposal.forVotes <= _proposal.againstVotes || _proposal.forVotes < quorumVotes\n        ) {\n            return ProposalState.Defeated;\n        } else if (_proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (_proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(_proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param _proposalId The id of the proposal to vote on\n     * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 _proposalId, uint8 _support) external {\n        emit VoteCast(\n            msg.sender,\n            _proposalId,\n            _support,\n            castVoteInternal(msg.sender, _proposalId, _support),\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param _proposalId The id of the proposal to vote on\n     * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param _reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(\n        uint256 _proposalId,\n        uint8 _support,\n        string calldata _reason\n    ) external {\n        emit VoteCast(\n            msg.sender,\n            _proposalId,\n            _support,\n            castVoteInternal(msg.sender, _proposalId, _support),\n            _reason\n        );\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n     */\n    function castVoteBySig(\n        uint256 _proposalId,\n        uint8 _support,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        require(_v == 27 || _v == 28, \"PACT::castVoteBySig: invalid v value\");\n        require(\n            _s < 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A1,\n            \"PACT::castVoteBySig: invalid s value\"\n        );\n        bytes32 _domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainIdInternal(), address(this))\n        );\n        bytes32 _structHash = keccak256(abi.encode(BALLOT_TYPEHASH, _proposalId, _support));\n        bytes32 _digest = keccak256(abi.encodePacked(\"\\x19\\x01\", _domainSeparator, _structHash));\n        address _signatory = ecrecover(_digest, _v, _r, _s);\n        require(_signatory != address(0), \"PACT::castVoteBySig: invalid signature\");\n        emit VoteCast(\n            _signatory,\n            _proposalId,\n            _support,\n            castVoteInternal(_signatory, _proposalId, _support),\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param _voter The voter that is casting their vote\n     * @param _proposalId The id of the proposal to vote on\n     * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(\n        address _voter,\n        uint256 _proposalId,\n        uint8 _support\n    ) internal returns (uint96) {\n        require(\n            state(_proposalId) == ProposalState.Active,\n            \"PACT::castVoteInternal: voting is closed\"\n        );\n        require(_support <= 2, \"PACT::castVoteInternal: invalid vote type\");\n        Proposal storage _proposal = proposals[_proposalId];\n        Receipt storage _receipt = proposalReceipts[_proposalId][_voter];\n        require(!_receipt.hasVoted, \"PACT::castVoteInternal: voter already voted\");\n        uint96 _votes = getPriorVotes(_voter, _proposal.startBlock);\n\n        if (_support == 0) {\n            _proposal.againstVotes = add256(_proposal.againstVotes, _votes);\n        } else if (_support == 1) {\n            _proposal.forVotes = add256(_proposal.forVotes, _votes);\n        } else if (_support == 2) {\n            _proposal.abstainVotes = add256(_proposal.abstainVotes, _votes);\n        }\n\n        _receipt.hasVoted = true;\n        _receipt.support = _support;\n        _receipt.votes = _votes;\n\n        return _votes;\n    }\n\n    /**\n     * @notice Owner function for setting the voting delay\n     * @param _newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint256 _newVotingDelay) external virtual onlyOwner {\n        require(\n            _newVotingDelay >= MIN_VOTING_DELAY && _newVotingDelay <= MAX_VOTING_DELAY,\n            \"PACT::_setVotingDelay: invalid voting delay\"\n        );\n        uint256 _oldVotingDelay = votingDelay;\n        votingDelay = _newVotingDelay;\n\n        emit VotingDelaySet(_oldVotingDelay, _newVotingDelay);\n    }\n\n    /**\n     * @notice Owner function for setting the quorum votes\n     * @param _newQuorumVotes new quorum votes\n     */\n    function _setQuorumVotes(uint256 _newQuorumVotes) external onlyOwner {\n        require(\n            _newQuorumVotes >= proposalThreshold,\n            \"PACT::_setQuorumVotes: invalid quorum votes\"\n        );\n\n        emit QuorumVotesSet(quorumVotes, _newQuorumVotes);\n        quorumVotes = _newQuorumVotes;\n    }\n\n    /**\n     * @notice Owner function for setting the voting period\n     * @param _newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint256 _newVotingPeriod) external virtual onlyOwner {\n        require(\n            _newVotingPeriod >= MIN_VOTING_PERIOD && _newVotingPeriod <= MAX_VOTING_PERIOD,\n            \"PACT::_setVotingPeriod: invalid voting period\"\n        );\n        emit VotingPeriodSet(votingPeriod, _newVotingPeriod);\n        votingPeriod = _newVotingPeriod;\n    }\n\n    /**\n     * @notice Owner function for setting the proposal threshold\n     * @dev _newProposalThreshold must be greater than the hardcoded min\n     * @param _newProposalThreshold new proposal threshold\n     */\n    function _setProposalThreshold(uint256 _newProposalThreshold) external onlyOwner {\n        require(\n            _newProposalThreshold >= MIN_PROPOSAL_THRESHOLD &&\n                _newProposalThreshold <= MAX_PROPOSAL_THRESHOLD,\n            \"PACT::_setProposalThreshold: invalid proposal threshold\"\n        );\n        emit ProposalThresholdSet(proposalThreshold, _newProposalThreshold);\n        proposalThreshold = _newProposalThreshold;\n    }\n\n    /**\n     * @notice Owner function for setting the release token\n     * @param _newReleaseToken new release token address\n     */\n    function _setReleaseToken(IHasVotes _newReleaseToken) external onlyOwner {\n        require(\n            _newReleaseToken != token,\n            \"PACT::_setReleaseToken: releaseToken and token must be different\"\n        );\n        emit ReleaseTokenSet(address(releaseToken), address(_newReleaseToken));\n        releaseToken = _newReleaseToken;\n    }\n\n    function getPriorVotes(address _voter, uint256 _beforeBlock) public view returns (uint96) {\n        if (address(releaseToken) == address(0)) {\n            return token.getPriorVotes(_voter, _beforeBlock);\n        }\n        return\n            add96(\n                token.getPriorVotes(_voter, _beforeBlock),\n                releaseToken.getPriorVotes(_voter, _beforeBlock),\n                \"getPriorVotes overflow\"\n            );\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from this contract to an address\n     *\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner nonReentrant {\n        IERC20Upgradeable(address(_token)).safeTransfer(_to, _amount);\n\n        emit TransferERC20(address(_token), _to, _amount);\n    }\n\n    function add256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 _c = _a + _b;\n        require(_c >= _a, \"addition overflow\");\n        return _c;\n    }\n\n    function sub256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, \"subtraction underflow\");\n        return _a - _b;\n    }\n\n    function getChainIdInternal() internal view returns (uint256) {\n        uint256 _chainId;\n        assembly {\n            _chainId := chainid()\n        }\n        return _chainId;\n    }\n\n    function add96(\n        uint96 _a,\n        uint96 _b,\n        string memory _errorMessage\n    ) internal pure returns (uint96) {\n        uint96 _c = _a + _b;\n        require(_c >= _a, _errorMessage);\n        return _c;\n    }\n}\n"
    },
    "contracts/vesting/ImpactLabsVestingImplementation.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./interfaces/ImpactLabsVestingStorageV1.sol\";\n\ncontract ImpactLabsVestingImplementation is\n    Initializable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ImpactLabsVestingStorageV1\n{\n    using SafeERC20Upgradeable for IERC20;\n\n    /**\n     * @notice Triggered when ImpactLabs has claimed\n     *\n     * @param amount      Value of the claim\n     */\n    event Claimed(uint256 amount);\n\n    /**\n     * @notice Triggered when advancePayment has been decreased\n     *\n     * @param amount                  Value of the decrease\n     * @param advancePaymentLeft      Value of the advancePayment left\n     */\n    event AdvancePaymentDecreased(uint256 amount, uint256 advancePaymentLeft);\n\n    /**\n     * @notice Triggered when an amount of an ERC20 has been transferred from this contract to an address\n     *\n     * @param token               ERC20 token address\n     * @param to                  Address of the receiver\n     * @param amount              Amount of the transaction\n     */\n    event TransferERC20(address indexed token, address indexed to, uint256 amount);\n\n    /**\n     * @notice Used to initialize a new ImpactLabsVesting contract\n     * !!! before calling this method, you must ensure that there is enough PACTs on the contract address\n     *\n     * @param _impactLabs           Address of the ImpactLabs\n     * @param _PACT                 Address of the PACT Token\n     * @param _advancePayment       The amount of PACT that will be given in advance to ImpactLabs\n     */\n    function initialize(\n        address _impactLabs,\n        IERC20 _PACT,\n        IDonationMiner _donationMiner,\n        uint256 _advancePayment\n    ) public initializer {\n        require(\n            address(_impactLabs) != address(0),\n            \"ImpactLabsVesting::initialize: impactLabs_ address not set\"\n        );\n        require(\n            address(_PACT) != address(0),\n            \"ImpactLabsVesting::initialize: PACT address not set\"\n        );\n        require(\n            address(_donationMiner) != address(0),\n            \"ImpactLabsVesting::initialize: donationMiner_ address not set\"\n        );\n\n        __Ownable_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        impactLabs = _impactLabs;\n        PACT = _PACT;\n        donationMiner = _donationMiner;\n        advancePayment = _advancePayment;\n        nextRewardPeriod = 1;\n\n        transferToImpactLabs(_advancePayment);\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice Transfers PACT to ImpactLabs\n     * it will not be transferred PACTs to ImpactLabs until\n     * the entire amount payed in advance will be covered\n     */\n    function claim() external override whenNotPaused {\n        uint256 _index = nextRewardPeriod;\n        uint256 _rewardPeriodCount = donationMiner.rewardPeriodCount();\n\n        uint256 _rewardPerBlock;\n        uint256 _startBlock;\n        uint256 _endBlock;\n        uint256 _claimAmount;\n\n        while (_index <= _rewardPeriodCount) {\n            (_rewardPerBlock, , _startBlock, _endBlock, , , , ) = donationMiner.rewardPeriods(\n                _index\n            );\n\n            if (_endBlock >= block.number) {\n                break;\n            }\n\n            _claimAmount += ((_endBlock - _startBlock + 1) * _rewardPerBlock * 3) / 4;\n            _index++;\n        }\n\n        // if advancePayment is zero it means that all the entire amount payed in advance has been covered\n        if (advancePayment == 0) {\n            transferToImpactLabs(_claimAmount);\n        } else if (advancePayment >= _claimAmount) {\n            // if the claim amount is lesser than the amount of PACTs that is still given in advance\n            // it decrease advancePayment value\n            // it doesn't transfer PACTs to ImpactLabs\n            advancePayment -= _claimAmount;\n            emit AdvancePaymentDecreased(_claimAmount, advancePayment);\n        } else {\n            // if the claim amount is greater than the amount of PACTs that is still given in advance\n            // it decrease advancePayment to 0\n            // it transfer the difference to ImpactLabs\n            uint256 toTransfer = _claimAmount - advancePayment;\n            advancePayment = 0;\n\n            emit AdvancePaymentDecreased(_claimAmount - toTransfer, 0);\n            transferToImpactLabs(toTransfer);\n        }\n\n        nextRewardPeriod = _index;\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from this contract to an address\n     *\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyOwner nonReentrant {\n        IERC20Upgradeable(address(_token)).safeTransfer(_to, _amount);\n\n        emit TransferERC20(address(_token), _to, _amount);\n    }\n\n    /**\n     * @notice Transfers an amount of PACTs from this contract to impactLabs address\n     *\n     * @param _amount amount of the transaction\n     */\n    function transferToImpactLabs(uint256 _amount) internal nonReentrant {\n        if (_amount > 0) {\n            require(\n                PACT.balanceOf(address(this)) >= _amount,\n                \"ImpactLabsVesting::transferToImpactLabs: ERR_REWARD_TOKEN_BALANCE\"\n            );\n            IERC20Upgradeable(address(PACT)).safeTransfer(impactLabs, _amount);\n        }\n\n        emit Claimed(_amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/vesting/interfaces/ImpactLabsVestingStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./IImpactLabsVesting.sol\";\n\n/**\n * @title Storage for ImpactLabsVesting\n * @notice For future upgrades, do not change ImpactLabsVestingStorageV1. Create a new\n * contract which implements ImpactLabsVestingStorageV1 and following the naming convention\n * ImpactLabsVestingStorageVx.\n */\nabstract contract ImpactLabsVestingStorageV1 is IImpactLabsVesting {\n    address public override impactLabs;\n    IERC20 public override PACT;\n    IDonationMiner public override donationMiner;\n\n    uint256 public override nextRewardPeriod;\n    uint256 public override advancePayment;\n}\n"
    },
    "contracts/vesting/interfaces/IImpactLabsVesting.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../community/interfaces/ICommunityAdmin.sol\";\nimport \"../../treasury/interfaces/ITreasury.sol\";\nimport \"../../donationMiner/interfaces/IDonationMiner.sol\";\n\ninterface IImpactLabsVesting {\n    function getVersion() external pure returns (uint256);\n    function impactLabs() external view returns (address);\n    function PACT() external view returns (IERC20);\n    function donationMiner() external view returns (IDonationMiner);\n    function nextRewardPeriod() external view returns (uint256);\n    function advancePayment() external view returns (uint256);\n    function claim() external;\n    function transfer(IERC20 _token, address _to, uint256 _amount) external;\n}\n"
    },
    "contracts/community/interfaces/ICommunityAdmin.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"./ICommunity.sol\";\nimport \"../../treasury/interfaces/ITreasury.sol\";\nimport \"../../governor/impactMarketCouncil/interfaces/IImpactMarketCouncil.sol\";\nimport \"../../ambassadors/interfaces/IAmbassadors.sol\";\n\ninterface ICommunityAdmin {\n    enum CommunityState {\n        NONE,\n        Valid,\n        Removed,\n        Migrated\n    }\n\n    function getVersion() external pure returns(uint256);\n    function cUSD() external view returns(IERC20);\n    function treasury() external view returns(ITreasury);\n    function impactMarketCouncil() external view returns(IImpactMarketCouncil);\n    function ambassadors() external view returns(IAmbassadors);\n    function communityMiddleProxy() external view returns(address);\n    function authorizedWalletAddress() external view returns(address);\n    function minClaimAmountRatio() external view returns(uint256);\n    function minClaimAmountRatioPrecision() external view returns(uint256);\n    function communities(address _community) external view returns(CommunityState);\n    function communityImplementation() external view returns(ICommunity);\n    function communityProxyAdmin() external view returns(ProxyAdmin);\n    function communityListAt(uint256 _index) external view returns (address);\n    function communityListLength() external view returns (uint256);\n    function treasurySafetyPercentage() external view returns (uint256);\n    function treasuryMinBalance() external view returns (uint256);\n    function isAmbassadorOrEntityOfCommunity(address _community, address _ambassadorOrEntity) external view returns (bool);\n    function updateTreasury(ITreasury _newTreasury) external;\n    function updateImpactMarketCouncil(IImpactMarketCouncil _newImpactMarketCouncil) external;\n    function updateAmbassadors(IAmbassadors _newAmbassadors) external;\n    function updateCommunityMiddleProxy(address _communityMiddleProxy) external;\n    function updateCommunityImplementation(ICommunity _communityImplementation_) external;\n    function updateAuthorizedWalletAddress(address _newSignerAddress) external;\n    function updateMinClaimAmountRatio(uint256 _newMinClaimAmountRatio) external;\n    function updateTreasurySafetyPercentage(uint256 _newTreasurySafetyPercentage) external;\n    function updateTreasuryMinBalance(uint256 _newTreasuryMinBalance) external;\n    function setCommunityToAmbassador(address _ambassador, ICommunity _communityAddress) external;\n    function updateBeneficiaryParams(\n        ICommunity _community,\n        uint256 _claimAmount,\n        uint256 _maxClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval,\n        uint256 _maxBeneficiaries\n    ) external;\n    function updateCommunityParams(\n        ICommunity _community,\n        uint256 _minTranche,\n        uint256 _maxTranche\n    ) external;\n    function updateProxyImplementation(address _communityMiddleProxy, address _newLogic) external;\n    function updateCommunityToken(\n        ICommunity _community,\n        IERC20 _newToken,\n        bytes memory _exchangePath,\n        uint256 _claimAmount,\n        uint256 _maxClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval\n    ) external;\n    function addCommunity(\n        address _tokenAddress,\n        address[] memory _managers,\n        address _ambassador,\n        uint256 _claimAmount,\n        uint256 _maxClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval,\n        uint256 _minTranche,\n        uint256 _maxTranche,\n        uint256 _maxBeneficiaries\n    ) external;\n    function migrateCommunity(\n        address[] memory _managers,\n        ICommunity _previousCommunity\n    ) external;\n    function splitCommunity(\n        ICommunity _community,\n        uint256 _numberOfCopies,\n        address _ambassador,\n        address[] memory _managers\n    ) external;\n    function removeCommunity(ICommunity _community) external;\n    function fundCommunity() external returns(uint256);\n    function transferToBeneficiary(IERC20 _token, address beneficiary, uint256 amount) external;\n    function calculateCommunityTrancheAmount(ICommunity _community) external view returns (uint256);\n    function transfer(IERC20 _token, address _to, uint256 _amount) external;\n    function transferFromCommunity(\n        ICommunity _community,\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external;\n    function getCommunityProxyImplementation(address _communityProxyAddress) external view returns(address);\n}\n"
    },
    "contracts/treasury/interfaces/ITreasury.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../community/interfaces/ICommunityAdmin.sol\";\nimport \"../../treasuryLpSwap/interfaces/ITreasuryLpSwap.sol\";\nimport \"../../donationMiner/interfaces/IDonationMiner.sol\";\n\ninterface ITreasury {\n    enum LpStrategy {     //strategy to use for splitting the LP fees between treasury and buyback\n        NONE,             //all funds remains into treasury\n        MainCoin,         //for UBI coins (like cUSD): UBI coin fees are kept in treasury, PACT fees are used for buyback\n        SecondaryCoin     //for non UBI coins (like cEUR): half of the fees are swapped to PACT and used for buyback,\n                          // half of the fees are swapped to cUSD and kept in treasury\n                          // (PACT fees are used for buyback)\n    }\n\n    struct Token {\n        uint256 rate;                          //rate of the token in CUSD\n        LpStrategy lpStrategy;                 //strategy to use for splitting the LP fees between treasury and buyback\n        uint256 lpPercentage;                  //percentage of the funds to be used for LP\n        uint256 lpMinLimit;                    //minimum amount of funds that need to be in the treasury (and not to be used for LP)\n        uint256 uniswapNFTPositionManagerId;   //id of the NFT position manager\n        bytes exchangePathToCUSD;              //uniswap path to exchange the token to CUSD\n        bytes exchangePathToPACT;              //uniswap path to exchange the token to PACT\n    }\n\n    function getVersion() external pure returns(uint256);\n    function communityAdmin() external view returns(ICommunityAdmin);\n    function lpSwap() external view returns(ITreasuryLpSwap);\n    function PACT() external view returns (IERC20);\n    function donationMiner() external view returns (IDonationMiner);\n    function updateCommunityAdmin(ICommunityAdmin _communityAdmin) external;\n    function updateLpSwap(ITreasuryLpSwap _lpSwap) external;\n    function updatePACT(IERC20 _newPACT) external;\n    function updateDonationMiner(IDonationMiner _newDonationMiner) external;\n    function transfer(IERC20 _token, address _to, uint256 _amount) external;\n    function isToken(address _tokenAddress) external view returns (bool);\n    function tokenListLength() external view returns (uint256);\n    function tokenListAt(uint256 _index) external view returns (address);\n    function tokens(address _tokenAddress) external view returns (\n        uint256 rate,\n        LpStrategy lpStrategy,\n        uint256 lpPercentage,\n        uint256 lpMinLimit,\n        uint256 uniswapNFTPositionManagerId,\n        bytes calldata exchangePathToCUSD,\n        bytes calldata exchangePathToPACT\n    );\n    function setToken(\n        address _tokenAddress,\n        uint256 _rate,\n        LpStrategy _lpStrategy,\n        uint256 _lpPercentage,\n        uint256 _lpMinLimit,\n        uint256 _uniswapNFTPositionManagerId,\n        bytes memory _exchangePathToCUSD,\n        bytes memory _exchangePathToPACT\n    ) external;\n    function removeToken(address _tokenAddress) external;\n    function getConvertedAmount(address _tokenAddress, uint256 _amount) external returns (uint256);\n    function convertAmount(\n        address _tokenAddress,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        bytes memory _exchangePath\n    ) external;\n    function useFundsForLP() external;\n    function collectFees(uint256 _uniswapNFTPositionManagerId) external;\n}\n"
    },
    "contracts/donationMiner/interfaces/IDonationMiner.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../community/interfaces/ICommunityAdmin.sol\";\nimport \"../../community/interfaces/ICommunity.sol\";\nimport \"../../treasury/interfaces/ITreasury.sol\";\nimport \"../../staking/interfaces/IStaking.sol\";\nimport \"../../airdropV3/interfaces/IAirdropV3.sol\";\nimport \"../../microcredit/interfaces/IMicrocredit.sol\";\n\ninterface IDonationMiner {\n    struct RewardPeriod {\n        //reward tokens created per block\n        uint256 rewardPerBlock;\n        //reward tokens from previous periods + reward tokens from this reward period\n        uint256 rewardAmount;\n        //block number at which reward period starts\n        uint256 startBlock;\n        //block number at which reward period ends\n        uint256 endBlock;\n        //total of donations for this rewardPeriod\n        uint256 donationsAmount;\n        //amounts donated by every donor in this rewardPeriod\n        mapping(address => uint256) donorAmounts;\n        uint256 againstPeriods;\n        //total stake amount at the end of this rewardPeriod\n        uint256 stakesAmount;\n        //ratio between 1 cUSD donated and 1 PACT staked\n        uint256 stakingDonationRatio;\n        //true if user has staked/unstaked in this reward period\n        mapping(address => bool) hasSetStakeAmount;\n        //stake amount of a user at the end of this reward period;\n        //if a user doesn't stake/unstake in a reward period,\n        //              this value will remain 0 (and hasSetStakeAmount will be false)\n        //if hasNewStakeAmount is false it means the donorStakeAmount\n        //              is the same as the last reward period where hasSetStakeAmount is true\n        mapping(address => uint256) donorStakeAmounts;\n    }\n\n    struct Donor {\n        uint256 lastClaim;  //last reward period index for which the donor has claimed the reward; used until v2\n        uint256 rewardPeriodsCount; //total number of reward periods in which the donor donated\n        mapping(uint256 => uint256) rewardPeriods; //list of all reward period ids in which the donor donated\n        uint256 lastClaimPeriod; //last reward period id for which the donor has claimed the reward\n    }\n\n    struct Donation {\n        address donor;  //address of the donner\n        address target;  //address of the receiver (community or treasury)\n        uint256 rewardPeriod;  //number of the reward period in which the donation was made\n        uint256 blockNumber;  //number of the block in which the donation was executed\n        uint256 amount;  //the convertedAmount value\n        IERC20 token;  //address of the token\n        uint256 initialAmount;  //number of tokens donated\n    }\n\n    function getVersion() external pure returns(uint256);\n    function cUSD() external view returns (IERC20);\n    function PACT() external view returns (IERC20);\n    function treasury() external view returns (ITreasury);\n    function staking() external view returns (IStaking);\n    function airdropV3() external view returns (IAirdropV3);\n    function microcredit() external view returns (IMicrocredit);\n    function rewardPeriodSize() external view returns (uint256);\n    function decayNumerator() external view returns (uint256);\n    function decayDenominator() external view returns (uint256);\n    function stakingDonationRatio() external view returns (uint256);\n    function communityDonationRatio() external view returns (uint256);\n    function rewardPeriodCount() external view returns (uint256);\n    function donationCount() external view returns (uint256);\n    function rewardPeriods(uint256 _period) external view returns (\n        uint256 rewardPerBlock,\n        uint256 rewardAmount,\n        uint256 startBlock,\n        uint256 endBlock,\n        uint256 donationsAmount,\n        uint256 againstPeriods,\n        uint256 stakesAmount,\n        uint256 stakingDonationRatio\n\n);\n    function rewardPeriodDonorAmount(uint256 _period, address _donor) external view returns (uint256);\n    function rewardPeriodDonorStakeAmounts(uint256 _period, address _donor) external view returns (uint256);\n    function donors(address _donor) external view returns (\n        uint256 rewardPeriodsCount,\n        uint256 lastClaim,\n        uint256 lastClaimPeriod\n    );\n    function donorRewardPeriod(address _donor, uint256 _rewardPeriodIndex) external view returns (uint256);\n    function donations(uint256 _index) external view returns (\n        address donor,\n        address target,\n        uint256 rewardPeriod,\n        uint256 blockNumber,\n        uint256 amount,\n        IERC20 token,\n        uint256 initialAmount\n    );\n    function claimDelay() external view returns (uint256);\n    function againstPeriods() external view returns (uint256);\n    function updateRewardPeriodParams(\n        uint256 _newRewardPeriodSize,\n        uint256 _newDecayNumerator,\n        uint256 _newDecayDenominator\n    ) external;\n    function updateClaimDelay(uint256 _newClaimDelay) external;\n    function updateStakingDonationRatio(uint256 _newStakingDonationRatio) external;\n    function updateCommunityDonationRatio(uint256 _newCommunityDonationRatio) external;\n    function updateAgainstPeriods(uint256 _newAgainstPeriods) external;\n    function updateTreasury(ITreasury _newTreasury) external;\n    function updateStaking(IStaking _newStaking) external;\n    function updateAirdropV3(IAirdropV3 _newAirdropV3) external;\n    function updateMicrocredit(IMicrocredit newMicrocredit) external;\n    function donate(IERC20 _token, uint256 _amount, address _delegateAddress) external;\n    function donateToCommunity(ICommunity _community, IERC20 _token, uint256 _amount, address _delegateAddress) external;\n    function donateVirtual(uint256 _amount, address _delegateAddress) external;\n    function claimRewards() external;\n    function claimRewardsPartial(uint256 _lastPeriodNumber) external;\n    function stakeRewards() external;\n    function stakeRewardsPartial(uint256 _lastPeriodNumber) external;\n    function calculateClaimableRewards(address _donor) external returns (uint256);\n    function calculateClaimableRewardsByPeriodNumber(address _donor, uint256 _lastPeriodNumber) external returns (uint256);\n    function estimateClaimableReward(address _donor) external view returns (uint256);\n    function estimateClaimableRewardAdvance(address _donor) external view returns (uint256);\n    function estimateClaimableRewardByStaking(address _donor) external view returns (uint256);\n    function apr(address _stakeholderAddress) external view returns (uint256);\n    function generalApr() external view returns (uint256);\n    function lastPeriodsDonations(address _donor) external view returns (uint256 donorAmount, uint256 totalAmount);\n    function transfer(IERC20 _token, address _to, uint256 _amount) external;\n    function setStakingAmounts(address _holderAddress, uint256 _holderStakeAmount, uint256 _totalStakesAmount) external;\n    function currentRewardPeriodNumber() external view returns (uint256);\n\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "contracts/community/interfaces/ICommunity.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"./ICommunityAdmin.sol\";\n\ninterface ICommunity {\n    enum BeneficiaryState {\n        NONE, //the beneficiary hasn't been added yet\n        Valid,\n        Locked,\n        Removed,\n        AddressChanged,\n        Copied  //the beneficiary has been moved in a copy community\n    }\n\n    struct Beneficiary {\n        BeneficiaryState state;  //beneficiary state\n        uint256 claims;          //total number of claims\n        uint256 claimedAmount;   //total amount of tokens received\n                                 //(based on token ratios when there are more than one token)\n        uint256 lastClaim;       //block number of the last claim\n        mapping(address => uint256) claimedAmounts;\n    }\n\n    struct TokenUpdates {\n        address tokenAddress;    //address of the token\n        uint256 ratio;           //ratio between maxClaim and previous token maxClaim\n        uint256 startBlock;      //the number of the block from which the this token was \"active\"\n    }\n\n    function initialize(\n        address _tokenAddress,\n        address[] memory _managers,\n        uint256 _claimAmount,\n        uint256 _maxClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval,\n        uint256 _minTranche,\n        uint256 _maxTranche,\n        uint256 _maxBeneficiaries,\n        ICommunity _previousCommunity\n    ) external;\n    function getVersion() external pure returns(uint256);\n    function previousCommunity() external view returns(ICommunity);\n    function copyOf() external view returns(ICommunity);\n    function copies() external view returns(address[] memory);\n    function originalClaimAmount() external view returns(uint256);\n    function claimAmount() external view returns(uint256);\n    function baseInterval() external view returns(uint256);\n    function incrementInterval() external view returns(uint256);\n    function maxClaim() external view returns(uint256);\n    function maxTotalClaim() external view returns(uint256);\n    function validBeneficiaryCount() external view returns(uint);\n    function maxBeneficiaries() external view returns(uint);\n    function treasuryFunds() external view returns(uint);\n    function privateFunds() external view returns(uint);\n    function communityAdmin() external view returns(ICommunityAdmin);\n    function cUSD() external view  returns(IERC20);\n    function token() external view  returns(IERC20);\n    function tokenList() external view returns(address[] memory);\n    function locked() external view returns(bool);\n    function beneficiaries(address _beneficiaryAddress) external view returns(\n        BeneficiaryState state,\n        uint256 claims,\n        uint256 claimedAmount,\n        uint256 lastClaim\n    );\n    function beneficiaryClaimedAmounts(address _beneficiaryAddress) external view\n        returns (uint256[] memory claimedAmounts);\n    function decreaseStep() external view returns(uint);\n    function beneficiaryListAt(uint256 _index) external view returns (address);\n    function beneficiaryListLength() external view returns (uint256);\n    function impactMarketAddress() external pure returns (address);\n    function minTranche() external view returns(uint256);\n    function maxTranche() external view returns(uint256);\n    function lastFundRequest() external view returns(uint256);\n    function tokenUpdates(uint256 _index) external view returns (\n        address tokenAddress,\n        uint256 ratio,\n        uint256 startBlock\n    );\n    function tokenUpdatesLength() external view returns (uint256);\n    function isSelfFunding() external view returns (bool);\n    function setBeneficiaryState(address _beneficiaryAddress, BeneficiaryState _state) external;\n    function updateCommunityAdmin(ICommunityAdmin _communityAdmin) external;\n    function updatePreviousCommunity(ICommunity _newPreviousCommunity) external;\n    function updateBeneficiaryParams(\n        uint256 _claimAmount,\n        uint256 _maxClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval\n    ) external;\n    function updateCommunityParams(\n        uint256 _minTranche,\n        uint256 _maxTranche\n    ) external;\n    function updateMaxBeneficiaries(uint256 _newMaxBeneficiaries) external;\n    function updateToken(\n        IERC20 _newToken,\n        bytes calldata _exchangePath,\n        uint256 _claimAmount,\n        uint256 _maxClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval\n    ) external;\n    function donate(address _sender, uint256 _amount) external;\n    function transfer(IERC20 _token, address _to, uint256 _amount) external;\n    function addManager(address _managerAddress) external;\n    function removeManager(address _managerAddress) external;\n    function addBeneficiary(address _beneficiaryAddress) external;\n    function addBeneficiaries(address[] memory _beneficiaryAddresses) external;\n    function addBeneficiariesUsingSignature(\n        address[] memory _beneficiaryAddresses,\n        uint256 _expirationTimestamp,\n        bytes calldata _signature\n    ) external;\n    function copyBeneficiaries(address[] memory _beneficiaryAddresses) external;\n    function lockBeneficiary(address _beneficiaryAddress) external;\n    function lockBeneficiaries(address[] memory _beneficiaryAddresses) external;\n    function lockBeneficiariesUsingSignature(\n        address[] memory _beneficiaryAddresses,\n        uint256 _expirationTimestamp,\n        bytes calldata _signature\n    ) external;\n    function unlockBeneficiary(address _beneficiaryAddress) external;\n    function unlockBeneficiaries(address[] memory _beneficiaryAddresses) external;\n    function unlockBeneficiariesUsingSignature(\n        address[] memory _beneficiaryAddresses,\n        uint256 _expirationTimestamp,\n        bytes calldata _signature\n    ) external;\n    function removeBeneficiary(address _beneficiaryAddress) external;\n    function removeBeneficiaries(address[] memory _beneficiaryAddresses) external;\n    function removeBeneficiariesUsingSignature(\n        address[] memory _beneficiaryAddresses,\n        uint256 _expirationTimestamp,\n        bytes calldata _signature\n    ) external;\n    function changeBeneficiaryAddressByManager(address _oldBeneficiaryAddress, address _newBeneficiaryAddress) external;\n    function changeBeneficiaryAddress(address _newBeneficiaryAddress) external;\n    function claim() external;\n    function lastInterval(address _beneficiaryAddress) external view returns (uint256);\n    function claimCooldown(address _beneficiaryAddress) external view returns (uint256);\n    function lock() external;\n    function unlock() external;\n    function requestFunds() external;\n    function beneficiaryJoinFromMigrated(address _beneficiaryAddress) external;\n    function getInitialMaxClaim() external view returns (uint256);\n    function addCopy(ICommunity _copy) external;\n    function copyCommunityDetails(ICommunity _originalCommunity) external;\n}\n"
    },
    "contracts/governor/impactMarketCouncil/interfaces/IImpactMarketCouncil.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\ninterface IImpactMarketCouncil {\n    struct Proposal {\n        // Unique id for looking up a proposal\n        uint256 id;\n        // Creator of the proposal\n        address proposer;\n        // The block at which voting ends: votes must be cast prior to this block\n        uint256 endBlock;\n        // Current number of votes in favor of this proposal\n        uint256 forVotes;\n        // Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n        // Current number of votes for abstaining for this proposal\n        uint256 abstainVotes;\n        // Flag marking whether the proposal has been canceled\n        bool canceled;\n        // Flag marking whether the proposal has been executed\n        bool executed;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        // Whether or not a vote has been cast\n        bool hasVoted;\n        // Whether or not the voter supports the proposal or abstains\n        uint8 support;\n        // The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Expired,\n        Succeeded,\n        Executed\n    }\n}\n"
    },
    "contracts/ambassadors/interfaces/IAmbassadors.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\ninterface IAmbassadors {\n    function getVersion() external pure returns(uint256);\n    function isAmbassador(address _ambassador) external view returns (bool);\n    function isAmbassadorOf(address _ambassador, address _community) external view returns (bool);\n    function isEntityOf(address _ambassador, address _entityAddress) external view returns (bool);\n    function isAmbassadorAt(address _ambassador, address _entityAddress) external view returns (bool);\n\n    function addEntity(address _entity) external;\n    function removeEntity(address _entity) external;\n    function replaceEntityAccount(address _entity, address _newEntity) external;\n    function addAmbassador(address _ambassador) external;\n    function removeAmbassador(address _ambassador) external;\n    function replaceAmbassadorAccount(address _ambassador, address _newAmbassador) external;\n    function replaceAmbassador(address _oldAmbassador, address _newAmbassador) external;\n    function transferAmbassador(address _ambassador, address _toEntity, bool _keepCommunities) external;\n    function transferCommunityToAmbassador(address _to, address _community) external;\n    function setCommunityToAmbassador(address _ambassador, address _community) external;\n    function removeCommunity(address _community) external;\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/treasuryLpSwap/interfaces/ITreasuryLpSwap.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../treasury/interfaces/ITreasury.sol\";\nimport \"../../externalInterfaces/uniswapV3/INonfungiblePositionManager.sol\";\nimport \"../../externalInterfaces/uniswapV3/IUniswapRouter02.sol\";\nimport \"../../externalInterfaces/uniswapV3/IQuoter.sol\";\n\ninterface ITreasuryLpSwap {\n    function getVersion() external pure returns(uint256);\n    function treasury() external view returns(ITreasury);\n    function uniswapRouter() external view returns(IUniswapRouter02);\n    function uniswapQuoter() external view returns(IQuoter);\n    function uniswapNFTPositionManager() external view returns(INonfungiblePositionManager);\n    function updateTreasury(ITreasury _treasury) external;\n    function updateUniswapRouter(IUniswapRouter02 _uniswapRouter) external;\n    function updateUniswapQuoter(IQuoter _uniswapQuoter) external;\n    function updateUniswapNFTPositionManager(INonfungiblePositionManager _newUniswapNFTPositionManager) external;\n    function transfer(IERC20 _token, address _to, uint256 _amount) external;\n    function convertAmount(\n        address _tokenAddress,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        bytes memory _exchangePath\n    ) external;\n    function addToLp(IERC20 _token, uint256 _amount) external;\n    function collectFees(uint256 _uniswapNFTPositionManagerId) external returns (uint256 amount0, uint256 amount1);\n    function decreaseLiquidity(uint256 _uniswapNFTPositionManagerId, uint128 _liquidityAmount) external returns (uint256 amount0, uint256 amount1);\n}\n"
    },
    "contracts/externalInterfaces/uniswapV3/INonfungiblePositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.4;\npragma abicoder v2;\n\n/// @title Non-fungible token for positions\n/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred\n/// and authorized.\ninterface INonfungiblePositionManager\n{\n    /// @notice Emitted when liquidity is increased for a position NFT\n    /// @dev Also emitted when a token is minted\n    /// @param tokenId The ID of the token for which liquidity was increased\n    /// @param liquidity The amount by which liquidity for the NFT position was increased\n    /// @param amount0 The amount of token0 that was paid for the increase in liquidity\n    /// @param amount1 The amount of token1 that was paid for the increase in liquidity\n    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n    /// @notice Emitted when liquidity is decreased for a position NFT\n    /// @param tokenId The ID of the token for which liquidity was decreased\n    /// @param liquidity The amount by which liquidity for the NFT position was decreased\n    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity\n    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity\n    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n    /// @notice Emitted when tokens are collected for a position NFT\n    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior\n    /// @param tokenId The ID of the token for which underlying tokens were collected\n    /// @param recipient The address of the account that received the collected tokens\n    /// @param amount0 The amount of token0 owed to the position that was collected\n    /// @param amount1 The amount of token1 owed to the position that was collected\n    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);\n\n    /// @notice Returns the position information associated with a given token ID.\n    /// @dev Throws if the token ID is not valid.\n    /// @param tokenId The ID of the token that represents the position\n    /// @return nonce The nonce for permits\n    /// @return operator The address that is approved for spending\n    /// @return token0 The address of the token0 for a specific pool\n    /// @return token1 The address of the token1 for a specific pool\n    /// @return fee The fee associated with the pool\n    /// @return tickLower The lower end of the tick range for the position\n    /// @return tickUpper The higher end of the tick range for the position\n    /// @return liquidity The liquidity of the position\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n    /// @return tokenId The ID of the token that represents the minted position\n    /// @return liquidity The amount of liquidity for this position\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\n    /// amount0Desired The desired amount of token0 to be spent,\n    /// amount1Desired The desired amount of token1 to be spent,\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return liquidity The new liquidity amount as a result of the increase\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\n    /// amount The amount by which liquidity will be decreased,\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\n    /// recipient The account that should receive the tokens,\n    /// amount0Max The maximum amount of token0 to collect,\n    /// amount1Max The maximum amount of token1 to collect\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n    /// must be collected first.\n    /// @param tokenId The ID of the token that is being burned\n    function burn(uint256 tokenId) external payable;\n\n    function ownerOf(uint256 tokenId) external view returns(address);\n}\n"
    },
    "contracts/externalInterfaces/uniswapV3/IUniswapRouter02.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\n/// @title Router token swapping functionality\ninterface IUniswapRouter02 {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n}\n"
    },
    "contracts/externalInterfaces/uniswapV3/IQuoter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.4;\npragma abicoder v2;\n\n/// @title Quoter Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoter {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountIn The desired input amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountOut The desired output amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n}\n"
    },
    "contracts/staking/interfaces/IStaking.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../donationMiner/interfaces/IDonationMiner.sol\";\nimport \"../../externalInterfaces/openzeppelin/IMintableERC20.sol\";\n\ninterface IStaking {\n    struct Unstake {\n        uint256 amount;         //amount unstaked\n        uint256 cooldownBlock;  //first block number that will allow holder to claim this unstake\n    }\n\n    struct Holder {\n        uint256 amount;          // amount of PACT that are staked by holder\n        uint256 nextUnstakeId;   //\n        Unstake[] unstakes;      //list of all unstakes amount\n    }\n\n    function getVersion() external pure returns(uint256);\n    function updateCooldown(uint256 _newCooldown) external;\n    function PACT() external view returns (IERC20);\n    function SPACT() external view returns (IMintableERC20);\n    function donationMiner() external view returns (IDonationMiner);\n    function cooldown() external view returns(uint256);\n    function currentTotalAmount() external view returns(uint256);\n    function stakeholderAmount(address _holderAddress) external view returns(uint256);\n    function stakeholder(address _holderAddress) external view returns (uint256 amount, uint256 nextUnstakeId, uint256 unstakeListLength, uint256 unstakedAmount);\n    function stakeholderUnstakeAt(address _holderAddress, uint256 _unstakeIndex) external view returns (Unstake memory);\n    function stakeholdersListAt(uint256 _index) external view returns (address);\n    function stakeholdersListLength() external view returns (uint256);\n\n    function stake(address _holder, uint256 _amount) external;\n    function unstake(uint256 _amount) external;\n    function claim() external;\n    function claimPartial(uint256 _lastUnstakeId) external;\n    function claimAmount(address _holderAddress) external view returns (uint256);\n}\n"
    },
    "contracts/airdropV3/interfaces/IAirdropV3.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"../../externalInterfaces/socialConnect/ISocialConnect.sol\";\nimport \"../../community/interfaces/ICommunity.sol\";\nimport \"../../donationMiner/interfaces/IDonationMiner.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IAirdropV3 {\n    struct Beneficiary {\n        uint256 amount;\n    }\n\n    function getVersion() external pure returns(uint256);\n    function donationMiner() external view returns(IDonationMiner);\n    function socialConnect() external view returns(ISocialConnect);\n    function socialConnectIssuer() external view returns(address);\n    function amount() external view returns(uint256);\n\n    function updateAmount(uint256 newTrancheAmount) external;\n\n    function register(address[] memory beneficiaryAddresses, address[] memory communityAddresses) external;\n}\n"
    },
    "contracts/microcredit/interfaces/IMicrocredit.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../donationMiner/interfaces/IDonationMiner.sol\";\n\ninterface IMicrocredit {\n    struct WalletMetadata {\n        uint256 userId;\n        address movedTo;\n    }\n\n    struct User {\n        Loan[] loans;\n    }\n\n    struct Manager {\n        uint256 currentLentAmountLimit;\n        uint256 currentLentAmount;\n    }\n\n    struct Repayment {\n        uint256 date;\n        uint256 amount;\n    }\n\n    struct Loan {\n        uint256 amountBorrowed;\n        uint256 period;                   // the number of seconds after a loan should be fully repaid\n        uint256 dailyInterest;\n        uint256 claimDeadline;\n        uint256 startDate;                // the timestamp the user claimed the amountBorrowed\n        uint256 lastComputedDebt;\n        uint256 amountRepayed;\n        Repayment[] repayments;\n        uint256 lastComputedDate;\n        address managerAddress;\n    }\n\n    function getVersion() external pure returns(uint256);\n    function cUSD() external view returns(IERC20);\n    function revenueAddress() external view returns(address);\n    function donationMiner() external view returns(IDonationMiner);\n    function walletMetadata(address userAddress)\n        external view returns(uint256 userId, address movedTo, uint256 loansLength);\n    function userLoans(address userAddress, uint256 loanId) external view returns(\n        uint256 amountBorrowed,\n        uint256 period,\n        uint256 dailyInterest,\n        uint256 claimDeadline,\n        uint256 startDate,\n        uint256 lastComputedDebt,\n        uint256 currentDebt,\n        uint256 amountRepayed,\n        uint256 repaymentsLength,\n        uint256 lastComputedDate,\n        address managerAddress\n    );\n    function userLoanRepayments(address userAddress, uint256 loanId, uint256 repaymentId)\n        external view returns( uint256 date, uint256 amount);\n    function walletListAt(uint256 index) external view returns (address);\n    function walletListLength() external view returns (uint256);\n    function managerListAt(uint256 index) external view returns (address);\n    function managerListLength() external view returns (uint256);\n    function managers(address managerAddress) external view returns (\n        uint256 currentLentAmountLimit,\n        uint256 currentLentAmount\n    );\n    function updateRevenueAddress(address newRevenueAddress) external;\n    function updateDonationMiner(IDonationMiner newDonationMiner) external;\n    function addManagers(address[] calldata managerAddresses, uint256[] calldata currentLentAmountLimit) external;\n    function removeManagers(address[] calldata managerAddresses) external;\n    function addLoan(\n        address userAddress,\n        uint256 amount,\n        uint256 period,\n        uint256 dailyInterest,\n        uint256 claimDeadline\n    ) external;\n    function addLoans(\n        address[] calldata userAddresses,\n        uint256[] calldata amounts,\n        uint256[] calldata periods,\n        uint256[] calldata dailyInterests,\n        uint256[] calldata claimDeadlines\n    ) external;\n    function cancelLoans(\n        address[] calldata userAddresses,\n        uint256[] calldata loansIds\n    ) external;\n    function changeUserAddress(address oldWalletAddress, address newWalletAddress) external;\n    function claimLoan(uint256 loanId) external;\n    function repayLoan(uint256 loanId, uint256 repaymentAmount) external;\n    function changeManager(address[] memory borrowerAddresses, address managerAddress) external;\n    function transferERC20(IERC20 _token, address _to, uint256 _amount) external;\n}\n\n"
    },
    "contracts/externalInterfaces/openzeppelin/IMintableERC20.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\ninterface IMintableERC20 {\n    function mint(address _account, uint96 _amount) external;\n\n    function burn(address _account, uint96 _amount) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _account) external view returns (uint256);\n\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\n\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    function approve(address _spender, uint256 _amount) external returns (bool);\n\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/externalInterfaces/socialConnect/ISocialConnect.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.4;\n\ninterface ISocialConnect {\n    /**\n    * @notice Returns identifiers mapped to `account` by signers of `trustedIssuers`\n    * @param account Address of the account\n    * @param trustedIssuers Array of n issuers whose identifier mappings will be used\n    * @return countsPerIssuer Array of number of identifiers returned per issuer\n    * @return identifiers Array (length == sum([0])) of identifiers\n    * @dev Adds identifier info to the arrays in order of provided trustedIssuers\n    * @dev Expectation that only one attestation exists per (identifier, issuer, account)\n    */\n    function lookupIdentifiers(address account, address[] calldata trustedIssuers)\n    external view returns (uint256[] memory countsPerIssuer, bytes32[] memory identifiers);\n}\n"
    },
    "contracts/donationMiner/interfaces/DonationMinerStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./IDonationMiner.sol\";\n\n/**\n * @title Storage for DonationMiner\n * @notice For future upgrades, do not change DonationMinerStorageV1. Create a new\n * contract which implements DonationMinerStorageV1 and following the naming convention\n * DonationMinerStorageVX.\n */\nabstract contract DonationMinerStorageV1 is IDonationMiner {\n    IERC20 public override cUSD;\n    IERC20 public override PACT;\n    ITreasury public override treasury;\n    uint256 public override rewardPeriodSize;\n    uint256 public override donationCount;\n    uint256 public override rewardPeriodCount;\n    uint256 public override decayNumerator;\n    uint256 public override decayDenominator;\n\n    mapping(uint256 => Donation) public override donations;\n    mapping(uint256 => RewardPeriod) public override rewardPeriods;\n    mapping(address => Donor) public override donors;\n}\n"
    },
    "contracts/donationMiner/interfaces/DonationMinerStorageV2.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./DonationMinerStorageV1.sol\";\n\n/**\n * @title Storage for DonationMiner\n * @notice For future upgrades, do not change DonationMinerStorageV2. Create a new\n * contract which implements DonationMinerStorageV2 and following the naming convention\n * DonationMinerStorageVX.\n */\nabstract contract DonationMinerStorageV2 is DonationMinerStorageV1 {\n    uint256 public override claimDelay;\n}\n"
    },
    "contracts/donationMiner/interfaces/DonationMinerStorageV3.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./DonationMinerStorageV2.sol\";\n\n/**\n * @title Storage for DonationMiner\n * @notice For future upgrades, do not change DonationMinerStorageV3. Create a new\n * contract which implements DonationMinerStorageV3 and following the naming convention\n * DonationMinerStorageVX.\n */\nabstract contract DonationMinerStorageV3 is DonationMinerStorageV2 {\n    uint256 public override againstPeriods;\n}\n"
    },
    "contracts/donationMiner/interfaces/DonationMinerStorageV4.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./DonationMinerStorageV3.sol\";\n\n/**\n * @title Storage for DonationMiner\n * @notice For future upgrades, do not change DonationMinerStorageV4. Create a new\n * contract which implements DonationMinerStorageV4 and following the naming convention\n * DonationMinerStorageVX.\n */\nabstract contract DonationMinerStorageV4 is DonationMinerStorageV3 {\n    IStaking public override staking;\n    //ratio between 1 cUSD donated and 1 PACT staked\n    uint256 public override stakingDonationRatio;\n    uint256 public override communityDonationRatio;\n}\n"
    },
    "contracts/donationMiner/interfaces/DonationMinerStorageV5.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./DonationMinerStorageV4.sol\";\n\n/**\n * @title Storage for DonationMiner\n * @notice For future upgrades, do not change DonationMinerStorageV5. Create a new\n * contract which implements DonationMinerStorageV4 and following the naming convention\n * DonationMinerStorageVX.\n */\nabstract contract DonationMinerStorageV5 is DonationMinerStorageV4 {\n    IAirdropV3 public override airdropV3;\n    IMicrocredit public override microcredit;\n}\n"
    },
    "contracts/donationMiner/DonationMinerImplementation.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/DonationMinerStorageV5.sol\";\n\ncontract DonationMinerImplementation is\n    Initializable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    DonationMinerStorageV5\n{\n    address internal constant AIRDROP_V3_TOKEN_ADDRESS = 0x00000000000000000000000000000000000000A3;\n    address internal constant MICROCREDIT_TOKEN_ADDRESS = 0x00000000000000000000000000000000000000C1;\n\n    using SafeERC20Upgradeable for IERC20;\n\n    /**\n     * @notice Triggered when a donation has been added\n     *\n     * @param donationId        Id of the donation\n     * @param delegateAddress   Address of the delegate\n     * @param amount            Value of the donation\n     * @param token             Address of the token after conversion\n     * @param amount            Number of token donated\n     * @param target            Address of the receiver (community or treasury)\n     *                          or address of the DonationMiner contract otherwise\n     */\n    event DonationAdded(\n        uint256 indexed donationId,\n        address indexed delegateAddress,\n        uint256 amount,\n        address token,\n        uint256 initialAmount,\n        address indexed target\n    );\n\n    /**\n     * @notice Triggered when a donor has claimed his reward\n     *\n     * @param donor             Address of the donner\n     * @param amount            Value of the reward\n     */\n    event RewardClaimed(address indexed donor, uint256 amount);\n\n    /**\n     * @notice Triggered when a donor has claimed his reward\n     *\n     * @param donor             Address of the donner\n     * @param amount            Value of the reward\n     * @param lastRewardPeriod  Number of the last reward period for witch the claim was made\n     */\n    event RewardClaimedPartial(address indexed donor, uint256 amount, uint256 lastRewardPeriod);\n\n    /**\n     * @notice Triggered when a donor has staked his reward\n     *\n     * @param donor             Address of the donner\n     * @param amount            Value of the reward\n     */\n    event RewardStaked(address indexed donor, uint256 amount);\n\n    /**\n     * @notice Triggered when a donor has staked his reward\n     *\n     * @param donor             Address of the donner\n     * @param amount            Value of the reward\n     * @param lastRewardPeriod  Number of the last reward period for witch tha stake was made\n     */\n    event RewardStakedPartial(address indexed donor, uint256 amount, uint256 lastRewardPeriod);\n\n    /**\n     * @notice Triggered when an amount of an ERC20 has been transferred from this contract to an address\n     *\n     * @param token               ERC20 token address\n     * @param to                  Address of the receiver\n     * @param amount              Amount of the transaction\n     */\n    event TransferERC20(address indexed token, address indexed to, uint256 amount);\n\n    /**\n     * @notice Triggered when reward period params have been updated\n     *\n     * @param oldRewardPeriodSize   Old rewardPeriodSize value\n     * @param oldDecayNumerator     Old decayNumerator value\n     * @param oldDecayDenominator   Old decayDenominator value\n     * @param newRewardPeriodSize   New rewardPeriodSize value\n     * @param newDecayNumerator     New decayNumerator value\n     * @param newDecayDenominator   New decayDenominator value\n     *\n     * For further information regarding each parameter, see\n     * *DonationMiner* smart contract initialize method.\n     */\n    event RewardPeriodParamsUpdated(\n        uint256 oldRewardPeriodSize,\n        uint256 oldDecayNumerator,\n        uint256 oldDecayDenominator,\n        uint256 newRewardPeriodSize,\n        uint256 newDecayNumerator,\n        uint256 newDecayDenominator\n    );\n\n    /**\n     * @notice Triggered when the claimDelay value has been updated\n     *\n     * @param oldClaimDelay            Old claimDelay value\n     * @param newClaimDelay            New claimDelay value\n     */\n    event ClaimDelayUpdated(uint256 oldClaimDelay, uint256 newClaimDelay);\n\n    /**\n     * @notice Triggered when the stakingDonationRatio value has been updated\n     *\n     * @param oldStakingDonationRatio            Old stakingDonationRatio value\n     * @param newStakingDonationRatio            New stakingDonationRatio value\n     */\n    event StakingDonationRatioUpdated(\n        uint256 oldStakingDonationRatio,\n        uint256 newStakingDonationRatio\n    );\n\n    /**\n     * @notice Triggered when the communityDonationRatio value has been updated\n     *\n     * @param oldCommunityDonationRatio            Old communityDonationRatio value\n     * @param newCommunityDonationRatio            New communityDonationRatio value\n     */\n    event CommunityDonationRatioUpdated(\n        uint256 oldCommunityDonationRatio,\n        uint256 newCommunityDonationRatio\n    );\n\n    /**\n     * @notice Triggered when the againstPeriods value has been updated\n     *\n     * @param oldAgainstPeriods            Old againstPeriods value\n     * @param newAgainstPeriods            New againstPeriods value\n     */\n    event AgainstPeriodsUpdated(uint256 oldAgainstPeriods, uint256 newAgainstPeriods);\n\n    /**\n     * @notice Triggered when the treasury address has been updated\n     *\n     * @param oldTreasury             Old treasury address\n     * @param newTreasury             New treasury address\n     */\n    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    /**\n     * @notice Triggered when the staking address has been updated\n     *\n     * @param oldStaking             Old staking address\n     * @param newStaking             New staking address\n     */\n    event StakingUpdated(address indexed oldStaking, address indexed newStaking);\n\n    /**\n     * @notice Enforces beginning rewardPeriod has started\n     */\n    modifier whenStarted() {\n        require(block.number >= rewardPeriods[1].startBlock, \"DonationMiner: ERR_NOT_STARTED\");\n        _;\n    }\n\n    /**\n     * @notice Enforces sender to be Staking contract\n     */\n    modifier onlyStaking() {\n        require(msg.sender == address(staking), \"DonationMiner: NOT_STAKING\");\n        _;\n    }\n\n    /**\n     * @notice Used to initialize a new DonationMiner contract\n     *\n     * @param _cUSD                 Address of the cUSD token\n     * @param _PACT                 Address of the PACT Token\n     * @param _treasury             Address of the Treasury\n     * @param _firstRewardPerBlock  Number of PACTs given for each block\n     *                              from the first reward period\n     * @param _rewardPeriodSize     Number of blocks of the reward period\n     * @param _startingBlock        First block of the first reward period\n     * @param _decayNumerator       Decay numerator used for calculating\n                                    the new reward per block based on\n                                    the previous reward per block\n     * @param _decayDenominator     Decay denominator used for calculating\n                                    the new reward per block based on\n                                    the previous reward per block\n     */\n    function initialize(\n        IERC20 _cUSD,\n        IERC20 _PACT,\n        ITreasury _treasury,\n        uint256 _firstRewardPerBlock,\n        uint256 _rewardPeriodSize,\n        uint256 _startingBlock,\n        uint256 _decayNumerator,\n        uint256 _decayDenominator\n    ) public initializer {\n        require(address(_cUSD) != address(0), \"DonationMiner::initialize: cUSD address not set\");\n        require(address(_PACT) != address(0), \"DonationMiner::initialize: PACT address not set\");\n        require(address(_treasury) != address(0), \"DonationMiner::initialize: treasury_ not set\");\n        require(\n            _firstRewardPerBlock != 0,\n            \"DonationMiner::initialize: firstRewardPerBlock not set!\"\n        );\n        require(_startingBlock != 0, \"DonationMiner::initialize: startingRewardPeriod not set!\");\n        require(_rewardPeriodSize != 0, \"DonationMiner::initialize: rewardPeriodSize is invalid!\");\n\n        __Ownable_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        cUSD = _cUSD;\n        PACT = _PACT;\n        treasury = _treasury;\n        rewardPeriodSize = _rewardPeriodSize;\n        decayNumerator = _decayNumerator;\n        decayDenominator = _decayDenominator;\n\n        rewardPeriodCount = 1;\n        initFirstPeriod(_startingBlock, _firstRewardPerBlock);\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 4;\n    }\n\n    /**\n     * @notice Returns the amount of cUSD donated by a user in a reward period\n     *\n     * @param _period number of the reward period\n     * @param _donor address of the donor\n     * @return uint256 amount of cUSD donated by the user in this reward period\n     */\n    function rewardPeriodDonorAmount(uint256 _period, address _donor)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rewardPeriods[_period].donorAmounts[_donor];\n    }\n\n    /**\n     * @notice Returns the amount of PACT staked by a user at the and of the reward period\n     *\n     * @param _period reward period number\n     * @param _donor address of the donor\n     * @return uint256 amount of PACT staked by a user at the and of the reward period\n     */\n    function rewardPeriodDonorStakeAmounts(uint256 _period, address _donor)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rewardPeriods[_period].donorStakeAmounts[_donor];\n    }\n\n    /**\n     * @notice Returns a reward period number from a donor reward period list\n     *\n     * @param _donor address of the donor\n     * @param _rewardPeriodIndex index of the reward period\n     * @return uint256 number of the reward period\n     */\n    function donorRewardPeriod(address _donor, uint256 _rewardPeriodIndex)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return donors[_donor].rewardPeriods[_rewardPeriodIndex];\n    }\n\n    /**\n     * @notice Updates reward period default params\n     *\n     * @param _newRewardPeriodSize value of new rewardPeriodSize\n     * @param _newDecayNumerator value of new decayNumerator\n     * @param _newDecayDenominator value of new decayDenominator\n     */\n    function updateRewardPeriodParams(\n        uint256 _newRewardPeriodSize,\n        uint256 _newDecayNumerator,\n        uint256 _newDecayDenominator\n    ) external override onlyOwner {\n        require(\n            _newRewardPeriodSize != 0,\n            \"DonationMiner::initialize: rewardPeriodSize is invalid!\"\n        );\n\n        initializeRewardPeriods();\n\n        emit RewardPeriodParamsUpdated(\n            rewardPeriodSize,\n            decayNumerator,\n            decayDenominator,\n            _newRewardPeriodSize,\n            _newDecayNumerator,\n            _newDecayDenominator\n        );\n\n        rewardPeriodSize = _newRewardPeriodSize;\n        decayNumerator = _newDecayNumerator;\n        decayDenominator = _newDecayDenominator;\n    }\n\n    /**\n     * @notice Updates claimDelay value\n     *\n     * @param _newClaimDelay      Number of reward periods a donor has to wait after\n     *                            a donation until he will be able to claim his reward\n     */\n    function updateClaimDelay(uint256 _newClaimDelay) external override onlyOwner {\n        emit ClaimDelayUpdated(claimDelay, _newClaimDelay);\n\n        claimDelay = _newClaimDelay;\n    }\n\n    /**\n     * @notice Updates stakingDonationRatio value\n     *\n     * @param _newStakingDonationRatio    Number of tokens that need to be staked to be counted as 1 PACT donated\n     */\n    function updateStakingDonationRatio(uint256 _newStakingDonationRatio)\n        external\n        override\n        onlyOwner\n    {\n        initializeRewardPeriods();\n\n        emit StakingDonationRatioUpdated(stakingDonationRatio, _newStakingDonationRatio);\n\n        stakingDonationRatio = _newStakingDonationRatio;\n    }\n\n    /**\n     * @notice Updates communityDonationRatio value\n     *\n     * @param _newCommunityDonationRatio    Ratio between 1USD donated into the treasury vs 1USD donated to a community\n     */\n    function updateCommunityDonationRatio(uint256 _newCommunityDonationRatio)\n        external\n        override\n        onlyOwner\n    {\n        emit CommunityDonationRatioUpdated(communityDonationRatio, _newCommunityDonationRatio);\n        communityDonationRatio = _newCommunityDonationRatio;\n    }\n\n    /**\n     * @notice Updates againstPeriods value\n     *\n     * @param _newAgainstPeriods      Number of reward periods for the backward computation\n     */\n    function updateAgainstPeriods(uint256 _newAgainstPeriods) external override onlyOwner {\n        initializeRewardPeriods();\n\n        emit AgainstPeriodsUpdated(againstPeriods, _newAgainstPeriods);\n        againstPeriods = _newAgainstPeriods;\n    }\n\n    /**\n     * @notice Updates Treasury address\n     *\n     * @param _newTreasury address of new treasury_ contract\n     */\n    function updateTreasury(ITreasury _newTreasury) external override onlyOwner {\n        emit TreasuryUpdated(address(treasury), address(_newTreasury));\n        treasury = _newTreasury;\n    }\n\n    /**\n     * @notice Updates Staking address\n     *\n     * @param _newStaking address of new Staking contract\n     */\n    function updateStaking(IStaking _newStaking) external override onlyOwner {\n        emit StakingUpdated(address(staking), address(_newStaking));\n        staking = _newStaking;\n    }\n\n    /**\n     * @notice Updates AirdropV3 address\n     *\n     * @param _newAirdropV3 address of new AirdropV3 contract\n     */\n    function updateAirdropV3(IAirdropV3 _newAirdropV3) external override onlyOwner {\n        airdropV3 = _newAirdropV3;\n    }\n\n    /**\n     * @notice Updates Microcredit address\n     *\n     * @param _newMicrocredit address of new Microcredit contract\n     */\n    function updateMicrocredit(IMicrocredit _newMicrocredit) external override onlyOwner {\n        microcredit = _newMicrocredit;\n    }\n\n    /**\n     * @notice Transfers cUSD tokens to the treasury contract\n     *\n     * @param _token address of the token\n     * @param _amount Amount of cUSD tokens to deposit.\n     * @param _delegateAddress the address that will claim the reward for the donation\n     */\n    function donate(\n        IERC20 _token,\n        uint256 _amount,\n        address _delegateAddress\n    ) external override whenNotPaused whenStarted nonReentrant {\n        require(\n            _token == cUSD || treasury.isToken(address(_token)),\n            \"DonationMiner::donate: Invalid token\"\n        );\n\n        _token.safeTransferFrom(msg.sender, address(treasury), _amount);\n\n        _addDonation(_delegateAddress, _token, _amount, address(treasury));\n    }\n\n    /**\n     * @dev Transfers tokens to the community contract\n     *\n     * @param _community address of the community\n     * @param _token address of the token\n     * @param _amount amount of cUSD tokens to deposit\n     * @param _delegateAddress the address that will claim the reward for the donation\n     */\n    function donateToCommunity(\n        ICommunity _community,\n        IERC20 _token,\n        uint256 _amount,\n        address _delegateAddress\n    ) external override whenNotPaused whenStarted nonReentrant {\n        ICommunityAdmin _communityAdmin = treasury.communityAdmin();\n        require(\n            _communityAdmin.communities(address(_community)) ==\n                ICommunityAdmin.CommunityState.Valid,\n            \"DonationMiner::donateToCommunity: This is not a valid community address\"\n        );\n\n        require(\n            address(_token) == address(_community.cUSD()),\n            \"DonationMiner::donateToCommunity: Invalid token\"\n        );\n\n        _community.donate(msg.sender, _amount);\n        _addDonation(_delegateAddress, _token, _amount, address(_community));\n    }\n\n    /**\n     * @notice Transfers cUSD tokens to the treasury contract\n     *\n     * @param _amount Amount of cUSD tokens to deposit.\n     * @param _delegateAddress the address that will claim the reward for the donation\n     */\n    function donateVirtual(\n        uint256 _amount,\n        address _delegateAddress\n    ) external override whenNotPaused {\n        if (msg.sender == address(airdropV3)) {\n            _addDonation(_delegateAddress, IERC20(AIRDROP_V3_TOKEN_ADDRESS), _amount, address(treasury));\n        } else if (msg.sender == address(microcredit)) {\n            _addDonation(_delegateAddress, IERC20(MICROCREDIT_TOKEN_ADDRESS), _amount, address(treasury));\n        } else {\n            revert(\"DonationMiner: You are not allow to call this method\");\n        }\n    }\n\n    /**\n     * @notice Transfers to the sender the rewards\n     */\n    function claimRewards() external override whenNotPaused whenStarted nonReentrant {\n        uint256 _claimAmount = _computeRewardsByPeriodNumber(msg.sender, _getLastClaimablePeriod());\n\n        IERC20Upgradeable(address(PACT)).safeTransfer(msg.sender, _claimAmount);\n        emit RewardClaimed(msg.sender, _claimAmount);\n    }\n\n    /**\n     * @notice Transfers to the sender the rewards\n     */\n    function claimRewardsPartial(uint256 _lastPeriodNumber)\n        external\n        override\n        whenNotPaused\n        whenStarted\n        nonReentrant\n    {\n        require(\n            _lastPeriodNumber <= _getLastClaimablePeriod(),\n            \"DonationMiner::claimRewardsPartial: This reward period isn't claimable yet\"\n        );\n\n        uint256 _claimAmount = _computeRewardsByPeriodNumber(msg.sender, _lastPeriodNumber);\n\n        IERC20Upgradeable(address(PACT)).safeTransfer(msg.sender, _claimAmount);\n\n        emit RewardClaimedPartial(msg.sender, _claimAmount, _lastPeriodNumber);\n    }\n\n    /**\n     * @notice Stakes the reward\n     */\n    function stakeRewards() external override whenNotPaused whenStarted nonReentrant {\n        initializeRewardPeriods();\n\n        uint256 _stakeAmount = _computeRewardsByPeriodNumber(msg.sender, rewardPeriodCount - 1);\n\n        PACT.approve(address(staking), _stakeAmount);\n        staking.stake(msg.sender, _stakeAmount);\n\n        emit RewardStaked(msg.sender, _stakeAmount);\n    }\n\n    /**\n     * @notice Stakes the reward\n     */\n    function stakeRewardsPartial(uint256 _lastPeriodNumber)\n        external\n        override\n        whenNotPaused\n        whenStarted\n        nonReentrant\n    {\n        initializeRewardPeriods();\n\n        require(\n            _lastPeriodNumber < rewardPeriodCount,\n            \"DonationMiner::stakeRewardsPartial: This reward period isn't claimable yet\"\n        );\n\n        uint256 _stakeAmount = _computeRewardsByPeriodNumber(msg.sender, _lastPeriodNumber);\n\n        PACT.approve(address(staking), _stakeAmount);\n        staking.stake(msg.sender, _stakeAmount);\n\n        emit RewardStaked(msg.sender, _stakeAmount);\n    }\n\n    /**\n     * @notice Calculates the rewards from ended reward periods of a donor\n     *\n     * @param _donorAddress address of the donor\n     * @param _lastPeriodNumber last reward period number to be computed\n     * @return uint256 sum of all donor's rewards that has not been claimed until _lastPeriodNumber\n     */\n    function calculateClaimableRewardsByPeriodNumber(\n        address _donorAddress,\n        uint256 _lastPeriodNumber\n    ) external view override returns (uint256) {\n        uint256 _maxRewardPeriod;\n\n        if (rewardPeriods[rewardPeriodCount].endBlock < block.number) {\n            _maxRewardPeriod =\n                (block.number - rewardPeriods[rewardPeriodCount].endBlock) /\n                rewardPeriodSize;\n            _maxRewardPeriod += rewardPeriodCount;\n        } else {\n            _maxRewardPeriod = rewardPeriodCount - 1;\n        }\n\n        require(\n            _lastPeriodNumber <= _maxRewardPeriod,\n            \"DonationMiner::calculateClaimableRewardsByPeriodNumber: This reward period isn't available yet\"\n        );\n\n        (uint256 _claimAmount, ) = _calculateRewardByPeriodNumber(_donorAddress, _lastPeriodNumber);\n        return _claimAmount;\n    }\n\n    /**\n     * @notice Calculates the rewards from ended reward periods of a donor\n     *\n     * @param _donorAddress address of the donor\n     * @return claimAmount uint256 sum of all donor's rewards that has not been claimed until _lastPeriodNumber\n     */\n    function calculateClaimableRewards(address _donorAddress)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        (uint256 _claimAmount, ) = _calculateRewardByPeriodNumber(\n            _donorAddress,\n            currentRewardPeriodNumber() - 1\n        );\n        return _claimAmount;\n    }\n\n    /**\n     * @notice Calculates the estimate reward of a donor for current reward period\n     *\n     * @param _donorAddress             address of the donor\n     *\n     * @return uint256 reward that donor will receive in current reward period if there isn't another donation\n     */\n    function estimateClaimableReward(address _donorAddress)\n        external\n        view\n        override\n        whenStarted\n        whenNotPaused\n        returns (uint256)\n    {\n        return _estimateClaimableReward(_donorAddress, 0);\n    }\n\n    /**\n     * @notice Calculates the estimate reward of a donor for the next x reward periods\n     *\n     * @param _donorAddress             address of the donor\n     *\n     * @return uint256 reward that donor will receive in current reward period if there isn't another donation\n     */\n    function estimateClaimableRewardAdvance(address _donorAddress)\n        external\n        view\n        override\n        whenStarted\n        whenNotPaused\n        returns (uint256)\n    {\n        return _estimateClaimableReward(_donorAddress, againstPeriods);\n    }\n\n    /**\n     * @notice Calculates the estimate reward of a donor for current reward period based on his staking\n     *\n     * @return uint256 estimated reward by donor stakes\n     */\n    function estimateClaimableRewardByStaking(address _donorAddress)\n        external\n        view\n        override\n        whenStarted\n        whenNotPaused\n        returns (uint256)\n    {\n        uint256 _donorAmount;\n        uint256 _totalAmount;\n\n        (, _totalAmount) = lastPeriodsDonations(address(0));\n\n        uint256 _currentPeriodReward = _calculateCurrentPeriodReward();\n\n        return\n            (_currentPeriodReward * staking.stakeholderAmount(_donorAddress)) /\n            (_totalAmount * stakingDonationRatio + staking.currentTotalAmount());\n    }\n\n    /**\n     * @notice Calculates the APR of a user based on his staking\n     *\n     * @param _stakeholderAddress      address of the stakeHolder\n     *\n     * @return uint256 APR of the user\n     */\n    function apr(address _stakeholderAddress)\n        external\n        view\n        override\n        whenStarted\n        whenNotPaused\n        returns (uint256)\n    {\n        uint256 _stakeholderAmount = staking.stakeholderAmount(_stakeholderAddress);\n        if (_stakeholderAmount == 0) {\n            return 0;\n        }\n\n        return\n            (1e18 * 365100 * _estimateClaimableReward(_stakeholderAddress, 0)) / _stakeholderAmount;\n    }\n\n    /**\n     * @notice Calculates the APR\n     *\n     * @return uint256 APR\n     */\n    function generalApr() public view override whenStarted whenNotPaused returns (uint256) {\n        uint256 _donorAmount;\n        uint256 _totalAmount;\n\n        (, _totalAmount) = lastPeriodsDonations(address(0));\n\n        uint256 _currentPeriodReward = _calculateCurrentPeriodReward();\n        uint256 _totalReward = _currentPeriodReward;\n        uint256 _index;\n        while (_index < 364) {\n            _currentPeriodReward = (_currentPeriodReward * decayNumerator) / decayDenominator;\n            _totalReward += _currentPeriodReward;\n            _index++;\n        }\n\n        return\n            (1e18 * 100 * _totalReward) /\n            (_totalAmount * stakingDonationRatio + staking.currentTotalAmount());\n    }\n\n    /**\n     * @dev Calculate the score of a user based as\n     * this ratio (his donation and staking) / (all donation and staking)\n     * E.G. score = 0.01 * 1e18 => the donor have have 1% score\n     *      so he will get 1% of the reward\n     *\n     * @param _donorAddress  address of the donor\n     *\n     * @return uint256    donor's score\n     */\n    function donorScore(address _donorAddress) public view returns (uint256) {\n        return _calculateDonorShare(_donorAddress, 1e18);\n    }\n\n    /**\n     * @dev Calculate all donations on the last X epochs as well as everyone\n     * else in the same period.\n     *\n     * @param _donorAddress  address of the donor\n     *\n     * @return donorAmount uint256    sum of donor's donations\n     * @return totalAmount uint256    sum of all donations\n     */\n    function lastPeriodsDonations(address _donorAddress)\n        public\n        view\n        override\n        returns (uint256 donorAmount, uint256 totalAmount)\n    {\n        uint256 _currentRewardPeriodNumber = currentRewardPeriodNumber();\n\n        uint256 _startPeriod = _currentRewardPeriodNumber > againstPeriods\n            ? _currentRewardPeriodNumber - againstPeriods\n            : 1;\n\n        if (rewardPeriodCount >= _startPeriod) {\n            (donorAmount, totalAmount) = _calculateDonorIntervalAmounts(\n                _donorAddress,\n                _startPeriod,\n                rewardPeriodCount\n            );\n        }\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from this contract to an address\n     *\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyOwner nonReentrant {\n        IERC20Upgradeable(address(_token)).safeTransfer(_to, _amount);\n\n        emit TransferERC20(address(_token), _to, _amount);\n    }\n\n    function setStakingAmounts(\n        address _holderAddress,\n        uint256 _holderAmount,\n        uint256 _totalAmount\n    ) external override whenNotPaused whenStarted onlyStaking {\n        initializeRewardPeriods();\n\n        RewardPeriod storage _rewardPeriod = rewardPeriods[rewardPeriodCount];\n        _rewardPeriod.hasSetStakeAmount[_holderAddress] = true;\n        _rewardPeriod.donorStakeAmounts[_holderAddress] = _holderAmount;\n        _rewardPeriod.stakesAmount = _totalAmount;\n\n        Donor storage _donor = donors[_holderAddress];\n        //if user hasn't made any donation/staking\n        //set _donor.lastClaimPeriod to be previous reward period\n        //to not calculate reward for epochs 1 to rewardPeriodsCount -1\n        if (_donor.lastClaimPeriod == 0 && _donor.rewardPeriodsCount == 0) {\n            _donor.lastClaimPeriod = rewardPeriodCount - 1;\n        }\n    }\n\n    function currentRewardPeriodNumber() public view override returns (uint256) {\n        uint256 lastRewardPeriodEndBlock = rewardPeriods[rewardPeriodCount].endBlock;\n\n        return\n            lastRewardPeriodEndBlock > block.number\n                ? rewardPeriodCount\n                : rewardPeriodCount +\n                    (block.number - lastRewardPeriodEndBlock) /\n                    rewardPeriodSize +\n                    1;\n    }\n\n    /**\n     * @notice Initializes all reward periods that haven't been initialized yet until the current one.\n     *         The first donor in a reward period will pay for that operation.\n     */\n    function initializeRewardPeriods() internal {\n        RewardPeriod storage _lastPeriod = rewardPeriods[rewardPeriodCount];\n\n        while (_lastPeriod.endBlock < block.number) {\n            rewardPeriodCount++;\n            RewardPeriod storage _newPeriod = rewardPeriods[rewardPeriodCount];\n            _newPeriod.againstPeriods = againstPeriods;\n            _newPeriod.startBlock = _lastPeriod.endBlock + 1;\n            _newPeriod.endBlock = _newPeriod.startBlock + rewardPeriodSize - 1;\n            _newPeriod.rewardPerBlock =\n                (_lastPeriod.rewardPerBlock * decayNumerator) /\n                decayDenominator;\n            _newPeriod.stakesAmount = _lastPeriod.stakesAmount;\n            _newPeriod.stakingDonationRatio = stakingDonationRatio;\n            uint256 _rewardAmount = rewardPeriodSize * _newPeriod.rewardPerBlock;\n\n            uint256 _startPeriod = (rewardPeriodCount - 1 > _lastPeriod.againstPeriods)\n                ? rewardPeriodCount - 1 - _lastPeriod.againstPeriods\n                : 1;\n\n            if (!hasDonationOrStake(_startPeriod, rewardPeriodCount - 1)) {\n                _rewardAmount += _lastPeriod.rewardAmount;\n            }\n            _newPeriod.rewardAmount = _rewardAmount;\n            _lastPeriod = _newPeriod;\n\n            treasury.useFundsForLP();\n        }\n    }\n\n    /**\n     * @notice Adds a new donation in donations list\n     *\n     * @param _delegateAddress address of the wallet that will claim the reward\n     * @param _initialAmount amount of the donation\n     * @param _target address of the receiver (community or treasury)\n     */\n    function _addDonation(\n        address _delegateAddress,\n        IERC20 _token,\n        uint256 _initialAmount,\n        address _target\n    ) internal {\n        initializeRewardPeriods();\n\n        donationCount++;\n        Donation storage _donation = donations[donationCount];\n        _donation.donor = _delegateAddress;\n        _donation.target = _target;\n        _donation.blockNumber = block.number;\n        _donation.rewardPeriod = rewardPeriodCount;\n        _donation.token = _token;\n        _donation.initialAmount = _initialAmount;\n\n        if (\n            _token == cUSD\n            || address(_token) == AIRDROP_V3_TOKEN_ADDRESS\n            || address(_token) == MICROCREDIT_TOKEN_ADDRESS\n        ) {\n            _donation.amount = _initialAmount;\n        } else {\n            _donation.amount = treasury.getConvertedAmount(address(_token), _initialAmount);\n        }\n\n        if (_target != address(treasury)) {\n            _donation.amount = _donation.amount / communityDonationRatio;\n        }\n\n        updateRewardPeriodAmounts(rewardPeriodCount, _delegateAddress, _donation.amount);\n        addCurrentRewardPeriodToDonor(_delegateAddress);\n\n        emit DonationAdded(\n            donationCount,\n            _delegateAddress,\n            _donation.amount,\n            address(_token),\n            _initialAmount,\n            _target\n        );\n    }\n\n    /**\n     * @notice Adds the current reward period number to a donor's list only if it hasn't been added yet\n     *\n     * @param _donorAddress address of the donor\n     */\n    function addCurrentRewardPeriodToDonor(address _donorAddress) internal {\n        Donor storage _donor = donors[_donorAddress];\n        uint256 _lastDonorRewardPeriod = _donor.rewardPeriods[_donor.rewardPeriodsCount];\n\n        //ensures that the current reward period number hasn't been added in the donor's list\n        if (_lastDonorRewardPeriod != rewardPeriodCount) {\n            _donor.rewardPeriodsCount++;\n            _donor.rewardPeriods[_donor.rewardPeriodsCount] = rewardPeriodCount;\n        }\n\n        //if user hasn't made any donation/staking\n        //set _donor.lastClaimPeriod to be previous reward period\n        //to not calculate reward for epochs 1 to rewardPeriodsCount -1\n        if (_donor.lastClaimPeriod == 0 && _donor.rewardPeriodsCount == 0) {\n            _donor.lastClaimPeriod = rewardPeriodCount - 1;\n        }\n    }\n\n    /**\n     * @notice Updates the amounts of a reward period\n     *\n     * @param _rewardPeriodNumber number of the reward period\n     * @param _donorAddress address of the donor\n     * @param _amount amount to be added\n     */\n    function updateRewardPeriodAmounts(\n        uint256 _rewardPeriodNumber,\n        address _donorAddress,\n        uint256 _amount\n    ) internal {\n        RewardPeriod storage _currentPeriod = rewardPeriods[_rewardPeriodNumber];\n        _currentPeriod.donationsAmount += _amount;\n        _currentPeriod.donorAmounts[_donorAddress] += _amount;\n    }\n\n    /**\n     * @notice Checks if current reward period has been initialized\n     *\n     * @return bool true if current reward period has been initialized\n     */\n    function isCurrentRewardPeriodInitialized() internal view returns (bool) {\n        return rewardPeriods[rewardPeriodCount].endBlock >= block.number;\n    }\n\n    function _calculateDonorIntervalAmounts(\n        address _donorAddress,\n        uint256 _startPeriod,\n        uint256 _endPeriod\n    ) internal view returns (uint256, uint256) {\n        uint256 _donorAmount;\n        uint256 _totalAmount;\n        uint256 _index = _startPeriod;\n        for (; _index <= _endPeriod; _index++) {\n            RewardPeriod storage _rewardPeriod = rewardPeriods[_index];\n            _donorAmount += _rewardPeriod.donorAmounts[_donorAddress];\n            _totalAmount += _rewardPeriod.donationsAmount;\n        }\n        return (_donorAmount, _totalAmount);\n    }\n\n    function _getLastClaimablePeriod() internal returns (uint256) {\n        initializeRewardPeriods();\n\n        return rewardPeriodCount > claimDelay + 1 ? rewardPeriodCount - 1 - claimDelay : 0;\n    }\n\n    /**\n     * @notice Computes the rewards\n     */\n    function _computeRewardsByPeriodNumber(address _donorAddress, uint256 _lastPeriodNumber)\n        internal\n        returns (uint256)\n    {\n        Donor storage _donor = donors[_donorAddress];\n        uint256 _claimAmount;\n        uint256 _lastDonorStakeAmount;\n\n        (_claimAmount, _lastDonorStakeAmount) = _calculateRewardByPeriodNumber(\n            _donorAddress,\n            _lastPeriodNumber\n        );\n\n        if (_donor.lastClaimPeriod < _lastPeriodNumber) {\n            _donor.lastClaimPeriod = _lastPeriodNumber;\n        }\n\n        rewardPeriods[_lastPeriodNumber].donorStakeAmounts[_donorAddress] = _lastDonorStakeAmount;\n\n        if (_claimAmount == 0) {\n            return _claimAmount;\n        }\n\n        if (_claimAmount > PACT.balanceOf(address(this))) {\n            _claimAmount = PACT.balanceOf(address(this));\n        }\n\n        return _claimAmount;\n    }\n\n    /**\n     * @notice Calculates the reward for a donor starting with his last reward period claimed\n     *\n     * @param _donorAddress address of the donor\n     * @param _lastPeriodNumber last reward period number to be computed\n     * @return _claimAmount uint256 sum of all donor's rewards that has not been claimed until _lastPeriodNumber\n     * @return _lastDonorStakeAmount uint256 number of PACTs that are staked by the donor at the end of _lastPeriodNumber\n     */\n    function _calculateRewardByPeriodNumber(address _donorAddress, uint256 _lastPeriodNumber)\n        internal\n        view\n        returns (uint256 _claimAmount, uint256 _lastDonorStakeAmount)\n    {\n        Donor storage _donor = donors[_donorAddress];\n\n        // _index is the last reward period number for which the donor claimed his reward\n        uint256 _index = _donor.lastClaimPeriod + 1;\n\n        // this is only used for the transition from V2 to V3\n        // we have to be sure a user is not able to claim for a epoch that he's claimed\n        //      so, if the _donor.lastClaimPeriod hasn't been set yet,\n        //      we will start from _donor.rewardPeriods[_donor.lastClaim]\n        if (_index == 1) {\n            _index = _donor.rewardPeriods[_donor.lastClaim] + 1;\n        }\n\n        uint256 _donorAmount;\n        uint256 _totalAmount;\n        uint256 _rewardAmount;\n        uint256 _stakesAmount;\n        uint256 _stakingDonationRatio;\n\n        //first time _previousRewardPeriod must be rewardPeriods[0] in order to have:\n        //_currentRewardPeriod.againstPeriods = _currentRewardPeriod.againstPeriods - _previousRewardPeriod.againstPeriods\n        RewardPeriod storage _previousRewardPeriod = rewardPeriods[0];\n        RewardPeriod storage _currentRewardPeriod = rewardPeriods[_index];\n        RewardPeriod storage _expiredRewardPeriod = rewardPeriods[0];\n\n        //we save the stake amount of a donor at the end of each claim,\n        //so rewardPeriods[_index - 1].donorStakeAmounts[_donorAddress] is the amount staked by the donor at his last claim\n        _lastDonorStakeAmount = rewardPeriods[_index - 1].donorStakeAmounts[_donorAddress];\n\n        while (_index <= _lastPeriodNumber) {\n            if (_currentRewardPeriod.startBlock > 0) {\n                // this case is used to calculate the reward for periods that have been initialized\n\n                if (_currentRewardPeriod.againstPeriods == 0) {\n                    _donorAmount = _currentRewardPeriod.donorAmounts[_donorAddress];\n                    _totalAmount = _currentRewardPeriod.donationsAmount;\n                } else if (\n                    _previousRewardPeriod.againstPeriods == _currentRewardPeriod.againstPeriods\n                ) {\n                    if (_index > _currentRewardPeriod.againstPeriods + 1) {\n                        _expiredRewardPeriod = rewardPeriods[\n                            _index - 1 - _currentRewardPeriod.againstPeriods\n                        ];\n                        _donorAmount -= _expiredRewardPeriod.donorAmounts[_donorAddress];\n                        _totalAmount -= _expiredRewardPeriod.donationsAmount;\n                    }\n\n                    _donorAmount += _currentRewardPeriod.donorAmounts[_donorAddress];\n                    _totalAmount += _currentRewardPeriod.donationsAmount;\n                } else {\n                    if (_index > _currentRewardPeriod.againstPeriods) {\n                        (_donorAmount, _totalAmount) = _calculateDonorIntervalAmounts(\n                            _donorAddress,\n                            _index - _currentRewardPeriod.againstPeriods,\n                            _index\n                        );\n                    } else {\n                        (_donorAmount, _totalAmount) = _calculateDonorIntervalAmounts(\n                            _donorAddress,\n                            0,\n                            _index\n                        );\n                    }\n                }\n\n                _rewardAmount = _currentRewardPeriod.rewardAmount;\n                _stakesAmount = _currentRewardPeriod.stakesAmount;\n                _stakingDonationRatio = _currentRewardPeriod.stakingDonationRatio > 0\n                    ? _currentRewardPeriod.stakingDonationRatio\n                    : 1;\n            } else {\n                // this case is used to calculate the reward for periods that have not been initialized yet\n                // E.g. calculateClaimableRewardsByPeriodNumber & calculateClaimableRewards\n                // this step can be reached only after calculating the reward for periods that have been initialized\n\n                if (_index > againstPeriods + 1) {\n                    _expiredRewardPeriod = rewardPeriods[_index - 1 - againstPeriods];\n\n                    //we already know that _donorAmount >= _expiredRewardPeriod.donorAmounts[_donorAddress]\n                    //because _donorAmount is a sum of some donorAmounts, including _expiredRewardPeriod.donorAmounts[_donorAddress]\n                    _donorAmount -= _expiredRewardPeriod.donorAmounts[_donorAddress];\n                    //we already know that _totalAmount >= _expiredRewardPeriod.donationsAmount\n                    //because _totalAmount is a sum of some donationsAmounts, including _expiredRewardPeriod.donationsAmount\n                    _totalAmount -= _expiredRewardPeriod.donationsAmount;\n                }\n\n                _donorAmount += _currentRewardPeriod.donorAmounts[_donorAddress];\n                _totalAmount += _currentRewardPeriod.donationsAmount;\n                _rewardAmount = (_rewardAmount * decayNumerator) / decayDenominator;\n            }\n\n            if (_currentRewardPeriod.hasSetStakeAmount[_donorAddress]) {\n                _lastDonorStakeAmount = _currentRewardPeriod.donorStakeAmounts[_donorAddress];\n            }\n\n            if (_donorAmount + _lastDonorStakeAmount > 0) {\n                _claimAmount +=\n                    (_rewardAmount *\n                        (_donorAmount * _stakingDonationRatio + _lastDonorStakeAmount)) /\n                    (_totalAmount * _stakingDonationRatio + _stakesAmount);\n            }\n\n            _index++;\n\n            _previousRewardPeriod = _currentRewardPeriod;\n            _currentRewardPeriod = rewardPeriods[_index];\n        }\n\n        return (_claimAmount, _lastDonorStakeAmount);\n    }\n\n    /**\n     * @notice Initializes the first reward period\n     *\n     * @param _startingBlock first block\n     * @param _firstRewardPerBlock initial reward per block\n     */\n    function initFirstPeriod(uint256 _startingBlock, uint256 _firstRewardPerBlock) internal {\n        RewardPeriod storage _firstPeriod = rewardPeriods[1];\n        _firstPeriod.startBlock = _startingBlock;\n        _firstPeriod.endBlock = _startingBlock + rewardPeriodSize - 1;\n        _firstPeriod.rewardPerBlock = _firstRewardPerBlock;\n        _firstPeriod.rewardAmount = _firstRewardPerBlock * rewardPeriodSize;\n    }\n\n    /**\n     * @notice Checks if there is any donation or stake between _startPeriod and _endPeriod\n     *\n     * @return bool true if there is any donation or stake\n     */\n    function hasDonationOrStake(uint256 _startPeriod, uint256 _endPeriod)\n        internal\n        view\n        returns (bool)\n    {\n        while (_startPeriod <= _endPeriod) {\n            if (\n                rewardPeriods[_startPeriod].donationsAmount +\n                    rewardPeriods[_startPeriod].stakesAmount >\n                0\n            ) {\n                return true;\n            }\n            _startPeriod++;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Calculates the estimate reward of a donor\n     *\n     * @param _donorAddress             address of the donor\n     * @param _inAdvanceRewardPeriods   number of reward periods in front\n     *                                   if _inAdvanceRewardPeriods is 0 the method returns\n     *                                        the estimated reward for current reward period\n     * @return uint256 reward that donor will receive in current reward period if there isn't another donation\n     */\n    function _estimateClaimableReward(address _donorAddress, uint256 _inAdvanceRewardPeriods)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _currentPeriodReward = _calculateCurrentPeriodReward();\n        uint256 _totalReward = _currentPeriodReward;\n\n        while (_inAdvanceRewardPeriods > 0) {\n            _currentPeriodReward = (_currentPeriodReward * decayNumerator) / decayDenominator;\n            _totalReward += _currentPeriodReward;\n            _inAdvanceRewardPeriods--;\n        }\n        return _calculateDonorShare(_donorAddress, _totalReward);\n    }\n\n    /**\n     * @notice Calculates a donor share based on the donations and stakes from the last x rewardPeriods\n     *\n     *\n     * @return uint256  the share from the _total\n     */\n    function _calculateDonorShare(address _donorAddress, uint256 _total)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _donorAmount;\n        uint256 _totalAmount;\n\n        (_donorAmount, _totalAmount) = lastPeriodsDonations(_donorAddress);\n\n        uint256 totalStakeAmount = staking.SPACT().totalSupply();\n        if (totalStakeAmount == 0 && _totalAmount == 0) {\n            return 0;\n        }\n\n        uint256 _stakingDonationRatio = stakingDonationRatio > 0 ? stakingDonationRatio : 1;\n\n        return\n            (_total *\n                (_donorAmount * _stakingDonationRatio + staking.stakeholderAmount(_donorAddress))) /\n            (_totalAmount * _stakingDonationRatio + staking.currentTotalAmount());\n    }\n\n    function _calculateCurrentPeriodReward() internal view returns (uint256) {\n        uint256 _currentRewardPeriodNumber = currentRewardPeriodNumber();\n\n        uint256 _rewardPerBlock = (rewardPeriods[rewardPeriodCount].rewardPerBlock *\n            decayNumerator**(_currentRewardPeriodNumber - rewardPeriodCount)) /\n            decayDenominator**(_currentRewardPeriodNumber - rewardPeriodCount);\n\n        return _rewardPerBlock * rewardPeriodSize;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/mocks/donationMiner/DonationMinerImplementationOld.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/DonationMinerStorageV3Old.sol\";\n\ncontract DonationMinerImplementationOld is\n    Initializable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    DonationMinerStorageV3Old\n{\n    using SafeERC20Upgradeable for IERC20;\n\n    /**\n     * @notice Triggered when a donation has been added\n     *\n     * @param donationId  Id of the donation\n     * @param donor       Address of the donner\n     * @param amount      Value of the donation\n     * @param target      Address of the receiver (community or treasury)\n     *                    or address of the DonationMiner contract otherwise\n     */\n    event DonationAdded(\n        uint256 indexed donationId,\n        address indexed donor,\n        uint256 amount,\n        address indexed target\n    );\n\n    /**\n     * @notice Triggered when a donor has claimed his reward\n     *\n     * @param donor             Address of the donner\n     * @param amount            Value of the reward\n     */\n    event RewardClaimed(address indexed donor, uint256 amount);\n\n    /**\n     * @notice Triggered when a donor has claimed his reward\n     *\n     * @param donor             Address of the donner\n     * @param amount            Value of the reward\n     * @param lastRewardPeriod  Number of the last reward period for witch tha claim was made\n     */\n    event RewardClaimedPartial(address indexed donor, uint256 amount, uint256 lastRewardPeriod);\n\n    /**\n     * @notice Triggered when an amount of an ERC20 has been transferred from this contract to an address\n     *\n     * @param token               ERC20 token address\n     * @param to                  Address of the receiver\n     * @param amount              Amount of the transaction\n     */\n    event TransferERC20(address indexed token, address indexed to, uint256 amount);\n\n    /**\n     * @notice Triggered when reward period params have been updated\n     *\n     * @param oldRewardPeriodSize   Old rewardPeriodSize value\n     * @param oldDecayNumerator     Old decayNumerator value\n     * @param oldDecayDenominator   Old decayDenominator value\n     * @param newRewardPeriodSize   New rewardPeriodSize value\n     * @param newDecayNumerator     New decayNumerator value\n     * @param newDecayDenominator   New decayDenominator value\n     *\n     * For further information regarding each parameter, see\n     * *DonationMiner* smart contract initialize method.\n     */\n    event RewardPeriodParamsUpdated(\n        uint256 oldRewardPeriodSize,\n        uint256 oldDecayNumerator,\n        uint256 oldDecayDenominator,\n        uint256 newRewardPeriodSize,\n        uint256 newDecayNumerator,\n        uint256 newDecayDenominator\n    );\n\n    /**\n     * @notice Triggered when the claimDelay value has been updated\n     *\n     * @param oldClaimDelay            Old claimDelay value\n     * @param newClaimDelay            New claimDelay value\n     */\n    event ClaimDelayUpdated(uint256 oldClaimDelay, uint256 newClaimDelay);\n\n    /**\n     * @notice Triggered when the againstPeriods value has been updated\n     *\n     * @param oldAgainstPeriods            Old againstPeriods value\n     * @param newAgainstPeriods            New againstPeriods value\n     */\n    event AgainstPeriodsUpdated(uint256 oldAgainstPeriods, uint256 newAgainstPeriods);\n\n    /**\n     * @notice Triggered when the treasury address has been updated\n     *\n     * @param oldTreasury             Old treasury address\n     * @param newTreasury             New treasury address\n     */\n    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    /**\n     * @notice Enforces beginning rewardPeriod has started\n     */\n    modifier whenStarted() {\n        require(block.number >= rewardPeriods[1].startBlock, \"DonationMiner: ERR_NOT_STARTED\");\n        _;\n    }\n\n    /**\n     * @notice Used to initialize a new DonationMiner contract\n     *\n     * @param _cUSD                 Address of the cUSD token\n     * @param _PACT                 Address of the PACT Token\n     * @param _treasury             Address of the Treasury\n     * @param _firstRewardPerBlock  Number of PACTs given for each block\n     *                              from the first reward period\n     * @param _rewardPeriodSize     Number of blocks of the reward period\n     * @param _startingBlock        First block of the first reward period\n     * @param _decayNumerator       Decay numerator used for calculating\n                                    the new reward per block based on\n                                    the previous reward per block\n     * @param _decayDenominator     Decay denominator used for calculating\n                                    the new reward per block based on\n                                    the previous reward per block\n     */\n    function initialize(\n        IERC20 _cUSD,\n        IERC20 _PACT,\n        ITreasury _treasury,\n        uint256 _firstRewardPerBlock,\n        uint256 _rewardPeriodSize,\n        uint256 _startingBlock,\n        uint256 _decayNumerator,\n        uint256 _decayDenominator\n    ) public initializer {\n        require(address(_cUSD) != address(0), \"DonationMiner::initialize: cUSD address not set\");\n        require(address(_PACT) != address(0), \"DonationMiner::initialize: PACT address not set\");\n        require(address(_treasury) != address(0), \"DonationMiner::initialize: treasury_ not set\");\n        require(\n            _firstRewardPerBlock != 0,\n            \"DonationMiner::initialize: firstRewardPerBlock not set!\"\n        );\n        require(_startingBlock != 0, \"DonationMiner::initialize: startingRewardPeriod not set!\");\n\n        __Ownable_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        cUSD = _cUSD;\n        PACT = _PACT;\n        treasury = _treasury;\n        rewardPeriodSize = _rewardPeriodSize;\n        decayNumerator = _decayNumerator;\n        decayDenominator = _decayDenominator;\n\n        rewardPeriodCount = 1;\n        initFirstPeriod(_startingBlock, _firstRewardPerBlock);\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 3;\n    }\n\n    /**\n     * @notice Returns the amount of cUSD donated by a user in a reward period\n     *\n     * @param _period number of the reward period\n     * @param _donor address of the donor\n     * @return uint256 amount of cUSD donated by the user in this reward period\n     */\n    function rewardPeriodDonorAmount(uint256 _period, address _donor)\n    external\n    view\n    override\n    returns (uint256)\n    {\n        return rewardPeriods[_period].donorAmounts[_donor];\n    }\n\n    /**\n     * @notice Returns a reward period number from a donor reward period list\n     *\n     * @param _donor address of the donor\n     * @param _rewardPeriodIndex index of the reward period\n     * @return uint256 number of the reward period\n     */\n    function donorRewardPeriod(address _donor, uint256 _rewardPeriodIndex)\n    external\n    view\n    override\n    returns (uint256)\n    {\n        return donors[_donor].rewardPeriods[_rewardPeriodIndex];\n    }\n\n    /**\n     * @notice Updates reward period default params\n     *\n     * @param _newRewardPeriodSize value of new rewardPeriodSize\n     * @param _newDecayNumerator value of new decayNumerator\n     * @param _newDecayDenominator value of new decayDenominator\n     */\n    function updateRewardPeriodParams(\n        uint256 _newRewardPeriodSize,\n        uint256 _newDecayNumerator,\n        uint256 _newDecayDenominator\n    ) external override onlyOwner {\n        uint256 _oldRewardPeriodSize = rewardPeriodSize;\n        uint256 _oldDecayNumerator = decayNumerator;\n        uint256 _oldDecayDenominator = decayDenominator;\n\n        rewardPeriodSize = _newRewardPeriodSize;\n        decayNumerator = _newDecayNumerator;\n        decayDenominator = _newDecayDenominator;\n\n        emit RewardPeriodParamsUpdated(\n            _oldRewardPeriodSize,\n            _oldDecayNumerator,\n            _oldDecayDenominator,\n            _newRewardPeriodSize,\n            _newDecayNumerator,\n            _newDecayDenominator\n        );\n    }\n\n    /**\n     * @notice Updates claimDelay value\n     *\n     * @param _newClaimDelay      Number of reward periods a donor has to wait after\n     *                            a donation until he will be able to claim his reward\n     */\n    function updateClaimDelay(uint256 _newClaimDelay) external override onlyOwner {\n        uint256 _oldClaimDelay = claimDelay;\n        claimDelay = _newClaimDelay;\n\n        emit ClaimDelayUpdated(_oldClaimDelay, _newClaimDelay);\n    }\n\n    /**\n     * @notice Updates againstPeriods value\n     *\n     * @param _newAgainstPeriods      Number of reward periods for the backward computation\n     */\n    function updateAgainstPeriods(uint256 _newAgainstPeriods) external override onlyOwner {\n        uint256 _oldAgainstPeriods = againstPeriods;\n        againstPeriods = _newAgainstPeriods;\n\n        emit AgainstPeriodsUpdated(_oldAgainstPeriods, _newAgainstPeriods);\n    }\n\n    /**\n     * @notice Updates Treasury address\n     *\n     * @param _newTreasury address of new treasury_ contract\n     */\n    function updateTreasury(ITreasury _newTreasury) external override onlyOwner {\n        address _oldTreasuryAddress = address(treasury);\n        treasury = _newTreasury;\n\n        emit TreasuryUpdated(_oldTreasuryAddress, address(_newTreasury));\n    }\n\n    /**\n     * @notice Transfers cUSD tokens to the treasury contract\n     *\n     * @param _amount Amount of cUSD tokens to deposit.\n     */\n    function donate(uint256 _amount) external override whenNotPaused whenStarted nonReentrant {\n        // Transfer the cUSD from the donor to the treasury\n        cUSD.safeTransferFrom(msg.sender, address(treasury), _amount);\n\n        addDonation(msg.sender, _amount, address(treasury));\n    }\n\n    /**\n     * @dev Transfers cUSD tokens to the community contract\n     *\n     * @param _community address of the community\n     * @param _amount amount of cUSD tokens to deposit\n     */\n    function donateToCommunity(ICommunity _community, uint256 _amount)\n    external\n    override\n    whenNotPaused\n    whenStarted\n    nonReentrant\n    {\n        ICommunityAdmin _communityAdmin = treasury.communityAdmin();\n        require(\n            _communityAdmin.communities(address(_community)) ==\n            ICommunityAdmin.CommunityState.Valid,\n            \"DonationMiner::donateToCommunity: This is not a valid community address\"\n        );\n        // Transfer the cUSD from the donor to the community\n        _community.donate(msg.sender, _amount);\n        addDonation(msg.sender, _amount, address(_community));\n    }\n\n    /**\n     * @notice Transfers to the sender the rewards\n     */\n    function claimRewards() external override whenNotPaused whenStarted nonReentrant {\n        uint256 _claimAmount = _claimRewardsByPeriodNumber(msg.sender, _getLastClaimablePeriod());\n\n        emit RewardClaimed(msg.sender, _claimAmount);\n    }\n\n    /**\n     * @notice Transfers to the sender the rewards\n     */\n    function claimRewardsPartial(uint256 _lastPeriodNumber)\n    external\n    override\n    whenNotPaused\n    whenStarted\n    nonReentrant\n    {\n        require(\n            _lastPeriodNumber <= _getLastClaimablePeriod(),\n            \"DonationMiner::claimRewardsPartial: This reward period isn't claimable yet\"\n        );\n\n        uint256 _claimAmount = _claimRewardsByPeriodNumber(msg.sender, _lastPeriodNumber);\n\n        emit RewardClaimedPartial(msg.sender, _claimAmount, _lastPeriodNumber);\n    }\n\n    /**\n     * @notice Calculates the rewards from ended reward periods of a donor\n     *\n     * @param _donorAddress address of the donor\n     * @param _lastPeriodNumber last reward period number to be computed\n     * @return uint256 sum of all donor's rewards that has not been claimed until _lastPeriodNumber\n     */\n    function calculateClaimableRewardsByPeriodNumber(\n        address _donorAddress,\n        uint256 _lastPeriodNumber\n    ) public view override returns (uint256) {\n        uint256 _maxRewardPeriod;\n\n        if (rewardPeriods[rewardPeriodCount].endBlock < block.number) {\n            _maxRewardPeriod =\n            (block.number - rewardPeriods[rewardPeriodCount].endBlock) /\n            rewardPeriodSize;\n            _maxRewardPeriod += rewardPeriodCount;\n        } else {\n            _maxRewardPeriod = rewardPeriodCount - 1;\n        }\n\n        require(\n            _lastPeriodNumber <= _maxRewardPeriod,\n            \"DonationMiner::calculateClaimableRewardsByPeriodNumber: This reward period isn't available yet\"\n        );\n\n        return _calculateRewardByPeriodNumber(_donorAddress, _lastPeriodNumber);\n    }\n\n    /**\n     * @notice Calculates the rewards from ended reward periods of a donor\n     *\n     * @param _donorAddress address of the donor\n     * @return uint256 sum of all donor's rewards that has not been claimed\n     */\n    function calculateClaimableRewards(address _donorAddress)\n    public\n    view\n    override\n    returns (uint256)\n    {\n        uint256 _maxRewardPeriod;\n\n        if (rewardPeriods[rewardPeriodCount].endBlock < block.number) {\n            _maxRewardPeriod =\n            (block.number - rewardPeriods[rewardPeriodCount].endBlock) /\n            rewardPeriodSize;\n            _maxRewardPeriod += rewardPeriodCount;\n        } else {\n            _maxRewardPeriod = rewardPeriodCount - 1;\n        }\n\n        return _calculateRewardByPeriodNumber(_donorAddress, _maxRewardPeriod);\n    }\n\n    /**\n     * @notice Calculates the estimate reward of a donor for current reward period\n     *\n     * @param _donorAddress address of the donor\n     * @return uint256 reward that donor will receive in current reward period if there isn't another donation\n     */\n    function estimateClaimableReward(address _donorAddress)\n    external\n    view\n    override\n    whenStarted\n    whenNotPaused\n    returns (uint256)\n    {\n        if (!isCurrentRewardPeriodInitialized()) {\n            return 0;\n        }\n\n        RewardPeriod storage _lastRewardPeriod = rewardPeriods[rewardPeriodCount];\n\n        uint256 _totalAmount;\n        uint256 _donorAmount;\n        uint256 _claimAmount;\n\n        uint256 _startPeriod = (rewardPeriodCount > againstPeriods)\n        ? rewardPeriodCount - againstPeriods\n        : 0;\n\n        (_donorAmount, _totalAmount) = _calculateDonorIntervalAmounts(\n            _donorAddress,\n            _startPeriod,\n            rewardPeriodCount\n        );\n\n        _claimAmount += (_lastRewardPeriod.rewardAmount * _donorAmount) / _totalAmount;\n\n        return _claimAmount;\n    }\n\n    /**\n     * @notice Calculates the number of PACTs given for each block in current reward period\n     *\n     * @return uint256 current reward per block\n     */\n    function calculateRewardPerBlock() internal view returns (uint256) {\n        return\n        (rewardPeriods[rewardPeriodCount - 1].rewardPerBlock * decayNumerator) /\n        decayDenominator;\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from this contract to an address\n     *\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyOwner nonReentrant {\n        _token.safeTransfer(_to, _amount);\n\n        emit TransferERC20(address(_token), _to, _amount);\n    }\n\n    /**\n     * @notice Initializes all reward periods that haven't been initialized yet until the current one.\n     *         The first donor in a reward period will pay for that operation.\n     */\n    function initializeRewardPeriods() internal {\n        RewardPeriod storage _lastPeriod = rewardPeriods[rewardPeriodCount];\n\n        while (_lastPeriod.endBlock < block.number) {\n            rewardPeriodCount++;\n            RewardPeriod storage _newPeriod = rewardPeriods[rewardPeriodCount];\n            _newPeriod.againstPeriods = againstPeriods;\n            _newPeriod.startBlock = _lastPeriod.endBlock + 1;\n            _newPeriod.endBlock = _newPeriod.startBlock + rewardPeriodSize - 1;\n            _newPeriod.rewardPerBlock = calculateRewardPerBlock();\n            uint256 _rewardAmount = rewardPeriodSize * _newPeriod.rewardPerBlock;\n\n            uint256 _totalAmountAgainst;\n            uint256 _startPeriod = (rewardPeriodCount - 1 > _lastPeriod.againstPeriods)\n            ? rewardPeriodCount - 1 - _lastPeriod.againstPeriods\n            : 0;\n            (, _totalAmountAgainst) = _calculateDonorIntervalAmounts(\n                msg.sender,\n                _startPeriod,\n                rewardPeriodCount - 1\n            );\n            if (_totalAmountAgainst == 0) {\n                _rewardAmount += _lastPeriod.rewardAmount;\n            }\n            _newPeriod.rewardAmount = _rewardAmount;\n            _lastPeriod = _newPeriod;\n        }\n    }\n\n    /**\n     * @notice Adds a new donation in donations list\n     *\n     * @param _donorAddress address of the donner\n     * @param _amount amount of the donation\n     * @param _target address of the receiver (community or treasury)\n     */\n    function addDonation(\n        address _donorAddress,\n        uint256 _amount,\n        address _target\n    ) internal {\n        initializeRewardPeriods();\n\n        donationCount++;\n        Donation storage _donation = donations[donationCount];\n        _donation.donor = _donorAddress;\n        _donation.target = _target;\n        _donation.amount = _amount;\n        _donation.blockNumber = block.number;\n        _donation.rewardPeriod = rewardPeriodCount;\n        _donation.token = cUSD;\n        _donation.tokenPrice = 1e18;\n\n        updateRewardPeriodAmounts(rewardPeriodCount, msg.sender, _amount);\n        addCurrentRewardPeriodToDonor(msg.sender);\n\n        emit DonationAdded(donationCount, msg.sender, _amount, _target);\n    }\n\n    /**\n     * @notice Adds the current reward period number to a donor's list only if it hasn't been added yet\n     *\n     * @param _donorAddress address of the donor\n     */\n    function addCurrentRewardPeriodToDonor(address _donorAddress) internal {\n        Donor storage _donor = donors[_donorAddress];\n        uint256 _lastDonorRewardPeriod = _donor.rewardPeriods[_donor.rewardPeriodsCount];\n\n        //ensures that the current reward period number hasn't been added in the donor's list\n        if (_lastDonorRewardPeriod != rewardPeriodCount) {\n            _donor.rewardPeriodsCount++;\n            _donor.rewardPeriods[_donor.rewardPeriodsCount] = rewardPeriodCount;\n        }\n    }\n\n    /**\n     * @notice Updates the amounts of a reward period\n     *\n     * @param _rewardPeriodNumber number of the reward period\n     * @param _donorAddress address of the donor\n     * @param _amount amount to be added\n     */\n    function updateRewardPeriodAmounts(\n        uint256 _rewardPeriodNumber,\n        address _donorAddress,\n        uint256 _amount\n    ) internal {\n        RewardPeriod storage _currentPeriod = rewardPeriods[_rewardPeriodNumber];\n        _currentPeriod.donationsAmount += _amount;\n        _currentPeriod.donorAmounts[_donorAddress] += _amount;\n    }\n\n    /**\n     * @notice Checks if current reward period has been initialized\n     *\n     * @return bool true if current reward period has been initialized\n     */\n    function isCurrentRewardPeriodInitialized() internal view returns (bool) {\n        return rewardPeriods[rewardPeriodCount].endBlock >= block.number;\n    }\n\n    function _calculateDonorIntervalAmounts(\n        address _donorAddress,\n        uint256 _startPeriod,\n        uint256 _endPeriod\n    ) internal view returns (uint256, uint256) {\n        uint256 _donorAmount;\n        uint256 _totalAmount;\n        uint256 _index = _startPeriod;\n        for (; _index <= _endPeriod; _index++) {\n            RewardPeriod storage _rewardPeriod = rewardPeriods[_index];\n            _donorAmount += _rewardPeriod.donorAmounts[_donorAddress];\n            _totalAmount += _rewardPeriod.donationsAmount;\n        }\n        return (_donorAmount, _totalAmount);\n    }\n\n    function _getLastClaimablePeriod() internal returns (uint256) {\n        initializeRewardPeriods();\n\n        return rewardPeriodCount > claimDelay + 1 ? rewardPeriodCount - 1 - claimDelay : 0;\n    }\n\n    /**\n     * @notice Transfers to the sender the rewards\n     */\n    function _claimRewardsByPeriodNumber(address _donorAddress, uint256 _lastPeriodNumber)\n    internal\n    returns (uint256)\n    {\n        Donor storage _donor = donors[_donorAddress];\n        uint256 _claimAmount;\n\n        _claimAmount = _calculateRewardByPeriodNumber(_donorAddress, _lastPeriodNumber);\n\n        if (_donor.lastClaimPeriod < _lastPeriodNumber) {\n            _donor.lastClaimPeriod = _lastPeriodNumber;\n        }\n\n        if (_claimAmount == 0) {\n            return _claimAmount;\n        }\n\n        if (_claimAmount > PACT.balanceOf(address(this))) {\n            _claimAmount = PACT.balanceOf(address(this));\n        }\n\n        PACT.safeTransfer(_donorAddress, _claimAmount);\n\n        return _claimAmount;\n    }\n\n    /**\n     * @notice Calculates the reward for a donor starting with his last reward period claimed\n     *\n     * @param _donorAddress address of the donor\n     * @param _lastPeriodNumber last reward period number to be computed\n     * @return uint256 sum of all donor's rewards that has not been claimed until _lastPeriodNumber\n     */\n    function _calculateRewardByPeriodNumber(address _donorAddress, uint256 _lastPeriodNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        Donor storage _donor = donors[_donorAddress];\n        uint256 _claimAmount;\n\n        // this is only used for the transition from V2 to V3\n        // we have to be sure a user is not able to claim for a epoch that he's claimed\n        //      so _index has to be greater than _donor.rewardPeriods[_donor.lastClaim]\n        uint256 _index = _donor.lastClaimPeriod > _donor.rewardPeriods[_donor.lastClaim]\n        ? _donor.lastClaimPeriod + 1\n        : _donor.rewardPeriods[_donor.lastClaim] + 1;\n\n        // this is only for optimizing\n        // to not start from the epoch #1, we can start from the first epoch in witch the user donated\n        if (_index == 1) {\n            _index = _donor.rewardPeriods[1];\n        }\n\n        uint256 _donorAmount;\n        uint256 _totalAmount;\n        uint256 _startPeriod;\n        uint256 _rewardAmount;\n        RewardPeriod storage _previousRewardPeriod = rewardPeriods[0];\n        RewardPeriod storage _currentRewardPeriod = rewardPeriods[_index];\n        RewardPeriod storage _expiredRewardPeriod = rewardPeriods[0];\n\n        while (_index <= _lastPeriodNumber) {\n            // used only by calculateClaimableRewardsByPeriodNumber & calculateClaimableRewards\n            if (_currentRewardPeriod.startBlock == 0) {\n                if (_index > againstPeriods + 1) {\n                    _expiredRewardPeriod = rewardPeriods[_index - 1 - againstPeriods];\n                    _donorAmount -= _expiredRewardPeriod.donorAmounts[_donorAddress];\n                    _totalAmount -= _expiredRewardPeriod.donationsAmount;\n                }\n\n                _donorAmount += _currentRewardPeriod.donorAmounts[_donorAddress];\n                _totalAmount += _currentRewardPeriod.donationsAmount;\n                _rewardAmount = (_rewardAmount * decayNumerator) / decayDenominator;\n            } else if (_currentRewardPeriod.againstPeriods == 0) {\n                _donorAmount = _currentRewardPeriod.donorAmounts[_donorAddress];\n                _totalAmount = _currentRewardPeriod.donationsAmount;\n                _rewardAmount = _currentRewardPeriod.rewardAmount;\n            } else if (\n                _previousRewardPeriod.againstPeriods != _currentRewardPeriod.againstPeriods\n            ) {\n                _startPeriod = _index > _currentRewardPeriod.againstPeriods\n                ? _index - _currentRewardPeriod.againstPeriods\n                : 0;\n                (_donorAmount, _totalAmount) = _calculateDonorIntervalAmounts(\n                    _donorAddress,\n                    _startPeriod,\n                    _index\n                );\n                _rewardAmount = _currentRewardPeriod.rewardAmount;\n            } else {\n                if (_index > _currentRewardPeriod.againstPeriods + 1) {\n                    _expiredRewardPeriod = rewardPeriods[\n                    _index - 1 - _currentRewardPeriod.againstPeriods\n                    ];\n                    _donorAmount -= _expiredRewardPeriod.donorAmounts[_donorAddress];\n                    _totalAmount -= _expiredRewardPeriod.donationsAmount;\n                }\n\n                _donorAmount += _currentRewardPeriod.donorAmounts[_donorAddress];\n                _totalAmount += _currentRewardPeriod.donationsAmount;\n                _rewardAmount = _currentRewardPeriod.rewardAmount;\n            }\n\n            if (_totalAmount > 0) {\n                _claimAmount += (_rewardAmount * _donorAmount) / _totalAmount;\n            }\n            _index++;\n\n            _previousRewardPeriod = _currentRewardPeriod;\n            _currentRewardPeriod = rewardPeriods[_index];\n        }\n\n        return _claimAmount;\n    }\n\n    /**\n     * @notice Initializes the first reward period\n     *\n     * @param _startingBlock first block\n     * @param _firstRewardPerBlock initial reward per block\n     */\n    function initFirstPeriod(uint256 _startingBlock, uint256 _firstRewardPerBlock) internal {\n        RewardPeriod storage _firstPeriod = rewardPeriods[1];\n        _firstPeriod.startBlock = _startingBlock;\n        _firstPeriod.endBlock = _startingBlock + rewardPeriodSize - 1;\n        _firstPeriod.rewardPerBlock = _firstRewardPerBlock;\n        _firstPeriod.rewardAmount = _firstRewardPerBlock * rewardPeriodSize;\n    }\n}\n"
    },
    "contracts/mocks/donationMiner/interfaces/DonationMinerStorageV3Old.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./DonationMinerStorageV2Old.sol\";\n\n/**\n * @title Storage for DonationMiner\n * @notice For future upgrades, do not change DonationMinerStorageV2. Create a new\n * contract which implements DonationMinerStorageV3 and following the naming convention\n * DonationMinerStorageVX.\n */\nabstract contract DonationMinerStorageV3Old is DonationMinerStorageV2Old {\n    uint256 public override againstPeriods;\n}\n"
    },
    "contracts/mocks/donationMiner/interfaces/DonationMinerStorageV2Old.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./DonationMinerStorageV1Old.sol\";\n\n/**\n * @title Storage for DonationMiner\n * @notice For future upgrades, do not change DonationMinerStorageV2. Create a new\n * contract which implements DonationMinerStorageV2 and following the naming convention\n * DonationMinerStorageVX.\n */\nabstract contract DonationMinerStorageV2Old is DonationMinerStorageV1Old {\n    uint256 public override claimDelay;\n}\n"
    },
    "contracts/mocks/donationMiner/interfaces/DonationMinerStorageV1Old.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./IDonationMinerOld.sol\";\n\n/**\n * @title Storage for DonationMiner\n * @notice For future upgrades, do not change DonationMinerStorageV1. Create a new\n * contract which implements DonationMinerStorageV1 and following the naming convention\n * DonationMinerStorageVX.\n */\nabstract contract DonationMinerStorageV1Old is IDonationMinerOld {\n    IERC20 public override cUSD;\n    IERC20 public override PACT;\n    ITreasury public override treasury;\n    uint256 public override rewardPeriodSize;\n    uint256 public override donationCount;\n    uint256 public override rewardPeriodCount;\n    uint256 public override decayNumerator;\n    uint256 public override decayDenominator;\n\n    mapping(uint256 => Donation) public override donations;\n    mapping(uint256 => RewardPeriod) public override rewardPeriods;\n    mapping(address => Donor) public override donors;\n}\n"
    },
    "contracts/mocks/donationMiner/interfaces/IDonationMinerOld.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../../community/interfaces/ICommunityAdmin.sol\";\nimport \"../../../treasury/interfaces/ITreasury.sol\";\n\ninterface IDonationMinerOld {\n    struct RewardPeriod {\n        uint256 rewardPerBlock; //reward tokens created per block.\n        uint256 rewardAmount; //reward tokens from previous periods + reward tokens from this reward period\n        uint256 startBlock; //block number at which reward period starts.\n        uint256 endBlock; //block number at which reward period ends.\n        uint256 donationsAmount; //total of donations for this rewardPeriod.\n        mapping(address => uint256) donorAmounts; //amounts donated by every donor in this rewardPeriod.\n        uint256 againstPeriods;\n    }\n\n    struct Donor {\n        uint256 lastClaim;  //last reward period index for which the donor has claimed the reward\n        uint256 rewardPeriodsCount; //total number of reward periods in which the donor donated\n        mapping(uint256 => uint256) rewardPeriods; //list of all reward period ids in which the donor donated\n        uint256 lastClaimPeriod;\n    }\n\n    struct Donation {\n        address donor;  //address of the donner\n        address target;  //address of the receiver (community or treasury)\n        uint256 rewardPeriod;  //number of the reward period in which the donation was made\n        uint256 blockNumber;  //number of the block in which the donation was executed\n        uint256 amount;  //number of tokens donated\n        IERC20 token;  //address of the token\n        uint256 tokenPrice;  //the price of the token in cUSD\n    }\n\n    function getVersion() external pure returns(uint256);\n    function cUSD() external view returns (IERC20);\n    function PACT() external view returns (IERC20);\n    function treasury() external view returns (ITreasury);\n    function rewardPeriodSize() external view returns (uint256);\n    function decayNumerator() external view returns (uint256);\n    function decayDenominator() external view returns (uint256);\n    function rewardPeriodCount() external view returns (uint256);\n    function donationCount() external view returns (uint256);\n    function rewardPeriods(uint256 _period) external view returns (\n        uint256 rewardPerBlock,\n        uint256 rewardAmount,\n        uint256 startBlock,\n        uint256 endBlock,\n        uint256 donationsAmount,\n        uint256 againstPeriods\n    );\n    function rewardPeriodDonorAmount(uint256 _period, address _donor) external view returns (uint256);\n    function donors(address _donor) external view returns (\n        uint256 rewardPeriodsCount,\n        uint256 lastClaim,\n        uint256 lastClaimPeriod\n    );\n    function donorRewardPeriod(address _donor, uint256 _rewardPeriodIndex) external view returns (uint256);\n    function donations(uint256 _index) external view returns (\n        address donor,\n        address target,\n        uint256 rewardPeriod,\n        uint256 blockNumber,\n        uint256 amount,\n        IERC20 token,\n        uint256 tokenPrice\n    );\n    function claimDelay() external view returns (uint256);\n    function againstPeriods() external view returns (uint256);\n    function updateRewardPeriodParams(\n        uint256 _newRewardPeriodSize,\n        uint256 _newDecayNumerator,\n        uint256 _newDecayDenominator\n    ) external;\n    function updateClaimDelay(uint256 _newClaimDelay) external;\n    function updateAgainstPeriods(uint256 _newAgainstPeriods) external;\n    function updateTreasury(ITreasury _newTreasury) external;\n    function donate(uint256 _amount) external;\n    function donateToCommunity(ICommunity _community, uint256 _amount) external;\n    function claimRewards() external;\n    function claimRewardsPartial(uint256 _lastPeriodNumber) external;\n    function calculateClaimableRewards(address _donor) external returns (uint256);\n    function calculateClaimableRewardsByPeriodNumber(address _donor, uint256 _lastPeriodNumber) external returns (uint256);\n    function estimateClaimableReward(address _donor) external view returns (uint256);\n    function transfer(IERC20 _token, address _to, uint256 _amount) external;\n}\n"
    },
    "contracts/treasury/interfaces/TreasuryStorageV2.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./ITreasury.sol\";\nimport \"./TreasuryStorageV1.sol\";\n\n/**\n * @title Storage for Treasury\n * @notice For future upgrades, do not change TreasuryStorageV2. Create a new\n * contract which implements TreasuryStorageV2 and following the naming convention\n * TreasuryStorageVX.\n */\nabstract contract TreasuryStorageV2 is TreasuryStorageV1 {\n    IDonationMiner public override donationMiner;\n    ITreasuryLpSwap public override lpSwap;\n    mapping(address => Token) public override tokens;\n    EnumerableSet.AddressSet internal _tokenList;\n    IERC20 public override PACT;\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/treasury/interfaces/TreasuryStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./ITreasury.sol\";\n\n/**\n * @title Storage for Treasury\n * @notice For future upgrades, do not change TreasuryStorageV1. Create a new\n * contract which implements TreasuryStorageV1 and following the naming convention\n * TreasuryStorageVX.\n */\nabstract contract TreasuryStorageV1 is ITreasury {\n    ICommunityAdmin public override communityAdmin;\n}\n"
    },
    "contracts/treasury/TreasuryImplementation.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./interfaces/TreasuryStorageV2.sol\";\n\ncontract TreasuryImplementation is\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    TreasuryStorageV2\n{\n    using SafeERC20Upgradeable for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    address constant DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n\n    /**\n     * @notice Triggered when CommunityAdmin has been updated\n     *\n     * @param oldCommunityAdmin   Old communityAdmin address\n     * @param newCommunityAdmin   New communityAdmin address\n     */\n    event CommunityAdminUpdated(\n        address indexed oldCommunityAdmin,\n        address indexed newCommunityAdmin\n    );\n\n    /**\n     * @notice Triggered when an amount of an ERC20 has been transferred from this contract to an address\n     *\n     * @param token               ERC20 token address\n     * @param to                  Address of the receiver\n     * @param amount              Amount of the transaction\n     */\n    event TransferERC20(address indexed token, address indexed to, uint256 amount);\n\n    /**\n     * @notice Triggered when a token has been set\n     *\n     * @param tokenAddress                      Address of the token\n     */\n    event TokenSet(address indexed tokenAddress);\n\n    /**\n     * @notice Triggered when a token has been removed\n     *\n     * @param tokenAddress        Address of the token\n     */\n    event TokenRemoved(address indexed tokenAddress);\n\n    /**\n     * @notice Triggered when a token has been set\n     *\n     * @param tokenAddress           Address of the token\n     * @param amountIn               Amount changed\n     * @param amountOutMin           Minimum amount out\n     * @param exchangePath           Exchange path\n     * @param amountsOut             Value of the final amount out\n     */\n    event AmountConverted(\n        address indexed tokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        bytes exchangePath,\n        uint256 amountsOut\n    );\n\n    /**\n     * @notice Enforces sender to be communityAdmin or owner\n     */\n    modifier onlyCommunityAdminOrOwner() {\n        require(\n            msg.sender == address(communityAdmin) || msg.sender == owner(),\n            \"Treasury: NOT_COMMUNITY_ADMIN AND NOT_OWNER\"\n        );\n        _;\n    }\n\n    //todo: remove this modifier after deployment and testing\n    /**\n     * @notice Enforces sender to DAO or impactMarketCouncil\n     */\n    modifier onlyOwnerOrImpactMarketCouncil() {\n        require(\n            msg.sender == owner() || msg.sender == address(communityAdmin.impactMarketCouncil()),\n            \"Treasury: caller is not the owner nor ImpactMarketCouncil\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Enforces sender to be owner or council or donationMiner\n     */\n    modifier onlyOwnerOrDonationMiner() {\n        require(\n            msg.sender == owner() || msg.sender == address(donationMiner),\n            \"Treasury: caller is not the owner nor donationMiner\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Used to initialize a new Treasury contract\n     *\n     * @param _communityAdmin    Address of the CommunityAdmin contract\n     */\n    function initialize(ICommunityAdmin _communityAdmin) public initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        communityAdmin = _communityAdmin;\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 2;\n    }\n\n    /**\n     * @notice Returns if an address is an accepted token\n     *\n     * @param _tokenAddress token address to be checked\n     * @return bool true if the tokenAddress is an accepted token\n     */\n    function isToken(address _tokenAddress) public view override returns (bool) {\n        return _tokenList.contains(_tokenAddress);\n    }\n\n    /**\n     * @notice Returns the address of a token from tokenList\n     *\n     * @param _index index of the token\n     * @return address of the token\n     */\n    function tokenListAt(uint256 _index) external view override returns (address) {\n        return _tokenList.at(_index);\n    }\n\n    /**\n     * @notice Returns the number of tokens\n     *\n     * @return uint256 number of tokens\n     */\n    function tokenListLength() external view override returns (uint256) {\n        return _tokenList.length();\n    }\n\n    /**\n     * @notice Updates the CommunityAdmin contract address\n     *\n     * @param _newCommunityAdmin address of the new CommunityAdmin contract\n     */\n    function updateCommunityAdmin(ICommunityAdmin _newCommunityAdmin)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        emit CommunityAdminUpdated(address(communityAdmin), address(_newCommunityAdmin));\n        communityAdmin = _newCommunityAdmin;\n    }\n\n    /**\n     * @notice Updates the PACT contract address\n     *\n     * @param _newPACT address of the new PACT contract\n     */\n    function updatePACT(IERC20 _newPACT) external override onlyOwnerOrImpactMarketCouncil {\n        PACT = _newPACT;\n    }\n\n    /**\n     * @notice Updates the DonationMiner contract address\n     *\n     * @param _newDonationMiner address of the new DonationMiner contract\n     */\n    function updateDonationMiner(IDonationMiner _newDonationMiner)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        donationMiner = _newDonationMiner;\n    }\n\n    /**\n     * @notice Updates the LpSwap contract address\n     *\n     * @param _newLpSwap address of the new LpSwap contract\n     */\n    function updateLpSwap(ITreasuryLpSwap _newLpSwap)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        lpSwap = _newLpSwap;\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from this contract to an address\n     *\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyCommunityAdminOrOwner nonReentrant {\n        _token.safeTransfer(_to, _amount);\n\n        emit TransferERC20(address(_token), _to, _amount);\n    }\n\n    /**\n     * @notice Used to set a new token\n     *\n     * @param _tokenAddress address of the token\n     * @param _rate rate of the token in CUSD\n     * @param _lpStrategy strategy to use for splitting the LP fees between treasury and buyback\n     * @param _lpPercentage percentage of the funds to be used for LP\n     * @param _lpMinLimit minimum amount of funds that need to be in the treasury (and not to be used for LP)\n     * @param _uniswapNFTPositionManagerId id of the NFT position manager\n     * @param _exchangePathToCUSD uniswap path to exchange the token to CUSD\n     * @param _exchangePathToPACT uniswap path to exchange the token to PACT\n     **/\n    function setToken(\n        address _tokenAddress,\n        uint256 _rate,\n        LpStrategy _lpStrategy,\n        uint256 _lpPercentage,\n        uint256 _lpMinLimit,\n        uint256 _uniswapNFTPositionManagerId,\n        bytes memory _exchangePathToCUSD,\n        bytes memory _exchangePathToPACT\n    ) public override onlyOwnerOrImpactMarketCouncil {\n        require(_rate > 0, \"Treasury::setToken: Invalid rate\");\n\n        emit TokenSet(_tokenAddress);\n\n        tokens[_tokenAddress].rate = _rate;\n        tokens[_tokenAddress].lpStrategy = _lpStrategy;\n        tokens[_tokenAddress].lpPercentage = _lpPercentage;\n        tokens[_tokenAddress].lpMinLimit = _lpMinLimit;\n\n        if (_uniswapNFTPositionManagerId > 0) {\n            require(\n                lpSwap.uniswapNFTPositionManager().ownerOf(_uniswapNFTPositionManagerId) ==\n                    address(lpSwap),\n                \"Treasury::setToken: invalid uniswapNFTPositionManagerId\"\n            );\n            tokens[_tokenAddress].uniswapNFTPositionManagerId = _uniswapNFTPositionManagerId;\n        }\n\n        if (_exchangePathToCUSD.length > 0) {\n            require(\n                lpSwap.uniswapQuoter().quoteExactInput(_exchangePathToCUSD, 1e18) > 0,\n                \"Treasury::setToken: invalid exchangePathToCUSD\"\n            );\n\n            tokens[_tokenAddress].exchangePathToCUSD = _exchangePathToCUSD;\n        }\n\n        if (_exchangePathToPACT.length > 0) {\n            require(\n                lpSwap.uniswapQuoter().quoteExactInput(_exchangePathToPACT, 1e18) > 0,\n                \"Treasury::setToken: invalid exchangePathToPACT\"\n            );\n\n            tokens[_tokenAddress].exchangePathToPACT = _exchangePathToPACT;\n        }\n\n        _tokenList.add(_tokenAddress);\n    }\n\n    /**\n     * @notice Used to remove a token\n     *\n     * @param _tokenAddress address of the token\n     **/\n    function removeToken(address _tokenAddress) external override onlyOwnerOrImpactMarketCouncil {\n        require(_tokenList.contains(_tokenAddress), \"Treasury::removeToken: this is not a token\");\n\n        tokens[_tokenAddress].rate = 0;\n        tokens[_tokenAddress].lpStrategy = LpStrategy.NONE;\n        tokens[_tokenAddress].lpPercentage = 0;\n        tokens[_tokenAddress].lpMinLimit = 0;\n        tokens[_tokenAddress].uniswapNFTPositionManagerId = 0;\n        delete tokens[_tokenAddress].exchangePathToCUSD;\n        delete tokens[_tokenAddress].exchangePathToPACT;\n\n        _tokenList.remove(_tokenAddress);\n\n        emit TokenRemoved(_tokenAddress);\n    }\n\n    /**\n     * @notice Gets the amount of cUSDs that can be obtained from a converting the given amount of a token\n     **/\n    function getConvertedAmount(address _tokenAddress, uint256 _amount)\n        external\n        override\n        returns (uint256)\n    {\n        require(isToken(_tokenAddress), \"Treasury::getConvertedAmount: this is not a valid token\");\n\n        Token memory _token = tokens[_tokenAddress];\n\n        uint256 _convertedAmount = _token.exchangePathToCUSD.length == 0\n            ? _amount\n            : lpSwap.uniswapQuoter().quoteExactInput(_token.exchangePathToCUSD, _amount);\n\n        return (_convertedAmount * _token.rate) / 1e18;\n    }\n\n    /**\n     * @notice Converts an amount of a token to cUSDs\n     *\n     * @param _tokenAddress is the address of the token to convert\n     * @param _amountIn is the amount of the token to convert\n     * @param _amountOutMin is used to prevent the transaction from failing if the price of the token changes - 0 for no check\n     * @param _exchangePath is the path to use for the swap - empty for the default path\n     **/\n    function convertAmount(\n        address _tokenAddress,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        bytes memory _exchangePath\n    ) external override onlyOwnerOrImpactMarketCouncil {\n        require(\n            _tokenList.contains(_tokenAddress),\n            \"Treasury::convertAmount: this is not a valid token\"\n        );\n\n        if (_exchangePath.length == 0) {\n            _exchangePath = tokens[_tokenAddress].exchangePathToCUSD;\n        }\n\n        IERC20(_tokenAddress).approve(address(lpSwap.uniswapRouter()), _amountIn);\n\n        // Executes the swap.\n        uint256 _amountOut = lpSwap.uniswapRouter().exactInput(\n            IUniswapRouter02.ExactInputParams({\n                path: _exchangePath,\n                recipient: address(this),\n                amountIn: _amountIn,\n                amountOutMinimum: _amountOutMin\n            })\n        );\n\n        emit AmountConverted(_tokenAddress, _amountIn, _amountOutMin, _exchangePath, _amountOut);\n    }\n\n    /**\n     * @notice Uses part of the funds of a token to add liquidity to the Uniswap pool\n     * it is used by the DonationMiner when creating a new epoch\n     * it can also been used by the DAO when there are too many funds in the treasury\n     **/\n    function useFundsForLP() external override onlyOwnerOrDonationMiner {\n        uint256 _tokenLength = _tokenList.length();\n\n        Token memory _token;\n\n        for (uint256 _index; _index < _tokenLength; _index++) {\n            _token = tokens[_tokenList.at(_index)];\n            if (_token.lpPercentage > 0) {\n                IERC20 _erc20Token = IERC20(_tokenList.at(_index));\n                uint256 _balance = _erc20Token.balanceOf(address(this));\n\n                if (_balance > _token.lpMinLimit) {\n                    uint256 _tokenAmountToUseInLp = (_balance * _token.lpPercentage) / 100e18;\n                    _erc20Token.approve(address(lpSwap), _tokenAmountToUseInLp);\n                    lpSwap.addToLp(_erc20Token, _tokenAmountToUseInLp);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Collects the fees of a Uniswap NFT position\n     *\n     * @param _uniswapNFTPositionManagerId is the id of the Uniswap NFT position\n     **/\n    function collectFees(uint256 _uniswapNFTPositionManagerId)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        (, , address _token0Address, address _token1Address, , , , , , , , ) = lpSwap\n            .uniswapNFTPositionManager()\n            .positions(_uniswapNFTPositionManagerId);\n\n        require(\n            _token0Address == address(PACT) || _token1Address == address(PACT),\n            \"Treasury::collectFees invalid uniswapNFTPositionManagerId\"\n        );\n\n        (uint256 _amount0, uint256 _amount1) = lpSwap.collectFees(_uniswapNFTPositionManagerId);\n\n        IERC20 _erc20Token;\n        uint256 _pactAmount;\n        uint256 _tokenAmount;\n\n        if (_token0Address == address(PACT)) {\n            _erc20Token = IERC20(_token1Address);\n            _pactAmount = _amount0;\n            _tokenAmount = _amount1;\n        } else {\n            _erc20Token = IERC20(_token0Address);\n            _pactAmount = _amount1;\n            _tokenAmount = _amount0;\n        }\n\n        Token memory _token = tokens[address(_erc20Token)];\n\n        if (_token.lpStrategy == LpStrategy.MainCoin) {\n            //            PACT.transfer(DEAD_ADDRESS, _pactAmount);\n        } else if (_token.lpStrategy == LpStrategy.SecondaryCoin) {\n            uint256 _pactToBurn;\n\n            _erc20Token.approve(address(lpSwap.uniswapRouter()), _tokenAmount);\n\n            lpSwap.uniswapRouter().exactInput(\n                IUniswapRouter02.ExactInputParams({\n                    path: _token.exchangePathToCUSD,\n                    recipient: address(this),\n                    amountIn: _tokenAmount / 2,\n                    amountOutMinimum: 0\n                })\n            );\n\n            _pactToBurn = lpSwap.uniswapRouter().exactInput(\n                IUniswapRouter02.ExactInputParams({\n                    path: _token.exchangePathToPACT,\n                    recipient: address(this),\n                    amountIn: _tokenAmount / 2,\n                    amountOutMinimum: 0\n                })\n            );\n\n            //            PACT.transfer(DEAD_ADDRESS, _pactToBurn + _pactAmount);\n        } else {\n            return;\n        }\n    }\n}\n"
    },
    "contracts/treasuryLpSwap/TreasuryLpSwapImplementation.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./interfaces/TreasuryLpSwapStorageV1.sol\";\n\ncontract TreasuryLpSwapImplementation is\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    TreasuryLpSwapStorageV1\n{\n    using SafeERC20Upgradeable for IERC20;\n\n    /**\n     * @notice Triggered when an amount of an ERC20 has been transferred from this contract to an address\n     *\n     * @param token               ERC20 token address\n     * @param to                  Address of the receiver\n     * @param amount              Amount of the transaction\n     */\n    event TransferERC20(address indexed token, address indexed to, uint256 amount);\n\n    /**\n     * @notice Triggered when a LP has been increased\n     *\n     * @param uniswapNFTPositionManagerId       Position manager tokenId\n     * @param pactToAdd                         Amount of PACT that should have been added in LP\n     * @param tokenToAdd                        Amount of token that should have been added in LP\n     * @param pactSpent                         Amount of PACT that have been added in LP\n     * @param tokenSpent                        Amount of token that have been added in LP\n     */\n    event LiquidityIncreased(\n        uint256 uniswapNFTPositionManagerId,\n        uint256 pactToAdd,\n        uint256 tokenToAdd,\n        uint256 pactSpent,\n        uint256 tokenSpent\n    );\n\n    /**\n     * @notice Triggered when a LP has been decreased\n     *\n     * @param uniswapNFTPositionManagerId           Position manager tokenId\n     * @param liquidityDecreased                    Liquidity amount that was decreased from LP\n     * @param liquidityLeft                         Liquidity amount that was left in LP\n     * @param pactDecreased                         Amount of PACT that was decreased from LP\n     * @param tokenDecreased                        Amount of token that was decreased from LP\n     */\n    event LiquidityDecreased(\n        uint256 uniswapNFTPositionManagerId,\n        uint256 liquidityDecreased,\n        uint256 liquidityLeft,\n        uint256 pactDecreased,\n        uint256 tokenDecreased\n    );\n\n    /**\n     * @notice Triggered when the fees of an LP has been decreased\n     *\n     * @param uniswapNFTPositionManagerId     Position manager tokenId\n     * @param pactFee                         pactFee\n     * @param tokenFee                        tokenFee\n     */\n    event FeesCollected(uint256 uniswapNFTPositionManagerId, uint256 pactFee, uint256 tokenFee);\n\n    /**\n     * @notice Triggered when a token has been set\n     *\n     * @param tokenAddress           Address of the token\n     * @param amountIn               Amount changed\n     * @param amountOutMin           Minimum amount out\n     * @param exchangePath           Exchange path\n     * @param amountsOut             Value of the final amount out\n     */\n    event AmountConverted(\n        address indexed tokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        bytes exchangePath,\n        uint256 amountsOut\n    );\n\n    //todo: remove this modifier after deployment and testing\n    /**\n     * @notice Enforces sender to DAO or impactMarketCouncil\n     */\n    modifier onlyOwnerOrImpactMarketCouncil() {\n        require(\n            msg.sender == owner() ||\n                msg.sender == address(treasury.communityAdmin().impactMarketCouncil()),\n            \"TreasuryLpSwap: caller is not the owner nor ImpactMarketCouncil\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Enforces sender to Treasury\n     */\n    modifier onlyTreasury() {\n        require(msg.sender == address(treasury), \"TreasuryLpSwap: caller is not the treasury\");\n        _;\n    }\n\n    function initialize(\n        ITreasury _treasury,\n        IUniswapRouter02 _uniswapRouter,\n        IQuoter _uniswapQuoter,\n        INonfungiblePositionManager _uniswapNFTPositionManager\n    ) public initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        treasury = _treasury;\n        uniswapRouter = _uniswapRouter;\n        uniswapQuoter = _uniswapQuoter;\n        uniswapNFTPositionManager = _uniswapNFTPositionManager;\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice Updates the Treasury contract address\n     *\n     * @param _newTreasury address of the new Treasury contract\n     */\n    function updateTreasury(ITreasury _newTreasury)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        treasury = _newTreasury;\n    }\n\n    /**\n     * @notice Updates the UniswapRouter contract address\n     *\n     * @param _newUniswapRouter address of the new UniswapRouter contract\n     */\n    function updateUniswapRouter(IUniswapRouter02 _newUniswapRouter)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        uniswapRouter = _newUniswapRouter;\n    }\n\n    /**\n     * @notice Updates the UniswapQuoter contract address\n     *\n     * @param _newUniswapQuoter address of the new UniswapQuoter contract\n     */\n    function updateUniswapQuoter(IQuoter _newUniswapQuoter)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        uniswapQuoter = _newUniswapQuoter;\n    }\n\n    /**\n     * @notice Updates the UniswapNFTPositionManager contract address\n     *\n     * @param _newUniswapNFTPositionManager address of the new UniswapNFTPositionManager contract\n     */\n    function updateUniswapNFTPositionManager(\n        INonfungiblePositionManager _newUniswapNFTPositionManager\n    ) external override onlyOwnerOrImpactMarketCouncil {\n        uniswapNFTPositionManager = _newUniswapNFTPositionManager;\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from this contract to an address\n     *\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyOwner nonReentrant {\n        _token.safeTransfer(_to, _amount);\n\n        emit TransferERC20(address(_token), _to, _amount);\n    }\n\n    /**\n     * @notice Converts an amount of a token to another token\n     *\n     * @param _tokenAddress address of the token to convert\n     * @param _amountIn amount of the token to convert\n     * @param _amountOutMin minimum amount of the token to receive\n     * @param _exchangePath exchange path - if empty, it will use the default exchange path\n     */\n    function convertAmount(\n        address _tokenAddress,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        bytes memory _exchangePath\n    ) external override onlyOwnerOrImpactMarketCouncil {\n        require(\n            treasury.isToken(_tokenAddress),\n            \"TreasuryLpSwap::convertAmount: this is not a valid token\"\n        );\n\n        if (_exchangePath.length == 0) {\n            (, , , , , bytes memory _exchangePathToCUSD, ) = treasury.tokens(_tokenAddress);\n            _exchangePath = _exchangePathToCUSD;\n        }\n\n        IERC20(_tokenAddress).approve(address(uniswapRouter), _amountIn);\n\n        // Executes the swap.\n        uint256 _amountOut = uniswapRouter.exactInput(\n            IUniswapRouter02.ExactInputParams({\n                path: _exchangePath,\n                recipient: address(this),\n                amountIn: _amountIn,\n                amountOutMinimum: _amountOutMin\n            })\n        );\n\n        emit AmountConverted(_tokenAddress, _amountIn, _amountOutMin, _exchangePath, _amountOut);\n    }\n\n    /**\n     * @notice Adds tokens to lp\n     *\n     * @param _erc20Token address of the ERC20 token\n     * @param _amount amount to be added in lp\n     */\n    function addToLp(IERC20 _erc20Token, uint256 _amount) external override nonReentrant {\n        if (_amount == 0) {\n            return;\n        }\n\n        _erc20Token.safeTransferFrom(msg.sender, address(this), _amount);\n\n        (\n            ,\n            ,\n            ,\n            ,\n            uint256 _uniswapNFTPositionManagerId,\n            ,\n            bytes memory _exchangePathToPACT\n        ) = treasury.tokens(address(_erc20Token));\n\n        uint256 _tokenAmountToAdd = _amount / 2;\n        _erc20Token.approve(address(uniswapRouter), _tokenAmountToAdd);\n\n        uint256 _pactAmountToAdd = uniswapRouter.exactInput(\n            IUniswapRouter02.ExactInputParams({\n                path: _exchangePathToPACT,\n                recipient: address(this),\n                amountIn: _tokenAmountToAdd,\n                amountOutMinimum: 0\n            })\n        );\n\n        uint256 _initialPACTBalance = treasury.PACT().balanceOf(address(this));\n        uint256 _initialTokenBalance = _erc20Token.balanceOf(address(this));\n\n        uint256 _amount0;\n        uint256 _amount1;\n\n        if (address(treasury.PACT()) < address(_erc20Token)) {\n            _amount0 = _pactAmountToAdd;\n            _amount1 = _tokenAmountToAdd;\n        } else {\n            _amount0 = _tokenAmountToAdd;\n            _amount1 = _pactAmountToAdd;\n        }\n\n        treasury.PACT().approve(address(uniswapNFTPositionManager), _pactAmountToAdd);\n        _erc20Token.approve(address(uniswapNFTPositionManager), _tokenAmountToAdd);\n\n        uniswapNFTPositionManager.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: _uniswapNFTPositionManagerId,\n                amount0Desired: _amount0,\n                amount1Desired: _amount1,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n\n        uint256 _pactSpent = _initialPACTBalance - treasury.PACT().balanceOf(address(this));\n        uint256 _tokenSpent = _initialTokenBalance - _erc20Token.balanceOf(address(this));\n\n        emit LiquidityIncreased(\n            _uniswapNFTPositionManagerId,\n            _pactAmountToAdd,\n            _tokenAmountToAdd,\n            _pactSpent,\n            _tokenSpent\n        );\n    }\n\n    /**\n     * @notice Collects fees from lp\n     *\n     * @param _uniswapNFTPositionManagerId id of the lp\n     */\n    function collectFees(uint256 _uniswapNFTPositionManagerId)\n        external\n        override\n        onlyTreasury\n        returns (uint256 amount0, uint256 amount1)\n    {\n        (amount0, amount1) = uniswapNFTPositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: _uniswapNFTPositionManagerId,\n                recipient: address(treasury),\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n\n        (, , address _token0Address, , , , , , , , , ) = uniswapNFTPositionManager.positions(\n            _uniswapNFTPositionManagerId\n        );\n\n        if (_token0Address == address(treasury.PACT())) {\n            emit FeesCollected(_uniswapNFTPositionManagerId, amount0, amount1);\n        } else {\n            emit FeesCollected(_uniswapNFTPositionManagerId, amount1, amount0);\n        }\n    }\n\n    function decreaseLiquidity(uint256 _uniswapNFTPositionManagerId, uint128 _liquidityAmount)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n        returns (uint256 amount0, uint256 amount1)\n    {\n        (amount0, amount1) = uniswapNFTPositionManager.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: _uniswapNFTPositionManagerId,\n                liquidity: _liquidityAmount,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n\n        (\n            ,\n            ,\n            address _token0Address,\n            ,\n            ,\n            ,\n            ,\n            uint256 _liquidityLeft,\n            ,\n            ,\n            ,\n\n        ) = uniswapNFTPositionManager.positions(_uniswapNFTPositionManagerId);\n\n        if (_token0Address == address(treasury.PACT())) {\n            emit LiquidityDecreased(\n                _uniswapNFTPositionManagerId,\n                _liquidityAmount,\n                _liquidityLeft,\n                amount0,\n                amount1\n            );\n        } else {\n            emit LiquidityDecreased(\n                _uniswapNFTPositionManagerId,\n                _liquidityAmount,\n                _liquidityLeft,\n                amount1,\n                amount0\n            );\n        }\n    }\n}\n"
    },
    "contracts/treasuryLpSwap/interfaces/TreasuryLpSwapStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./ITreasuryLpSwap.sol\";\n\n/**\n * @title Storage for TreasuryLpSwap\n * @notice For future upgrades, do not change TreasuryLpSwapStorageV1. Create a new\n * contract which implements TreasuryLpSwapStorageV1 and following the naming convention\n * TreasuryLpSwapStorageVX.\n */\nabstract contract TreasuryLpSwapStorageV1 is ITreasuryLpSwap {\n    ITreasury public override treasury;\n    IUniswapRouter02 public override uniswapRouter;\n    IQuoter public override uniswapQuoter;\n    INonfungiblePositionManager public override uniswapNFTPositionManager;\n}\n"
    },
    "contracts/referralLink/interfaces/IReferralLink.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../externalInterfaces/socialConnect/ISocialConnect.sol\";\n\ninterface IReferralLink {\n    enum CampaignState {\n        Invalid,\n        Valid,\n        Paused,\n        Canceled\n    }\n\n    struct Campaign {\n        IERC20 token;\n        uint256 balance;\n        CampaignState state;\n        uint256 startTime;\n        uint256 endTime;\n        uint256 rewardAmount;\n        uint256 maxReferralLinks;\n        mapping(address => uint256) referralLinks;\n    }\n\n    function getVersion() external pure returns (uint256);\n    function signerWalletAddress() external view returns(address);\n    function socialConnect() external view returns(ISocialConnect);\n    function socialConnectIssuer() external view returns(address);\n    function campaignsLength() external view returns (uint256);\n    function campaigns(uint256 _campaignId) external view returns (\n        IERC20 token,\n        uint256 balance,\n        CampaignState state,\n        uint256 startTime,\n        uint256 endTime,\n        uint256 rewardAmount,\n        uint256 maxReferralLinks\n    );\n    function campaignReferralLinks(uint256 _campaignId, address _senderAddress) external view returns (uint256);\n    function verifiedUsersAt(uint256 index) external view returns (address);\n    function verifiedUsersLength() external view returns (uint256);\n    function updateSignerWalletAddress(address newSignerAddress) external;\n    function addCampaign(IERC20 token, uint256 startTime, uint256 endTime, uint256 rewardAmount, uint256 maxReferralLinks) external;\n    function fundCampaign(uint256 campaignId, uint256 amount) external;\n    function pauseCampaign(uint256 campaignId) external;\n    function unpauseCampaign(uint256 campaignId) external;\n    function cancelCampaign(uint256 campaignId, address fundRecipient) external;\n    function claimReward(\n        address beneficiary,\n        uint256[] calldata campaignIds,\n        address[] calldata newUserAddresses,\n        bytes[] calldata signatures\n    ) external;\n}\n"
    },
    "contracts/referralLink/interfaces/ReferralLinkStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./IReferralLink.sol\";\n\n/**\n * @title Storage for ReferralLink\n * @notice For future upgrades, do not change ReferralLinkStorageV1. Create a new\n * contract which implements ReferralLinkStorageV1 and following the naming convention\n * ReferralLinkVX.\n */\nabstract contract ReferralLinkStorageV1 is IReferralLink {\n    address public override signerWalletAddress;\n    ISocialConnect public override socialConnect;\n    address public override socialConnectIssuer;\n    uint256 public override campaignsLength;\n    mapping(uint256 => Campaign) internal _campaigns;\n    EnumerableSet.AddressSet internal _verifiedUsers; // (receiver, sender) pair of a referralLink\n}\n"
    },
    "contracts/referralLink/ReferralLinkImplementation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./interfaces/ReferralLinkStorageV1.sol\";\n\ncontract ReferralLinkImplementation is\n    Initializable,\n    PausableUpgradeable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ReferralLinkStorageV1\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeERC20Upgradeable for IERC20;\n    using ECDSA for bytes32;\n\n    /**\n     * @notice Triggered when a campaign state has been changed\n     *\n     * @param campaignId        Id of the campaign\n     * @param startTime         Start date of the campaign\n     * @param endTime           End date of the campaign\n     * @param rewardAmount      Reward amount of the campaign\n     * @param maxReferralLinks  Maximum number of referral links for an user\n     */\n    event CampaignAdded(\n        uint256 indexed campaignId,\n        uint256 startTime,\n        uint256 endTime,\n        uint256 rewardAmount,\n        uint256 maxReferralLinks\n    );\n\n    /**\n     * @notice Triggered when a campaign has been funded\n     *\n     * @param campaignId        Id of the campaign\n     * @param sender            Address of the sender\n     * @param amount            Amount of the fund\n     */\n    event CampaignFunded(uint256 indexed campaignId, address indexed sender, uint256 amount);\n\n    /**\n     * @notice Triggered when a campaign state has been changed\n     *\n     * @param campaignId           Id of the campaign\n     * @param state             New state of the campaign\n     */\n    event CampaignStateChanged(uint256 indexed campaignId, CampaignState indexed state);\n\n    /**\n     * @notice Triggered when a reward has been claimed\n     *\n     * @param sender           address of the sender to be rewarded\n     * @param campaignId       the id of the campaign\n     * @param receiverAddress  address of the receiver\n     */\n    event RewardClaimed(\n        address indexed sender,\n        uint256 indexed campaignId,\n        address receiverAddress\n    );\n\n    /**\n     * @notice Used to initialize a new contract\n     *\n     * @param _signerWalletAddress    Address of the backend wallet\n     */\n    function initialize(\n        address _signerWalletAddress,\n        address _socialConnectAddress,\n        address _socialConnectIssuer\n    ) external initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        __Pausable_init_unchained();\n\n        signerWalletAddress = _signerWalletAddress;\n        socialConnect = ISocialConnect(_socialConnectAddress);\n        socialConnectIssuer = _socialConnectIssuer;\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice Returns the details of a campaign\n     *\n     * @param _campaignId id of the campaign\n     * @return token address of the token\n     * @return balance balance of the campaign\n     * @return state state of the campaign\n     * @return startTime start date of the campaign\n     * @return endTime end date of the campaign\n     * @return rewardAmount reward amount of the campaign\n     * @return maxReferralLinks maximum number of referral links\n     */\n    function campaigns(uint256 _campaignId)\n        external\n        view\n        override\n        returns (\n            IERC20 token,\n            uint256 balance,\n            CampaignState state,\n            uint256 startTime,\n            uint256 endTime,\n            uint256 rewardAmount,\n            uint256 maxReferralLinks\n        )\n    {\n        Campaign storage _campaign = _campaigns[_campaignId];\n        return (\n            _campaign.token,\n            _campaign.balance,\n            _campaign.state,\n            _campaign.startTime,\n            _campaign.endTime,\n            _campaign.rewardAmount,\n            _campaign.maxReferralLinks\n        );\n    }\n\n    /**\n     * @notice Returns the number of referral links used by a sender\n     *\n     * @param _campaignId id of the campaign\n     * @param _senderAddress address of the token\n     * @return the number of referral links used by a sender\n     */\n    function campaignReferralLinks(uint256 _campaignId, address _senderAddress)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _campaigns[_campaignId].referralLinks[_senderAddress];\n    }\n\n    /**\n     * @notice Returns the address of an verified user at a given index\n     *\n     * @param index index of the verified user\n     * @return the address of an verified user at a given index\n     */\n    function verifiedUsersAt(uint256 index) external view override returns (address) {\n        return _verifiedUsers.at(index);\n    }\n\n    /**\n     * @notice Returns the number of verified users\n     *\n     * @return the number of verified users\n     */\n    function verifiedUsersLength() external view override returns (uint256) {\n        return _verifiedUsers.length();\n    }\n\n    /**\n     * @dev Pauses the contract\n     */\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses the contract\n     */\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    /** Updates the address of the backend wallet\n     *\n     * @param _newSignerWalletAddress address of the new backend wallet\n     */\n    function updateSignerWalletAddress(address _newSignerWalletAddress)\n        external\n        override\n        onlyOwner\n    {\n        signerWalletAddress = _newSignerWalletAddress;\n    }\n\n    /**\n     * @notice Adds a new campaign\n     *\n     * @param _token      the token used for reward\n     * @param _startTime  the start date of the campaign\n     * @param _endTime    the end date of the campaign\n     * @param _rewardAmount the reward amount of the campaign\n     */\n    function addCampaign(\n        IERC20 _token,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _rewardAmount,\n        uint256 _maxReferralLinks\n    ) external override onlyOwner {\n        require(_startTime < _endTime && _endTime > block.timestamp, \"ReferralLink: Invalid dates\");\n\n        _campaigns[campaignsLength].state = CampaignState.Valid;\n        _campaigns[campaignsLength].token = _token;\n        _campaigns[campaignsLength].startTime = _startTime;\n        _campaigns[campaignsLength].endTime = _endTime;\n        _campaigns[campaignsLength].rewardAmount = _rewardAmount;\n        _campaigns[campaignsLength].maxReferralLinks = _maxReferralLinks;\n\n        emit CampaignAdded(campaignsLength, _startTime, _endTime, _rewardAmount, _maxReferralLinks);\n\n        campaignsLength++;\n    }\n\n    /**\n     * @notice Pauses a campaign\n     *\n     * @param _campaignId id of the campaign\n     */\n    function pauseCampaign(uint256 _campaignId) external override onlyOwner {\n        Campaign storage _campaign = _campaigns[_campaignId];\n\n        require(_campaign.state == CampaignState.Valid, \"ReferralLink: Invalid campaign id\");\n\n        _campaign.state = CampaignState.Paused;\n\n        emit CampaignStateChanged(_campaignId, CampaignState.Paused);\n    }\n\n    /**\n     * @notice Unpauses a campaign\n     *\n     * @param _campaignId id of the campaign\n     */\n    function unpauseCampaign(uint256 _campaignId) external override onlyOwner {\n        Campaign storage _campaign = _campaigns[_campaignId];\n\n        require(_campaign.state == CampaignState.Paused, \"ReferralLink: Invalid campaign id\");\n\n        _campaign.state = CampaignState.Valid;\n\n        emit CampaignStateChanged(_campaignId, CampaignState.Valid);\n    }\n\n    /**\n     * @notice Cancels a campaign\n     *\n     * @param _campaignId id of the campaign\n     * @param _fundRecipient the address of the recipient who will receive the funds allocated for this campaign\n     */\n    function cancelCampaign(uint256 _campaignId, address _fundRecipient)\n        external\n        override\n        onlyOwner\n    {\n        Campaign storage _campaign = _campaigns[_campaignId];\n\n        require(\n            _campaign.state == CampaignState.Valid || _campaign.state == CampaignState.Paused,\n            \"ReferralLink: Invalid campaign id\"\n        );\n\n        _campaign.state = CampaignState.Canceled;\n        uint256 _campaignBalance = _campaign.balance;\n        _campaign.balance = 0;\n\n        _campaign.token.safeTransfer(_fundRecipient, _campaignBalance);\n\n        emit CampaignStateChanged(_campaignId, CampaignState.Canceled);\n    }\n\n    /**\n     * @notice Funds a campaign\n     *\n     * @param _campaignId   the id of the campaign\n     * @param _amount the amount to be funded\n     */\n    function fundCampaign(uint256 _campaignId, uint256 _amount) external override {\n        Campaign storage _campaign = _campaigns[_campaignId];\n\n        require(\n            _campaign.state == CampaignState.Valid || _campaign.state == CampaignState.Paused,\n            \"ReferralLink: Invalid campaign id\"\n        );\n\n        _campaign.token.safeTransferFrom(msg.sender, address(this), _amount);\n\n        _campaign.balance += _amount;\n\n        emit CampaignFunded(_campaignId, msg.sender, _amount);\n    }\n\n    /**\n     * @notice Allows users to claim the reward for a campaign using a signature\n     *\n     * @param _sender address of the sender\n     * @param _campaignIds ids of the campaigns\n     * @param _newUserAddresses addresses of the new users\n     * @param _signatures signatures from the backend\n     */\n    function claimReward(\n        address _sender,\n        uint256[] calldata _campaignIds,\n        address[] calldata _newUserAddresses,\n        bytes[] calldata _signatures\n    ) external override {\n        require(\n            _campaignIds.length == _newUserAddresses.length &&\n                _campaignIds.length == _signatures.length,\n            \"ReferralLink: Invalid data\"\n        );\n\n        Campaign storage _campaign;\n\n        uint256 _index;\n        bytes32 _messageHash;\n\n        for (_index = 0; _index < _campaignIds.length; _index++) {\n            _campaign = _campaigns[_campaignIds[_index]];\n\n            require(_campaign.state == CampaignState.Valid, \"ReferralLink: Invalid campaign id\");\n\n            require(\n                _campaign.startTime <= block.timestamp,\n                \"ReferralLink: Campaign has not started yet\"\n            );\n\n            require(_campaign.endTime >= block.timestamp, \"ReferralLink: Campaign has ended\");\n\n            require(\n                _campaign.referralLinks[_sender] < _campaign.maxReferralLinks,\n                \"ReferralLink: Already reached max referral links\"\n            );\n\n            require(\n                !_verifiedUsers.contains(_newUserAddresses[_index]),\n                \"ReferralLink: This user already exists\"\n            );\n\n            require(\n                _campaign.balance >= _campaign.rewardAmount,\n                \"ReferralLink: Campaign doesn't have enough funds\"\n            );\n\n            require(\n                _isSocialConnectVerified(_newUserAddresses[_index]),\n                \"ReferralLink: User has not been verified\"\n            );\n\n            _messageHash = keccak256(\n                abi.encode(_sender, _campaignIds[_index], _newUserAddresses[_index])\n            );\n\n            require(\n                signerWalletAddress ==\n                    _messageHash.toEthSignedMessageHash().recover(_signatures[_index]),\n                \"ReferralLink: Invalid signature\"\n            );\n\n            _campaign.referralLinks[_sender]++;\n            _verifiedUsers.add(_newUserAddresses[_index]);\n\n            _campaign.token.safeTransfer(_sender, _campaign.rewardAmount);\n            _campaign.token.safeTransfer(_newUserAddresses[_index], _campaign.rewardAmount);\n\n            _campaign.balance -= _campaign.rewardAmount * 2;\n\n            emit RewardClaimed(_sender, _campaignIds[_index], _newUserAddresses[_index]);\n        }\n    }\n\n    function _isSocialConnectVerified(address _userAddress) internal view returns (bool) {\n        address[] memory _issuers = new address[](1);\n        _issuers[0] = address(socialConnectIssuer);\n        (uint256[] memory _countsPerIssuer, ) = socialConnect.lookupIdentifiers(\n            _userAddress,\n            _issuers\n        );\n\n        return _countsPerIssuer[0] > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/learnAndEarn/LearnAndEarnImplementation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./interfaces/ILearnAndEarn.sol\";\nimport \"./interfaces/LearnAndEarnStorageV1.sol\";\n\ncontract LearnAndEarnImplementation is\n    Initializable,\n    PausableUpgradeable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    LearnAndEarnStorageV1\n{\n    using SafeERC20Upgradeable for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using ECDSA for bytes32;\n\n    /**\n     * @notice Triggered when a level has been funded\n     *\n     * @param levelId           Id of the level\n     * @param sender            Address of the sender\n     * @param amount            Amount of the fund\n     */\n    event LevelFunded(uint256 indexed levelId, address indexed sender, uint256 amount);\n\n    /**\n     * @notice Triggered when a level state has been changed\n     *\n     * @param levelId           Id of the level\n     * @param state             New state of the level\n     */\n    event LevelStateChanged(uint256 indexed levelId, LevelState indexed state);\n\n    /**\n     * @notice Triggered when a level has been updated\n     *\n     * @param levelId           Id of the level\n     * @param newTokenAddress   New token address\n     */\n    event LevelUpdated(uint256 indexed levelId, address newTokenAddress);\n\n    /**\n     * @notice Triggered when a reward has been claimed\n     *\n     * @param beneficiary    address of the beneficiary to be rewarded\n     * @param levelId       the id of the level\n     */\n    event RewardClaimed(address indexed beneficiary, uint256 indexed levelId);\n\n    /**\n     * @notice Enforces sender to DAO or impactMarketCouncil\n     */\n    modifier onlyOwnerOrImpactMarketCouncil() {\n        require(\n            msg.sender == owner() || msg.sender == address(communityAdmin.impactMarketCouncil()),\n            \"LearnAndEarn: caller is not the owner nor ImpactMarketCouncil\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Used to initialize a new CommunityAdmin contract\n     *\n     * @param _signerWalletAddress    Address of the backend wallet\n     */\n    function initialize(address _signerWalletAddress, ICommunityAdmin _communityAdmin)\n        external\n        initializer\n    {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        __Pausable_init_unchained();\n\n        signerWalletAddress = _signerWalletAddress;\n        communityAdmin = _communityAdmin;\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice Returns the id of a level from levelList\n     *\n     * @param _index index of the level\n     * @return id of the level\n     */\n    function levelListAt(uint256 _index) external view override returns (uint256) {\n        return _levelList.at(_index);\n    }\n\n    /**\n     * @notice Returns the number of levels\n     *\n     * @return uint256 number of levels\n     */\n    function levelListLength() external view override returns (uint256) {\n        return _levelList.length();\n    }\n\n    /**\n     * @notice Returns the reward amount claimed by a beneficiary for a level\n     *\n     * @param _levelId id of the level\n     * @param _beneficiary address of the beneficiary\n     * @return reward amount claimed by the beneficiary for a level\n     */\n    function levelClaims(uint256 _levelId, address _beneficiary)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return levels[_levelId].claims[_beneficiary];\n    }\n\n    /**\n     * @dev Pauses the contract\n     */\n    function pause() public onlyOwnerOrImpactMarketCouncil {\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses the contract\n     */\n    function unpause() public onlyOwnerOrImpactMarketCouncil {\n        _unpause();\n    }\n\n    /** Updates the address of the backend wallet\n     *\n     * @param _newSignerWalletAddress address of the new backend wallet\n     */\n    function updateSignerWalletAddress(address _newSignerWalletAddress)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        signerWalletAddress = _newSignerWalletAddress;\n    }\n\n    /**\n     * @notice Updates the CommunityAdmin contract address\n     *\n     * @param _newCommunityAdmin address of the new CommunityAdmin contract\n     */\n    function updateCommunityAdmin(ICommunityAdmin _newCommunityAdmin) external override onlyOwner {\n        communityAdmin = _newCommunityAdmin;\n    }\n\n    /**\n     * @notice Adds a new level\n     *\n     * @param _levelId    the id of the level\n     * @param _token      the token used for reward\n     */\n    function addLevel(uint256 _levelId, IERC20 _token)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        require(\n            levels[_levelId].state == LevelState.Invalid,\n            \"LearnAndLearn::addLevel: Invalid level id\"\n        );\n\n        levels[_levelId].state = LevelState.Valid;\n        levels[_levelId].token = _token;\n\n        _levelList.add(_levelId);\n\n        emit LevelStateChanged(_levelId, LevelState.Valid);\n    }\n\n    /**\n     * @notice Updates a level\n     *\n     * @param _levelId    the id of the level\n     * @param _token      the token used for reward\n     */\n    function updateLevel(uint256 _levelId, IERC20 _token)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        require(\n            levels[_levelId].state == LevelState.Valid,\n            \"LearnAndLearn::updateLevel: Invalid level id\"\n        );\n\n        require(levels[_levelId].balance == 0, \"LearnAndLearn::updateLevel: This level has funds\");\n\n        levels[_levelId].token = _token;\n\n        emit LevelUpdated(_levelId, address(_token));\n    }\n\n    /**\n     * @notice Pauses a level\n     *\n     * @param _levelId id of the level\n     */\n    function pauseLevel(uint256 _levelId) external override onlyOwnerOrImpactMarketCouncil {\n        Level storage _level = levels[_levelId];\n\n        require(_level.state == LevelState.Valid, \"LearnAndEarn::pauseLevel: Invalid level id\");\n\n        _level.state = LevelState.Paused;\n\n        emit LevelStateChanged(_levelId, LevelState.Paused);\n    }\n\n    /**\n     * @notice Unpauses a level\n     *\n     * @param _levelId id of the level\n     */\n    function unpauseLevel(uint256 _levelId) external override onlyOwnerOrImpactMarketCouncil {\n        Level storage _level = levels[_levelId];\n\n        require(_level.state == LevelState.Paused, \"LearnAndEarn::unpauseLevel: Invalid level id\");\n\n        _level.state = LevelState.Valid;\n\n        emit LevelStateChanged(_levelId, LevelState.Valid);\n    }\n\n    /**\n     * @notice Cancels a level\n     *\n     * @param _levelId id of the level\n     * @param _fundRecipient the address of the recipient who will receive the funds allocated for this level\n     */\n    function cancelLevel(uint256 _levelId, address _fundRecipient)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        Level storage _level = levels[_levelId];\n\n        require(\n            _level.state == LevelState.Valid || _level.state == LevelState.Paused,\n            \"LearnAndEarn::cancelLevel: Invalid level id\"\n        );\n\n        _level.state = LevelState.Canceled;\n        uint256 _levelBalance = _level.balance;\n        _level.balance = 0;\n\n        _level.token.safeTransfer(_fundRecipient, _levelBalance);\n\n        emit LevelStateChanged(_levelId, LevelState.Canceled);\n    }\n\n    /**\n     * @notice Funds a level\n     *\n     * @param _levelId   the id of the level\n     * @param _amount the amount to be funded\n     */\n    function fundLevel(uint256 _levelId, uint256 _amount) external override {\n        Level storage _level = levels[_levelId];\n\n        require(\n            _level.state == LevelState.Valid || _level.state == LevelState.Paused,\n            \"LearnAndEarn::fundLevel: Invalid level id\"\n        );\n\n        _level.token.safeTransferFrom(msg.sender, address(this), _amount);\n\n        _level.balance += _amount;\n\n        emit LevelFunded(_levelId, msg.sender, _amount);\n    }\n\n    /**\n     * @notice Allows beneficiaries to claim the reward for a list of levels using a signature\n     *\n     * @param _beneficiary     address of the beneficiary to be rewarded\n     * @param _levelIds        the ids of the levels\n     * @param _rewardAmounts   the amounts of the tokens to be send to the beneficiary as reward for each level\n     * @param _signatures      the signatures from the backend\n     */\n    function claimRewardForLevels(\n        address _beneficiary,\n        uint256[] calldata _levelIds,\n        uint256[] calldata _rewardAmounts,\n        bytes[] calldata _signatures\n    ) external override {\n        Level storage _level;\n\n        require(\n            _levelIds.length == _rewardAmounts.length && _levelIds.length == _signatures.length,\n            \"LearnAndEarn::claimRewardForLevels: Invalid data\"\n        );\n\n        uint256 _index;\n        bytes32 _messageHash;\n\n        for (_index = 0; _index < _levelIds.length; _index++) {\n            _level = levels[_levelIds[_index]];\n\n            require(\n                _level.state == LevelState.Valid,\n                \"LearnAndEarn::claimRewardForLevels: Invalid level id\"\n            );\n\n            //if the beneficiary has already claimed the reward for this level,\n            // or if the rewardAmount is 0, skip this level\n            if (_level.claims[_beneficiary] > 0 || _rewardAmounts[_index] == 0) {\n                continue;\n            }\n\n            _messageHash = keccak256(\n                abi.encode(_beneficiary, _levelIds[_index], _rewardAmounts[_index])\n            );\n\n            require(\n                signerWalletAddress ==\n                    _messageHash.toEthSignedMessageHash().recover(_signatures[_index]),\n                \"LearnAndEarn::claimRewardForLevels: Invalid signature\"\n            );\n\n            _level.claims[_beneficiary] = _rewardAmounts[_index];\n\n            require(\n                _level.balance >= _rewardAmounts[_index],\n                \"LearnAndEarn::claimRewardForLevels: Level doesn't have enough funds\"\n            );\n\n            _level.token.safeTransfer(_beneficiary, _rewardAmounts[_index]);\n            _level.balance -= _rewardAmounts[_index];\n\n            emit RewardClaimed(_beneficiary, _levelIds[_index]);\n        }\n    }\n}\n"
    },
    "contracts/learnAndEarn/interfaces/ILearnAndEarn.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../../community/interfaces/ICommunityAdmin.sol\";\n\ninterface ILearnAndEarn {\n    enum LevelState {\n        Invalid,\n        Valid,\n        Paused,\n        Canceled\n    }\n\n    struct Level {\n        IERC20 token;\n        uint256 balance;\n        LevelState state;\n        mapping(address => uint256) claims;    // the reward amount claimed by beneficiaries for this level\n    }\n\n    function getVersion() external pure returns (uint256);\n    function signerWalletAddress() external view returns(address);\n    function communityAdmin() external view returns(ICommunityAdmin);\n    function levelListLength() external view returns (uint256);\n    function levelListAt(uint256 index) external view returns (uint256);\n    function levels(uint256 levelId)\n        external view returns ( IERC20 token, uint256 balance, LevelState state);\n    function levelClaims(\n        uint256 levelId,\n        address beneficiary\n    ) external view returns (uint256);\n    function updateSignerWalletAddress(address newSignerAddress) external;\n    function updateCommunityAdmin(ICommunityAdmin communityAdmin) external;\n    function addLevel(uint256 levelId, IERC20 token) external;\n    function updateLevel(uint256 levelId, IERC20 token) external;\n    function fundLevel(uint256 levelId, uint256 amount) external;\n    function pauseLevel(uint256 levelId) external;\n    function unpauseLevel(uint256 levelId) external;\n    function cancelLevel(uint256 levelId, address fundRecipient) external;\n    function claimRewardForLevels(\n        address beneficiary,\n        uint256[] calldata levelIds,\n        uint256[] calldata rewardAmounts,\n        bytes[] calldata signatures\n    ) external;\n}\n"
    },
    "contracts/learnAndEarn/interfaces/LearnAndEarnStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./ILearnAndEarn.sol\";\n\n/**\n * @title Storage for LearnAndEarn\n * @notice For future upgrades, do not change LearnAndEarnStorageV1. Create a new\n * contract which implements LearnAndEarnStorageV1 and following the naming convention\n * LearnAndEarnStorageVX.\n */\nabstract contract LearnAndEarnStorageV1 is ILearnAndEarn {\n    address public override signerWalletAddress;\n    ICommunityAdmin public override communityAdmin;\n    EnumerableSet.UintSet internal _levelList;\n    mapping(uint256 => Level) public override levels;\n}\n"
    },
    "contracts/governor/impactMarketCouncil/interfaces/ImpactMarketCouncilStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport \"../../../community/interfaces/ICommunityAdmin.sol\";\nimport \"./IImpactMarketCouncil.sol\";\n\nabstract contract ImpactMarketCouncilStorageV1 is IImpactMarketCouncil {\n    ProxyAdmin public communityProxyAdmin;\n    ICommunityAdmin public communityAdmin;\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    uint256 public quorumVotes;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    /// @notice The council members\n    mapping(address => bool) public members;\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n    /// @notice The official each proposal's signatures:\n    /// An ordered list of function signatures to be called\n    mapping(uint256 => string[]) public proposalSignatures;\n    /// @notice The official each proposal's calldatas:\n    /// An ordered list of calldata to be passed to each call\n    mapping(uint256 => bytes[]) public proposalCalldatas;\n    /// @notice The official each proposal's receipts:\n    /// Receipts of ballots for the entire set of voters\n    mapping(uint256 => mapping(address => Receipt)) public proposalReceipts;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    /// @notice The official each proposal's targets:\n    /// An ordered list of target addresses for calls to be made\n    mapping(uint256 => address[]) public proposalTargets;\n}\n"
    },
    "contracts/community/interfaces/CommunityAdminStorageV2.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./CommunityAdminStorageV1.sol\";\nimport \"../../governor/impactMarketCouncil/interfaces/IImpactMarketCouncil.sol\";\nimport \"../../ambassadors/interfaces/IAmbassadors.sol\";\n\n/**\n * @title Storage for CommunityAdmin\n * @notice For future upgrades, do not change CommunityAdminStorageV1. Create a new\n * contract which implements CommunityAdminStorageV1 and following the naming convention\n * CommunityAdminStorageVX.\n */\nabstract contract CommunityAdminStorageV2 is CommunityAdminStorageV1 {\n    IImpactMarketCouncil public override impactMarketCouncil;\n    IAmbassadors public override ambassadors;\n    address public override communityMiddleProxy;\n}\n"
    },
    "contracts/community/interfaces/CommunityAdminStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport \"./ICommunityAdmin.sol\";\nimport \"../../treasury/interfaces/ITreasury.sol\";\n\n/**\n * @title Storage for CommunityAdmin\n * @notice For future upgrades, do not change CommunityAdminStorageV1. Create a new\n * contract which implements CommunityAdminStorageV1 and following the naming convention\n * CommunityAdminStorageVX.\n */\nabstract contract CommunityAdminStorageV1 is ICommunityAdmin {\n    IERC20 public override cUSD;\n    ITreasury public override treasury;\n    ICommunity public override communityImplementation;\n    ProxyAdmin public override communityProxyAdmin;\n\n    mapping(address => CommunityState) public override communities;\n    EnumerableSet.AddressSet internal communityList;\n}\n"
    },
    "contracts/ambassadors/interfaces/AmbassadorsStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./IAmbassadors.sol\";\nimport \"../../community/interfaces/ICommunityAdmin.sol\";\n\n/**\n * @title Storage for Ambassadors\n * @notice For future upgrades, do not change AmbassadorsStorageV1. Create a new\n * contract which implements AmbassadorsStorageV1 and following the naming convention\n * AmbassadorsStorageVX.\n */\nabstract contract AmbassadorsStorageV1 is IAmbassadors {\n    uint256 public ambassadorIndex;\n    uint256 public entityIndex;\n\n    ICommunityAdmin public communityAdmin;\n    // address to index\n    mapping(address => uint256) public ambassadorByAddress;\n    // index to address\n    mapping(uint256 => address) public ambassadorByIndex;\n    // communities an ambassador is responsible for\n    mapping(uint256 => EnumerableSet.AddressSet) internal ambassadorCommunities;\n    // community address to ambassador index\n    mapping(address => uint256) public communityToAmbassador;\n    // ambassador belongs to entity\n    mapping(uint256 => uint256) public ambassadorToEntity;\n    // entity adding ambassadors\n    mapping(address => uint256) public entityByAddress;\n    // entity adding ambassadors\n    mapping(uint256 => address) public entityByIndex;\n    // number of ambassadors an entity is responsible for\n    mapping(uint256 => uint256) public entityAmbassadors;\n}\n"
    },
    "contracts/staking/interfaces/StakingStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./IStaking.sol\";\n\n/**\n * @title Storage for DonationMiner\n * @notice For future upgrades, do not change DonationMinerStorageV1. Create a new\n * contract which implements DonationMinerStorageV1 and following the naming convention\n * DonationMinerStorageVX.\n */\nabstract contract StakingStorageV1 is IStaking {\n    IERC20 public override PACT;\n    IMintableERC20 public override SPACT;\n    IDonationMiner public override donationMiner;\n    uint256 public override cooldown;\n\n    uint256 public override currentTotalAmount;\n\n    mapping(address => Holder) internal _holders;\n    EnumerableSet.AddressSet internal stakeholdersList;\n}\n"
    },
    "contracts/staking/StakingImplementation.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./interfaces/StakingStorageV1.sol\";\n\ncontract StakingImplementation is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    StakingStorageV1\n{\n    using SafeERC20Upgradeable for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /**\n     * @notice Triggered when some tokens have been staked\n     *\n     * @param holder     Address of the holder\n     * @param amount     Stake amount\n     */\n    event Staked(address indexed holder, uint256 amount);\n\n    /**\n     * @notice Triggered when some tokens have been unstaked\n     *\n     * @param holder     Address of the holder\n     * @param amount     Unstake amount\n     */\n    event Unstaked(address indexed holder, uint256 amount);\n\n    /**\n     * @notice Triggered when some tokens have been claimed\n     *\n     * @param holder     Address of the holder\n     * @param amount     Claim amount\n     */\n    event Claimed(address indexed holder, uint256 amount);\n\n    /**\n     * @notice Triggered when some tokens have been partially claimed\n     *\n     * @param holder          Address of the holder\n     * @param amount          Claim amount\n     * @param lastUnstakeId   Last unstake is to be claimed (if possible)\n     */\n    event ClaimedPartial(address indexed holder, uint256 amount, uint256 lastUnstakeId);\n\n    /**\n     * @notice Triggered when the cooldown value has been updated\n     *\n     * @param oldCooldown            Old cooldown value\n     * @param newCooldown            New cooldown value\n     */\n    event CooldownUpdated(uint256 oldCooldown, uint256 newCooldown);\n\n    /**\n     * @notice Used to initialize a new DonationMiner contract\n     *\n     * @param _PACT                 Address of the PACT Token\n     * @param _SPACT                Address of the SPACT Token\n     * @param _donationMiner        Address of the DonationMiner\n     * @param _cooldown             Number of blocks after a user can claim an unstake\n     */\n    function initialize(\n        IERC20 _PACT,\n        IMintableERC20 _SPACT,\n        IDonationMiner _donationMiner,\n        uint256 _cooldown\n    ) public initializer {\n        require(address(_PACT) != address(0), \"Stake::initialize: invalid _PACT address\");\n        require(address(_SPACT) != address(0), \"Stake::initialize: invalid _SPACT address\");\n        require(\n            address(_donationMiner) != address(0),\n            \"Stake::initialize: invalid _donationMiner address\"\n        );\n\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        PACT = _PACT;\n        SPACT = _SPACT;\n        donationMiner = _donationMiner;\n        cooldown = _cooldown;\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice Updates cooldown value\n     *\n     * @param _newCooldown        Number of blocks after a user can claim an unstake\n     */\n    function updateCooldown(uint256 _newCooldown) external override onlyOwner {\n        emit CooldownUpdated(cooldown, _newCooldown);\n\n        cooldown = _newCooldown;\n    }\n\n    function stakeholderAmount(address _holderAddress) external view override returns (uint256) {\n        return _holders[_holderAddress].amount;\n    }\n\n    function stakeholder(address _holderAddress)\n        external\n        view\n        override\n        returns (\n            uint256 amount,\n            uint256 nextUnstakeId,\n            uint256 unstakeListLength,\n            uint256 unstakedAmount\n        )\n    {\n        Holder storage _holder = _holders[_holderAddress];\n        return (\n            _holder.amount,\n            _holder.nextUnstakeId,\n            _holder.unstakes.length,\n            SPACT.balanceOf(_holderAddress) - _holder.amount\n        );\n    }\n\n    function stakeholderUnstakeAt(address _holderAddress, uint256 _unstakeIndex)\n        external\n        view\n        override\n        returns (Unstake memory)\n    {\n        return _holders[_holderAddress].unstakes[_unstakeIndex];\n    }\n\n    /**\n     * @notice Returns the address of a stakeholder from stakeholdersList\n     *\n     * @param _index index of the stakeholder\n     * @return address of the stakeholder\n     */\n    function stakeholdersListAt(uint256 _index) external view override returns (address) {\n        return stakeholdersList.at(_index);\n    }\n\n    /**\n     * @notice Returns the number of stakeholders\n     *\n     * @return uint256 number of stakeholders\n     */\n    function stakeholdersListLength() external view override returns (uint256) {\n        return stakeholdersList.length();\n    }\n\n    /**\n     * @notice Stakes new founds for the holder\n     *\n     * @param _holderAddress Address of the holder\n     * @param _amount Amount of cUSD tokens to stake\n     */\n    function stake(address _holderAddress, uint256 _amount) external override nonReentrant {\n        require(_amount > 0, \"Stake::stake: Amount can't be 0\");\n        require(_amount <= type(uint96).max, \"Stake::stake: Stake amount too big\");\n\n        IERC20Upgradeable(address(PACT)).safeTransferFrom(msg.sender, address(this), _amount);\n        SPACT.mint(_holderAddress, uint96(_amount));\n\n        //.add method checks if the stakeholdersList already contains this address\n        stakeholdersList.add(_holderAddress);\n\n        Holder storage _holder = _holders[_holderAddress];\n\n        _holder.amount += _amount;\n        currentTotalAmount += _amount;\n\n        donationMiner.setStakingAmounts(_holderAddress, _holder.amount, currentTotalAmount);\n\n        emit Staked(_holderAddress, _amount);\n    }\n\n    /**\n     * @notice Unstake\n     *\n     * @param _amount number of tokens to be unstaked\n     */\n    function unstake(uint256 _amount) external override {\n        require(_amount > 0, \"Stake::unstake: Unstake amount should not be 0\");\n        require(_amount <= type(uint96).max, \"Stake::unstake: Unstake amount too big\");\n\n        Holder storage _holder = _holders[msg.sender];\n\n        require(_holder.amount >= _amount, \"Stake::unstake: Not enough funds\");\n\n        _holder.unstakes.push(Unstake({amount: _amount, cooldownBlock: block.number + cooldown}));\n\n        _holder.amount -= _amount;\n        currentTotalAmount -= _amount;\n\n        donationMiner.setStakingAmounts(msg.sender, _holder.amount, currentTotalAmount);\n\n        emit Unstaked(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Claim all unstakes that are older than cooldown\n     */\n    function claim() external override nonReentrant {\n        require(_holders[msg.sender].unstakes.length > 0, \"Stake::claim: No funds to claim\");\n\n        emit Claimed(msg.sender, _claim(_holders[msg.sender].unstakes.length - 1));\n    }\n\n    /**\n     * @notice Claim all unstakes until _lastUnstakeId\n     */\n    function claimPartial(uint256 _lastUnstakeId) external override nonReentrant {\n        require(\n            _lastUnstakeId < _holders[msg.sender].unstakes.length,\n            \"Stake::claimPartial: lastUnstakeId too big\"\n        );\n\n        emit ClaimedPartial(msg.sender, _claim(_lastUnstakeId), _lastUnstakeId);\n    }\n\n    function claimAmount(address _holderAddress) external view override returns (uint256) {\n        Holder storage _holder = _holders[_holderAddress];\n\n        if (_holder.unstakes.length == 0) {\n            return 0;\n        }\n\n        uint256 _index = _holder.nextUnstakeId;\n        uint256 _amount;\n\n        while (\n            _index < _holder.unstakes.length &&\n            _holder.unstakes[_index].cooldownBlock < block.number\n        ) {\n            _amount += _holder.unstakes[_index].amount;\n            _index++;\n        }\n\n        return _amount;\n    }\n\n    function _claim(uint256 _lastUnstakeId) internal returns (uint256) {\n        Holder storage _holder = _holders[msg.sender];\n\n        uint256 _index = _holder.nextUnstakeId;\n        uint256 _amount;\n\n        while (_index <= _lastUnstakeId && _holder.unstakes[_index].cooldownBlock < block.number) {\n            _amount += _holder.unstakes[_index].amount;\n            _index++;\n        }\n\n        require(_amount > 0, \"Stake::claim: No funds to claim\");\n\n        _holder.nextUnstakeId = _index;\n\n        SPACT.burn(msg.sender, uint96(_amount));\n        IERC20Upgradeable(address(PACT)).safeTransfer(msg.sender, _amount);\n\n        return _amount;\n    }\n}\n"
    },
    "contracts/mocks/community/CommunityOld.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./interfaces/ICommunity.sol\";\nimport \"./interfaces/ICommunityOld.sol\";\nimport \"./interfaces/ICommunityAdmin.sol\";\nimport \"./interfaces/CommunityStorageV1.sol\";\n\n/**\n * @notice Welcome to the Community contract. For each community\n * there will be one proxy contract deployed by CommunityAdmin.\n * The implementation of the proxy is this contract. This enable\n * us to save tokens on the contract itself, and avoid the problems\n * of having everything in one single contract.\n *Each community has it's own members and and managers.\n */\ncontract CommunityOld is\n    Initializable,\n    AccessControlUpgradeable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    CommunityStorageV1\n{\n    using SafeERC20Upgradeable for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    bytes32 private constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n    uint256 private constant DEFAULT_AMOUNT = 5e16;\n\n    /**\n     * @notice Triggered when a manager has been added\n     *\n     * @param manager           Address of the manager that triggered the event\n     *                          or address of the CommunityAdmin if it's first manager\n     * @param account           Address of the manager that has been added\n     */\n    event ManagerAdded(address indexed manager, address indexed account);\n\n    /**\n     * @notice Triggered when a manager has been removed\n     *\n     * @param manager           Address of the manager that triggered the event\n     * @param account           Address of the manager that has been removed\n     */\n    event ManagerRemoved(address indexed manager, address indexed account);\n\n    /**\n     * @notice Triggered when a beneficiary has been added\n     *\n     * @param manager           Address of the manager that triggered the event\n     * @param beneficiary       Address of the beneficiary that has been added\n     */\n    event BeneficiaryAdded(address indexed manager, address indexed beneficiary);\n\n    /**\n     * @notice Triggered when a beneficiary has been locked\n     *\n     * @param manager           Address of the manager that triggered the event\n     * @param beneficiary       Address of the beneficiary that has been locked\n     */\n    event BeneficiaryLocked(address indexed manager, address indexed beneficiary);\n\n    /**\n     * @notice Triggered when a beneficiary has been unlocked\n     *\n     * @param manager           Address of the manager that triggered the event\n     * @param beneficiary       Address of the beneficiary that has been unlocked\n     */\n    event BeneficiaryUnlocked(address indexed manager, address indexed beneficiary);\n\n    /**\n     * @notice Triggered when a beneficiary has been removed\n     *\n     * @param manager           Address of the manager that triggered the event\n     * @param beneficiary       Address of the beneficiary that has been removed\n     */\n    event BeneficiaryRemoved(address indexed manager, address indexed beneficiary);\n\n    /**\n     * @notice Triggered when a beneficiary has claimed\n     *\n     * @param beneficiary       Address of the beneficiary that has claimed\n     * @param amount            Amount of the claim\n     */\n    event BeneficiaryClaim(address indexed beneficiary, uint256 amount);\n\n    /**\n     * @notice Triggered when a community has been locked\n     *\n     * @param manager           Address of the manager that triggered the event\n     */\n    event CommunityLocked(address indexed manager);\n\n    /**\n     * @notice Triggered when a community has been unlocked\n     *\n     * @param manager           Address of the manager that triggered the event\n     */\n    event CommunityUnlocked(address indexed manager);\n\n    /**\n     * @notice Triggered when a manager has requested funds for community\n     *\n     * @param manager           Address of the manager that triggered the event\n     */\n    event FundsRequested(address indexed manager);\n\n    /**\n     * @notice Triggered when someone has donated cUSD\n     *\n     * @param donor             Address of the donor\n     * @param amount            Amount of the donation\n     */\n    event Donate(address indexed donor, uint256 amount);\n\n    /**\n     * @notice Triggered when a beneficiary from previous community has joined in the current community\n     *\n     * @param beneficiary       Address of the beneficiary\n     */\n    event BeneficiaryJoined(address indexed beneficiary);\n\n    /**\n     * @notice Triggered when beneficiary params has been updated\n     *\n     * @param oldClaimAmount       Old claimAmount value\n     * @param oldMaxClaim          Old maxClaim value\n     * @param oldDecreaseStep      Old decreaseStep value\n     * @param oldBaseInterval      Old baseInterval value\n     * @param oldIncrementInterval Old incrementInterval value\n     * @param newClaimAmount       New claimAmount value\n     * @param newMaxClaim          New maxClaim value\n     * @param newDecreaseStep      New decreaseStep value\n     * @param newBaseInterval      New baseInterval value\n     * @param newIncrementInterval New incrementInterval value\n     *\n     * For further information regarding each parameter, see\n     * *Community* smart contract initialize method.\n     */\n    event BeneficiaryParamsUpdated(\n        uint256 oldClaimAmount,\n        uint256 oldMaxClaim,\n        uint256 oldDecreaseStep,\n        uint256 oldBaseInterval,\n        uint256 oldIncrementInterval,\n        uint256 newClaimAmount,\n        uint256 newMaxClaim,\n        uint256 newDecreaseStep,\n        uint256 newBaseInterval,\n        uint256 newIncrementInterval\n    );\n\n    /**\n     * @notice Triggered when community params has been updated\n     *\n     * @param oldMinTranche        Old minTranche value\n     * @param oldMaxTranche        Old maxTranche value\n     * @param newMinTranche        New minTranche value\n     * @param newMaxTranche        New maxTranche value\n     *\n     * For further information regarding each parameter, see\n     * *Community* smart contract initialize method.\n     */\n    event CommunityParamsUpdated(\n        uint256 oldMinTranche,\n        uint256 oldMaxTranche,\n        uint256 newMinTranche,\n        uint256 newMaxTranche\n    );\n\n    /**\n     * @notice Triggered when communityAdmin has been updated\n     *\n     * @param oldCommunityAdmin   Old communityAdmin address\n     * @param newCommunityAdmin   New communityAdmin address\n     */\n    event CommunityAdminUpdated(\n        address indexed oldCommunityAdmin,\n        address indexed newCommunityAdmin\n    );\n\n    /**\n     * @notice Triggered when previousCommunity has been updated\n     *\n     * @param oldPreviousCommunity   Old previousCommunity address\n     * @param newPreviousCommunity   New previousCommunity address\n     */\n    event PreviousCommunityUpdated(\n        address indexed oldPreviousCommunity,\n        address indexed newPreviousCommunity\n    );\n\n    /**\n     * @notice Triggered when an amount of an ERC20 has been transferred from this contract to an address\n     *\n     * @param token               ERC20 token address\n     * @param to                  Address of the receiver\n     * @param amount              Amount of the transaction\n     */\n    event TransferERC20(address indexed token, address indexed to, uint256 amount);\n\n    /**\n     * @notice Used to initialize a new Community contract\n     *\n     * @param _managers            Community's initial managers.\n     *                             Will be able to add others\n     * @param _claimAmount         Base amount to be claim by the beneficiary\n     * @param _maxClaim            Limit that a beneficiary can claim in total\n     * @param _decreaseStep        Value decreased from maxClaim each time a beneficiary is added\n     * @param _baseInterval        Base interval to start claiming\n     * @param _incrementInterval   Increment interval used in each claim\n     * @param _previousCommunity   Previous smart contract address of community\n     * @param _minTranche          Minimum amount that the community will receive when requesting funds\n     * @param _maxTranche          Maximum amount that the community will receive when requesting funds\n     */\n    function initialize(\n        address[] memory _managers,\n        uint256 _claimAmount,\n        uint256 _maxClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval,\n        uint256 _minTranche,\n        uint256 _maxTranche,\n        ICommunity _previousCommunity\n    ) external initializer {\n        require(\n            _baseInterval > _incrementInterval,\n            \"Community::initialize: baseInterval must be greater than incrementInterval\"\n        );\n        require(\n            _maxClaim > _claimAmount,\n            \"Community::initialize: maxClaim must be greater than claimAmount\"\n        );\n\n        require(\n            _minTranche <= _maxTranche,\n            \"Community::initialize: minTranche should not be greater than maxTranche\"\n        );\n\n        __AccessControl_init();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        claimAmount = _claimAmount;\n        baseInterval = _baseInterval;\n        incrementInterval = _incrementInterval;\n        maxClaim = _maxClaim;\n        minTranche = _minTranche;\n        maxTranche = _maxTranche;\n        previousCommunity = _previousCommunity;\n        communityAdmin = ICommunityAdmin(msg.sender);\n        decreaseStep = _decreaseStep;\n        locked = false;\n\n        transferOwnership(msg.sender);\n\n        // MANAGER_ROLE is the admin for the MANAGER_ROLE\n        // so every manager is able to add or remove other managers\n        _setRoleAdmin(MANAGER_ROLE, MANAGER_ROLE);\n\n        _setupRole(MANAGER_ROLE, msg.sender);\n        emit ManagerAdded(msg.sender, msg.sender);\n\n        for (uint256 i = 0; i < _managers.length; i++) {\n            addManager(_managers[i]);\n        }\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice Enforces sender to be a valid beneficiary\n     */\n    modifier onlyValidBeneficiary() {\n        require(\n            beneficiaries[msg.sender].state == BeneficiaryState.Valid,\n            \"Community: NOT_VALID_BENEFICIARY\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Enforces sender to have manager role\n     */\n    modifier onlyManagers() {\n        require(hasRole(MANAGER_ROLE, msg.sender), \"Community: NOT_MANAGER\");\n        _;\n    }\n\n    /**\n     * @notice Returns the cUSD contract address\n     */\n    function cUSD() public view override returns (IERC20) {\n        return communityAdmin.cUSD();\n    }\n\n    /**\n     * @notice Returns the length of the beneficiaryList\n     */\n    function beneficiaryListLength() external view override returns (uint256) {\n        return beneficiaryList.length();\n    }\n\n    /**\n     * @notice Returns an address from the beneficiaryList\n     *\n     * @param index_ index value\n     * @return address of the beneficiary\n     */\n    function beneficiaryListAt(uint256 index_) external view override returns (address) {\n        return beneficiaryList.at(index_);\n    }\n\n    /**\n     * @notice Returns the 0 address\n     * only used for backwards compatibility\n     */\n    function impactMarketAddress() public pure override returns (address) {\n        return address(0);\n    }\n\n    /** Updates the address of the communityAdmin\n     *\n     * @param _newCommunityAdmin address of the new communityAdmin\n     */\n    function updateCommunityAdmin(ICommunityAdmin _newCommunityAdmin) external override onlyOwner {\n        address _oldCommunityAdminAddress = address(communityAdmin);\n        communityAdmin = _newCommunityAdmin;\n\n        addManager(address(communityAdmin));\n\n        emit CommunityAdminUpdated(_oldCommunityAdminAddress, address(_newCommunityAdmin));\n    }\n\n    /** Updates the address of the previousCommunity\n     *\n     * @param _newPreviousCommunity address of the new previousCommunity\n     */\n    function updatePreviousCommunity(ICommunity _newPreviousCommunity) external override onlyOwner {\n        address _oldPreviousCommunityAddress = address(previousCommunity);\n        previousCommunity = _newPreviousCommunity;\n\n        emit PreviousCommunityUpdated(_oldPreviousCommunityAddress, address(_newPreviousCommunity));\n    }\n\n    /** Updates beneficiary params\n     *\n     * @param _claimAmount  base amount to be claim by the beneficiary\n     * @param _maxClaim limit that a beneficiary can claim  in total\n     * @param _decreaseStep value decreased from maxClaim each time a is beneficiary added\n     * @param _baseInterval base interval to start claiming\n     * @param _incrementInterval increment interval used in each claim\n     */\n    function updateBeneficiaryParams(\n        uint256 _claimAmount,\n        uint256 _maxClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval\n    ) external override onlyOwner {\n        require(\n            _baseInterval > _incrementInterval,\n            \"Community::constructor: baseInterval must be greater than incrementInterval\"\n        );\n        require(\n            _maxClaim > _claimAmount,\n            \"Community::constructor: maxClaim must be greater than claimAmount\"\n        );\n\n        uint256 _oldClaimAmount = claimAmount;\n        uint256 _oldMaxClaim = maxClaim;\n        uint256 _oldDecreaseStep = decreaseStep;\n        uint256 _oldBaseInterval = baseInterval;\n        uint256 _oldIncrementInterval = incrementInterval;\n\n        claimAmount = _claimAmount;\n        maxClaim = _maxClaim;\n        decreaseStep = _decreaseStep;\n        baseInterval = _baseInterval;\n        incrementInterval = _incrementInterval;\n\n        emit BeneficiaryParamsUpdated(\n            _oldClaimAmount,\n            _oldMaxClaim,\n            _oldDecreaseStep,\n            _oldBaseInterval,\n            _oldIncrementInterval,\n            _claimAmount,\n            _maxClaim,\n            _decreaseStep,\n            _baseInterval,\n            _incrementInterval\n        );\n    }\n\n    /** @notice Updates params of a community\n     *\n     * @param _minTranche minimum amount that the community will receive when requesting funds\n     * @param _maxTranche maximum amount that the community will receive when requesting funds\n     */\n    function updateCommunityParams(uint256 _minTranche, uint256 _maxTranche)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            _minTranche <= _maxTranche,\n            \"Community::updateCommunityParams: minTranche should not be greater than maxTranche\"\n        );\n\n        uint256 _oldMinTranche = minTranche;\n        uint256 _oldMaxTranche = maxTranche;\n\n        minTranche = _minTranche;\n        maxTranche = _maxTranche;\n\n        emit CommunityParamsUpdated(_oldMinTranche, _oldMaxTranche, _minTranche, _maxTranche);\n    }\n\n    /**\n     * @notice Adds a new manager\n     *\n     * @param _account address of the manager to be added\n     */\n    function addManager(address _account) public override onlyManagers {\n        if (!hasRole(MANAGER_ROLE, _account)) {\n            super.grantRole(MANAGER_ROLE, _account);\n            emit ManagerAdded(msg.sender, _account);\n        }\n    }\n\n    /**\n     * @notice Remove an existing manager\n     *\n     * @param _account address of the manager to be removed\n     */\n    function removeManager(address _account) external override onlyManagers {\n        require(\n            hasRole(MANAGER_ROLE, _account),\n            \"Community::removeManager: This account doesn't have manager role\"\n        );\n        require(\n            _account != address(communityAdmin),\n            \"Community::removeManager: You are not allow to remove communityAdmin\"\n        );\n        super.revokeRole(MANAGER_ROLE, _account);\n        emit ManagerRemoved(msg.sender, _account);\n    }\n\n    /**\n     * @notice Enforces managers to use addManager method\n     */\n    function grantRole(bytes32, address) public pure override {\n        require(false, \"Community::grantRole: You are not allow to use this method\");\n    }\n\n    /**\n     * @notice Enforces managers to use removeManager method\n     */\n    function revokeRole(bytes32, address) public pure override {\n        require(false, \"Community::revokeRole: You are not allow to use this method\");\n    }\n\n    /**\n     * @notice Adds a new beneficiary\n     *\n     * @param _beneficiaryAddress address of the beneficiary to be added\n     */\n    function addBeneficiary(address _beneficiaryAddress)\n        external\n        override\n        onlyManagers\n        nonReentrant\n    {\n        Beneficiary storage _beneficiary = beneficiaries[_beneficiaryAddress];\n        require(\n            _beneficiary.state == BeneficiaryState.NONE,\n            \"Community::addBeneficiary: Beneficiary exists\"\n        );\n        _changeBeneficiaryState(_beneficiary, BeneficiaryState.Valid);\n        // solhint-disable-next-line not-rely-on-time\n        _beneficiary.lastClaim = block.number;\n\n        beneficiaryList.add(_beneficiaryAddress);\n\n        // send default amount when adding a new beneficiary\n        cUSD().safeTransfer(_beneficiaryAddress, DEFAULT_AMOUNT);\n\n        emit BeneficiaryAdded(msg.sender, _beneficiaryAddress);\n    }\n\n    /**\n     * @notice Locks a valid beneficiary\n     *\n     * @param _beneficiaryAddress address of the beneficiary to be locked\n     */\n    function lockBeneficiary(address _beneficiaryAddress) external override onlyManagers {\n        Beneficiary storage _beneficiary = beneficiaries[_beneficiaryAddress];\n\n        require(\n            _beneficiary.state == BeneficiaryState.Valid,\n            \"Community::lockBeneficiary: NOT_YET\"\n        );\n        _changeBeneficiaryState(_beneficiary, BeneficiaryState.Locked);\n        emit BeneficiaryLocked(msg.sender, _beneficiaryAddress);\n    }\n\n    /**\n     * @notice  Unlocks a locked beneficiary\n     *\n     * @param _beneficiaryAddress address of the beneficiary to be unlocked\n     */\n    function unlockBeneficiary(address _beneficiaryAddress) external override onlyManagers {\n        Beneficiary storage _beneficiary = beneficiaries[_beneficiaryAddress];\n\n        require(\n            _beneficiary.state == BeneficiaryState.Locked,\n            \"Community::unlockBeneficiary: NOT_YET\"\n        );\n        _changeBeneficiaryState(_beneficiary, BeneficiaryState.Valid);\n        emit BeneficiaryUnlocked(msg.sender, _beneficiaryAddress);\n    }\n\n    /**\n     * @notice Remove an existing beneficiary\n     *\n     * @param _beneficiaryAddress address of the beneficiary to be removed\n     */\n    function removeBeneficiary(address _beneficiaryAddress) external override onlyManagers {\n        Beneficiary storage _beneficiary = beneficiaries[_beneficiaryAddress];\n\n        require(\n            _beneficiary.state == BeneficiaryState.Valid ||\n                _beneficiary.state == BeneficiaryState.Locked,\n            \"Community::removeBeneficiary: NOT_YET\"\n        );\n        _changeBeneficiaryState(_beneficiary, BeneficiaryState.Removed);\n        emit BeneficiaryRemoved(msg.sender, _beneficiaryAddress);\n    }\n\n    /**\n     * @dev Transfers cUSD to a valid beneficiary\n     */\n    function claim() external override onlyValidBeneficiary nonReentrant {\n        Beneficiary storage _beneficiary = beneficiaries[msg.sender];\n\n        require(!locked, \"LOCKED\");\n        require(claimCooldown(msg.sender) <= block.number, \"Community::claim: NOT_YET\");\n        require(\n            (_beneficiary.claimedAmount + claimAmount) <= maxClaim,\n            \"Community::claim: MAX_CLAIM\"\n        );\n\n        _beneficiary.claimedAmount += claimAmount;\n        _beneficiary.claims++;\n        _beneficiary.lastClaim = block.number;\n\n        cUSD().safeTransfer(msg.sender, claimAmount);\n        emit BeneficiaryClaim(msg.sender, claimAmount);\n    }\n\n    /**\n     * @notice Returns the number of blocks that a beneficiary have to wait between claims\n     *\n     * @param _beneficiaryAddress address of the beneficiary\n     * @return uint256 number of blocks for the lastInterval\n     */\n    function lastInterval(address _beneficiaryAddress) public view override returns (uint256) {\n        Beneficiary storage _beneficiary = beneficiaries[_beneficiaryAddress];\n        if (_beneficiary.claims == 0) {\n            return 0;\n        }\n        return baseInterval + (_beneficiary.claims - 1) * incrementInterval;\n    }\n\n    /**\n     * @notice Returns the block number when a beneficiary can claim again\n     *\n     * @param _beneficiaryAddress address of the beneficiary\n     * @return uint256 number of block when the beneficiary can claim\n     */\n    function claimCooldown(address _beneficiaryAddress) public view override returns (uint256) {\n        return beneficiaries[_beneficiaryAddress].lastClaim + lastInterval(_beneficiaryAddress);\n    }\n\n    /**\n     * @notice Locks the community claims\n     */\n    function lock() external override onlyManagers {\n        locked = true;\n        emit CommunityLocked(msg.sender);\n    }\n\n    /**\n     * @notice Unlocks the community claims\n     */\n    function unlock() external override onlyManagers {\n        locked = false;\n        emit CommunityUnlocked(msg.sender);\n    }\n\n    /**\n     * @notice Requests treasury funds from the communityAdmin\n     */\n    function requestFunds() external override onlyManagers {\n        communityAdmin.fundCommunity();\n\n        lastFundRequest = block.number;\n\n        emit FundsRequested(msg.sender);\n    }\n\n    /**\n     * @notice Transfers cUSDs from donor to this community\n     * Used by donationToCommunity method from DonationMiner contract\n     *\n     * @param _sender address of the sender\n     * @param _amount amount to be donated\n     */\n    function donate(address _sender, uint256 _amount) external override nonReentrant {\n        cUSD().safeTransferFrom(_sender, address(this), _amount);\n        privateFunds += _amount;\n\n        emit Donate(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Increases the treasuryFunds value\n     * Used by communityAdmin after an amount of cUSD are sent from the treasury\n     *\n     * @param _amount amount to be added to treasuryFunds\n     */\n    function addTreasuryFunds(uint256 _amount) external override onlyOwner {\n        treasuryFunds += _amount;\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from this contract to an address\n     *\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyOwner nonReentrant {\n        _token.safeTransfer(_to, _amount);\n\n        emit TransferERC20(address(_token), _to, _amount);\n    }\n\n    /**\n     * @notice Allows a beneficiary from the previousCommunity to join in this community\n     */\n    function beneficiaryJoinFromMigrated() external override {\n        // no need to check if it's a beneficiary, as the state is copied\n        Beneficiary storage _beneficiary = beneficiaries[msg.sender];\n\n        require(\n            _beneficiary.state == BeneficiaryState.NONE,\n            \"Community::beneficiaryJoinFromMigrated: Beneficiary exists\"\n        );\n\n        //if the previousCommunity is deployed with the new type of smart contract\n        if (previousCommunity.impactMarketAddress() == address(0)) {\n            (\n                BeneficiaryState _oldBeneficiaryState,\n                uint256 _oldBeneficiaryClaims,\n                uint256 _oldBeneficiaryClaimedAmount,\n                uint256 _oldBeneficiaryLastClaim\n            ) = previousCommunity.beneficiaries(msg.sender);\n\n            _changeBeneficiaryState(_beneficiary, _oldBeneficiaryState);\n            _beneficiary.claims = _oldBeneficiaryClaims;\n            _beneficiary.lastClaim = _oldBeneficiaryLastClaim;\n            _beneficiary.claimedAmount = _oldBeneficiaryClaimedAmount;\n        } else {\n            ICommunityOld _oldCommunity = ICommunityOld(address(previousCommunity));\n            uint256 _oldBeneficiaryLastInterval = _oldCommunity.lastInterval(msg.sender);\n            _changeBeneficiaryState(\n                _beneficiary,\n                BeneficiaryState(_oldCommunity.beneficiaries(msg.sender))\n            );\n\n            uint256 _oldBeneficiaryCooldown = _oldCommunity.cooldown(msg.sender);\n\n            if (_oldBeneficiaryCooldown >= _oldBeneficiaryLastInterval + _firstBlockTimestamp()) {\n                // seconds to blocks conversion\n                _beneficiary.lastClaim =\n                    (_oldBeneficiaryCooldown -\n                        _oldBeneficiaryLastInterval -\n                        _firstBlockTimestamp()) /\n                    5;\n            } else {\n                _beneficiary.lastClaim = 0;\n            }\n\n            _beneficiary.claimedAmount = _oldCommunity.claimed(msg.sender);\n\n            uint256 _previousBaseInterval = _oldCommunity.baseInterval();\n            if (_oldBeneficiaryLastInterval >= _previousBaseInterval) {\n                _beneficiary.claims =\n                    (_oldBeneficiaryLastInterval - _previousBaseInterval) /\n                    _oldCommunity.incrementInterval() +\n                    1;\n            } else {\n                _beneficiary.claims = 0;\n            }\n        }\n\n        beneficiaryList.add(msg.sender);\n\n        emit BeneficiaryJoined(msg.sender);\n    }\n\n    /**\n     * @notice Returns the initial maxClaim\n     */\n    function getInitialMaxClaim() external view override returns (uint256) {\n        return maxClaim + validBeneficiaryCount * decreaseStep;\n    }\n\n    /**\n     * @notice Changes the state of a beneficiary\n     *\n     * @param _beneficiary address of the beneficiary\n     * @param _newState new state\n     */\n    function _changeBeneficiaryState(Beneficiary storage _beneficiary, BeneficiaryState _newState)\n        internal\n    {\n        if (_beneficiary.state == _newState) {\n            return;\n        }\n\n        if (_newState == BeneficiaryState.Valid) {\n            require(\n                maxClaim - decreaseStep >= claimAmount,\n                \"Community::_changeBeneficiaryState: Max claim too low\"\n            );\n            validBeneficiaryCount++;\n            maxClaim -= decreaseStep;\n        } else if (_beneficiary.state == BeneficiaryState.Valid) {\n            validBeneficiaryCount--;\n            maxClaim += decreaseStep;\n        }\n\n        _beneficiary.state = _newState;\n    }\n\n    function _firstBlockTimestamp() public view returns (uint256) {\n        if (block.chainid == 42220) {\n            //celo mainnet\n            return 1587571205;\n        } else if (block.chainid == 44787) {\n            //alfajores testnet\n            return 1594921556;\n        } else if (block.chainid == 44787) {\n            //baklava testnet\n            return 1593012289;\n        } else {\n            return block.timestamp - block.number; //local\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/mocks/community/interfaces/ICommunity.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"./ICommunityAdmin.sol\";\n\ninterface ICommunity {\n    enum BeneficiaryState {\n        NONE, //the beneficiary hasn't been added yet\n        Valid,\n        Locked,\n        Removed\n    }\n\n    struct Beneficiary {\n        BeneficiaryState state;  //beneficiary state\n        uint256 claims;          //total number of claims\n        uint256 claimedAmount;   //total amount of cUSD received\n        uint256 lastClaim;       //block number of the last claim\n    }\n\n    function getVersion() external pure returns(uint256);\n    function previousCommunity() external view returns(ICommunity);\n    function claimAmount() external view returns(uint256);\n    function baseInterval() external view returns(uint256);\n    function incrementInterval() external view returns(uint256);\n    function maxClaim() external view returns(uint256);\n    function validBeneficiaryCount() external view returns(uint);\n    function treasuryFunds() external view returns(uint);\n    function privateFunds() external view returns(uint);\n    function communityAdmin() external view returns(ICommunityAdmin);\n    function cUSD() external view  returns(IERC20);\n    function locked() external view returns(bool);\n    function beneficiaries(address _beneficiaryAddress) external view returns(\n        BeneficiaryState state,\n        uint256 claims,\n        uint256 claimedAmount,\n        uint256 lastClaim\n    );\n    function decreaseStep() external view returns(uint);\n    function beneficiaryListAt(uint256 _index) external view returns (address);\n    function beneficiaryListLength() external view returns (uint256);\n    function impactMarketAddress() external pure returns (address);\n    function minTranche() external view returns(uint256);\n    function maxTranche() external view returns(uint256);\n    function lastFundRequest() external view returns(uint256);\n\n    function updateCommunityAdmin(ICommunityAdmin _communityAdmin) external;\n    function updatePreviousCommunity(ICommunity _newPreviousCommunity) external;\n    function updateBeneficiaryParams(\n        uint256 _claimAmount,\n        uint256 _maxClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval\n    ) external;\n    function updateCommunityParams(\n        uint256 _minTranche,\n        uint256 _maxTranche\n    ) external;\n    function donate(address _sender, uint256 _amount) external;\n    function addTreasuryFunds(uint256 _amount) external;\n    function transfer(IERC20 _token, address _to, uint256 _amount) external;\n    function addManager(address _managerAddress) external;\n    function removeManager(address _managerAddress) external;\n    function addBeneficiary(address _beneficiaryAddress) external;\n    function lockBeneficiary(address _beneficiaryAddress) external;\n    function unlockBeneficiary(address _beneficiaryAddress) external;\n    function removeBeneficiary(address _beneficiaryAddress) external;\n    function claim() external;\n    function lastInterval(address _beneficiaryAddress) external view returns (uint256);\n    function claimCooldown(address _beneficiaryAddress) external view returns (uint256);\n    function lock() external;\n    function unlock() external;\n    function requestFunds() external;\n    function beneficiaryJoinFromMigrated() external;\n    function getInitialMaxClaim() external view returns (uint256);\n}\n"
    },
    "contracts/mocks/community/interfaces/ICommunityOld.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\ninterface ICommunityOld {\n    function cooldown(address _account) external returns(uint256);\n    function lastInterval(address _account) external returns(uint256);\n    function claimed(address _account) external returns(uint256);\n    function beneficiaries(address _account) external returns(uint256);\n    function claimAmount() external returns(uint256);\n    function baseInterval() external returns(uint256);\n    function incrementInterval() external returns(uint256);\n    function maxClaim() external returns(uint256);\n    function previousCommunityContract() external returns(address);\n    function impactMarketAddress() external returns(address);\n    function cUSDAddress() external returns(address);\n    function locked() external returns(bool);\n    function addManager(address _account) external;\n    function removeManager(address _account) external;\n    function addBeneficiary(address _account) external;\n    function lockBeneficiary(address _account) external;\n    function unlockBeneficiary(address _account) external;\n    function removeBeneficiary(address _account) external;\n    function claim() external;\n    function edit(uint256 _claimAmount, uint256 _maxClaim, uint256 _baseInterval, uint256 _incrementInterval) external;\n    function lock() external;\n    function unlock() external;\n    function migrateFunds(address _newCommunity, address _newCommunityManager) external;\n    function hasRole(bytes32 role, address account) external view returns(bool);\n}\n"
    },
    "contracts/mocks/community/interfaces/ICommunityAdmin.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"./ICommunity.sol\";\nimport \"../../treasury/interfaces/ITreasury.sol\";\n\ninterface ICommunityAdmin {\n    enum CommunityState {\n        NONE,\n        Valid,\n        Removed,\n        Migrated\n    }\n\n    function getVersion() external pure returns(uint256);\n    function cUSD() external view returns(IERC20);\n    function treasury() external view returns(ITreasury);\n    function communities(address _community) external view returns(CommunityState);\n    function communityTemplate() external view returns(ICommunity);\n    function communityProxyAdmin() external view returns(ProxyAdmin);\n    function communityListAt(uint256 _index) external view returns (address);\n    function communityListLength() external view returns (uint256);\n\n    function updateTreasury(ITreasury _newTreasury) external;\n    function updateCommunityTemplate(ICommunity _communityTemplate_) external;\n    function updateBeneficiaryParams(\n        ICommunity _community,\n        uint256 _claimAmount,\n        uint256 _maxClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval\n    ) external;\n    function updateCommunityParams(\n        ICommunity _community,\n        uint256 _minTranche,\n        uint256 _maxTranche\n    ) external;\n    function updateProxyImplementation(address _communityProxy, address _newLogic) external;\n    function addCommunity(\n        address[] memory _managers,\n        uint256 _claimAmount,\n        uint256 _maxClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval,\n        uint256 _minTranche,\n        uint256 _maxTranche\n    ) external;\n    function migrateCommunity(\n        address[] memory _managers,\n        ICommunity _previousCommunity\n    ) external;\n    function addManagerToCommunity(ICommunity _community_, address _account_) external;\n    function removeCommunity(ICommunity _community) external;\n    function fundCommunity() external;\n    function transfer(IERC20 _token, address _to, uint256 _amount) external;\n    function transferFromCommunity(\n        ICommunity _community,\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external;\n}\n"
    },
    "contracts/mocks/community/interfaces/CommunityStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./ICommunity.sol\";\nimport \"./ICommunityAdmin.sol\";\n\n/**\n * @title Storage for Community\n * @notice For future upgrades, do not change CommunityStorageV1. Create a new\n * contract which implements CommunityStorageV1 and following the naming convention\n * CommunityStorageVX.\n */\nabstract contract CommunityStorageV1 is ICommunity {\n    bool public override locked;\n    uint256 public override claimAmount;\n    uint256 public override baseInterval;\n    uint256 public override incrementInterval;\n    uint256 public override maxClaim;\n    uint256 public override validBeneficiaryCount;\n    uint256 public override treasuryFunds;\n    uint256 public override privateFunds;\n    uint256 public override decreaseStep;\n    uint256 public override minTranche;\n    uint256 public override maxTranche;\n    uint256 public override lastFundRequest;\n\n    ICommunity public override previousCommunity;\n    ICommunityAdmin public override communityAdmin;\n\n    mapping(address => Beneficiary) public override beneficiaries;\n    EnumerableSet.AddressSet internal beneficiaryList;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/mocks/treasury/interfaces/ITreasury.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../community/interfaces/ICommunityAdmin.sol\";\nimport \"./IUniswapV2Router.sol\";\n\ninterface ITreasury {\n    struct Token {\n        uint256 rate;\n        address[] exchangePath;\n    }\n\n    function getVersion() external pure returns(uint256);\n    function communityAdmin() external view returns(ICommunityAdmin);\n    function uniswapRouter() external view returns(IUniswapV2Router);\n    function updateCommunityAdmin(ICommunityAdmin _communityAdmin) external;\n    function updateUniswapRouter(IUniswapV2Router _uniswapRouter) external;\n    function transfer(IERC20 _token, address _to, uint256 _amount) external;\n    function isToken(address _tokenAddress) external view returns (bool);\n    function tokenListLength() external view returns (uint256);\n    function tokenListAt(uint256 _index) external view returns (address);\n    function tokens(address _tokenAddress) external view returns (uint256 rate, address[] memory exchangePath);\n    function setToken(address _tokenAddress, uint256 _rate, address[] calldata _exchangePath) external;\n    function removeToken(address _tokenAddress) external;\n    function getConvertedAmount(address _tokenAddress, uint256 _amount) external view returns (uint256);\n    function convertAmount(\n        address _tokenAddress,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] memory _exchangePath,\n        uint256 _deadline\n    ) external;\n}\n"
    },
    "contracts/mocks/treasury/interfaces/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\ninterface IUniswapV2Router {\n    function factory() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function pairFor(address tokenA, address tokenB) external view returns (address);\n}\n"
    },
    "contracts/mocks/community/interfaces/CommunityAdminStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport \"./ICommunityAdmin.sol\";\n\n/**\n * @title Storage for CommunityAdmin\n * @notice For future upgrades, do not change CommunityAdminStorageV1. Create a new\n * contract which implements CommunityAdminStorageV1 and following the naming convention\n * CommunityAdminStorageVX.\n */\nabstract contract CommunityAdminStorageV1 is ICommunityAdmin {\n    IERC20 public override cUSD;\n    ITreasury public override treasury;\n    ICommunity public override communityTemplate;\n    ProxyAdmin public override communityProxyAdmin;\n\n    mapping(address => CommunityState) public override communities;\n    EnumerableSet.AddressSet internal communityList;\n}\n"
    },
    "contracts/microcredit/ImpactMultiSigProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\ncontract ImpactMultiSigProxyAdmin is ProxyAdmin {}\n"
    },
    "contracts/microcredit/CouncilProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\ncontract CouncilProxyAdmin is ProxyAdmin {}\n"
    },
    "contracts/governor/ImpactProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\ncontract ImpactProxyAdmin is ProxyAdmin {}\n"
    },
    "contracts/community/CommunityAdminImplementation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./interfaces/ICommunity.sol\";\nimport \"./interfaces/IPreviousCommunity.sol\";\nimport \"./interfaces/CommunityAdminStorageV1.sol\";\nimport \"../governor/impactMarketCouncil/interfaces/IImpactMarketCouncil.sol\";\nimport \"./interfaces/CommunityAdminStorageV3.sol\";\n\n/**\n * @notice Welcome to CommunityAdmin, the main contract. This is an\n * administrative (for now) contract where the admins have control\n * over the list of communities. Being only able to add and\n * remove communities\n */\ncontract CommunityAdminImplementation is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    CommunityAdminStorageV3\n{\n    using SafeERC20Upgradeable for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant DEFAULT_AMOUNT = 5e16;\n    uint256 private constant MIN_CLAIM_AMOUNT_RATIO_PRECISION = 100;\n\n    /**\n     * @notice Triggered when a community has been added\n     *\n     * @param communityAddress       Address of the community that has been added\n     * @param managers               Addresses of the initial managers\n     * @param originalClaimAmount    Value of the originalClaimAmount\n     * @param maxTotalClaim          Value of the maxTotalClaim\n     * @param decreaseStep           Value of the decreaseStep\n     * @param baseInterval           Value of the baseInterval\n     * @param incrementInterval      Value of the incrementInterval\n     * @param minTranche             Value of the minTranche\n     * @param maxTranche             Value of the maxTranche\n     *\n     * For further information regarding each parameter, see\n     * *Community* smart contract initialize method.\n     */\n    event CommunityAdded(\n        address indexed communityAddress,\n        address[] managers,\n        uint256 originalClaimAmount,\n        uint256 maxTotalClaim,\n        uint256 decreaseStep,\n        uint256 baseInterval,\n        uint256 incrementInterval,\n        uint256 minTranche,\n        uint256 maxTranche\n    );\n\n    /**\n     * @notice Triggered when a community has been removed\n     *\n     * @param communityAddress  Address of the community that has been removed\n     */\n    event CommunityRemoved(address indexed communityAddress);\n\n    /**\n     * @notice Triggered when a community has been migrated\n     *\n     * @param managers                 Addresses of the new community's initial managers\n     * @param communityAddress         New community address\n     * @param previousCommunityAddress Old community address\n     */\n    event CommunityMigrated(\n        address[] managers,\n        address indexed communityAddress,\n        address indexed previousCommunityAddress\n    );\n\n    /**\n     * @notice Triggered when a community has been copied\n     *\n     * @param originalCommunity         Address of the community that has been copied\n     * @param copyCommunity             Address of the copy\n     */\n    event CommunityCopied(address indexed originalCommunity, address indexed copyCommunity);\n\n    /**\n     * @notice Triggered when the treasury address has been updated\n     *\n     * @param oldTreasury             Old treasury address\n     * @param newTreasury             New treasury address\n     */\n    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    /**\n     * @notice Triggered when the impactMarket Council has been updated\n     *\n     * @param oldImpactMarketCouncil   Old impactMarket Council address\n     * @param newImpactMarketCouncil   New impactMarket Council address\n     */\n    event ImpactMarketCouncilUpdated(\n        address indexed oldImpactMarketCouncil,\n        address indexed newImpactMarketCouncil\n    );\n\n    /**\n     * @notice Triggered when the ambassadors has been updated\n     *\n     * @param oldAmbassadors   Old Ambassador address\n     * @param newAmbassadors   New Ambassador address\n     */\n    event AmbassadorsUpdated(address indexed oldAmbassadors, address indexed newAmbassadors);\n\n    /**\n     * @notice Triggered when the communityMiddleProxy address has been updated\n     *\n     * @param oldCommunityMiddleProxy   Old communityMiddleProxy address\n     * @param newCommunityMiddleProxy   New communityMiddleProxy address\n     */\n    event CommunityMiddleProxyUpdated(\n        address oldCommunityMiddleProxy,\n        address newCommunityMiddleProxy\n    );\n\n    /**\n     * @notice Triggered when the communityImplementation address has been updated\n     *\n     * @param oldCommunityImplementation    Old communityImplementation address\n     * @param newCommunityImplementation    New communityImplementation address\n     */\n    event CommunityImplementationUpdated(\n        address indexed oldCommunityImplementation,\n        address indexed newCommunityImplementation\n    );\n\n    /**\n     * @notice Triggered when a community has been funded\n     *\n     * @param community           Address of the community\n     * @param amount              Amount of the funding\n     */\n    event CommunityFunded(address indexed community, uint256 amount);\n\n    /**\n     * @notice Triggered when an amount of an ERC20 has been transferred from this contract to an address\n     *\n     * @param token               ERC20 token address\n     * @param to                  Address of the receiver\n     * @param amount              Amount of the transaction\n     */\n    event TransferERC20(address indexed token, address indexed to, uint256 amount);\n\n    /**\n     * @notice Enforces sender to be a valid community\n     */\n    modifier onlyCommunities() {\n        require(communities[msg.sender] == CommunityState.Valid, \"CommunityAdmin: NOT_COMMUNITY\");\n        _;\n    }\n\n    /**\n     * @notice Enforces sender to DAO or impactMarketCouncil\n     */\n    modifier onlyOwnerOrImpactMarketCouncil() {\n        require(\n            msg.sender == owner() || msg.sender == address(impactMarketCouncil),\n            \"CommunityAdmin: Not Owner Or ImpactMarketCouncil\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Used to initialize a new CommunityAdmin contract\n     *\n     * @param _communityImplementation    Address of the Community implementation\n     *                              used for deploying new communities\n     * @param _cUSD                 Address of the cUSD token\n     */\n    function initialize(ICommunity _communityImplementation, IERC20 _cUSD) external initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        communityImplementation = _communityImplementation;\n        cUSD = _cUSD;\n\n        communityProxyAdmin = new ProxyAdmin();\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 3;\n    }\n\n    /**\n     * @notice Returns the address of a community from communityList\n     *\n     * @param _index index of the community\n     * @return address of the community\n     */\n    function communityListAt(uint256 _index) external view override returns (address) {\n        return communityList.at(_index);\n    }\n\n    /**\n     * @notice Returns the number of communities\n     *\n     * @return uint256 number of communities\n     */\n    function communityListLength() external view override returns (uint256) {\n        return communityList.length();\n    }\n\n    /**\n     * @notice Returns the MIN_CLAIM_AMOUNT_RATIO_PRECISION\n     *\n     * @return uint256 number of communities\n     */\n    function minClaimAmountRatioPrecision() external pure override returns (uint256) {\n        return MIN_CLAIM_AMOUNT_RATIO_PRECISION;\n    }\n\n    /**\n     * @notice Returns if an address is the ambassador or entity of the community\n     *\n     * @return bool true if the address is an ambassador or entity of the community\n     */\n    function isAmbassadorOrEntityOfCommunity(address _community, address _ambassadorOrEntity)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return\n            ambassadors.isAmbassadorOf(_ambassadorOrEntity, _community) ||\n            ambassadors.isEntityOf(_ambassadorOrEntity, _community);\n    }\n\n    /**\n     * @notice Updates the address of the treasury\n     *\n     * @param _newTreasury address of the new treasury contract\n     */\n    function updateTreasury(ITreasury _newTreasury) external override onlyOwner {\n        emit TreasuryUpdated(address(treasury), address(_newTreasury));\n        treasury = _newTreasury;\n    }\n\n    /**\n     * @notice Updates the address of the the communityImplementation\n     *\n     * @param _newCommunityImplementation address of the new communityImplementation contract\n     */\n    function updateCommunityImplementation(ICommunity _newCommunityImplementation)\n        external\n        override\n        onlyOwner\n    {\n        emit CommunityImplementationUpdated(\n            address(communityImplementation),\n            address(_newCommunityImplementation)\n        );\n        communityImplementation = _newCommunityImplementation;\n    }\n\n    /** Updates the address of the backend wallet\n     *\n     * @param _newAuthorizedWalletAddress address of the new backend wallet\n     */\n    function updateAuthorizedWalletAddress(address _newAuthorizedWalletAddress)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        authorizedWalletAddress = _newAuthorizedWalletAddress;\n    }\n\n    /** Updates the value of the minClaimAmountRatio\n     *\n     * @param _newMinClaimAmountRatio value of the minClaimAmountRatio\n     *\n     * !!! be aware that this value will be divided by MIN_CLAIM_AMOUNT_RATIO_PRECISION\n     */\n    function updateMinClaimAmountRatio(uint256 _newMinClaimAmountRatio)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        require(\n            _newMinClaimAmountRatio >= MIN_CLAIM_AMOUNT_RATIO_PRECISION,\n            \"CommunityAdmin::updateMinClaimAmountRatio: Invalid minClaimAmountRatio\"\n        );\n        minClaimAmountRatio = _newMinClaimAmountRatio;\n    }\n\n    /** Updates the value of the treasurySafetyPercentage\n     *\n     * @param _newTreasurySafetyPercentage value of the treasurySafetyPercentage\n     *\n     */\n    function updateTreasurySafetyPercentage(uint256 _newTreasurySafetyPercentage)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        require(\n            _newTreasurySafetyPercentage > 0 && _newTreasurySafetyPercentage < 101,\n            \"CommunityAdmin::updateTreasurySafetyPercentage: Invalid treasurySafetyPercentage\"\n        );\n        treasurySafetyPercentage = _newTreasurySafetyPercentage;\n    }\n\n    /** Updates the value of the treasuryMinBalance\n     *\n     * @param _newTreasuryMinBalance value of the treasuryMinBalance\n     *\n     */\n    function updateTreasuryMinBalance(uint256 _newTreasuryMinBalance)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        treasuryMinBalance = _newTreasuryMinBalance;\n    }\n\n    /**\n     * @notice Set an existing ambassador to an existing community\n     *\n     * @param _ambassador address of the ambassador\n     * @param _community address of the community contract\n     */\n    function setCommunityToAmbassador(address _ambassador, ICommunity _community)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n    {\n        ambassadors.setCommunityToAmbassador(_ambassador, address(_community));\n    }\n\n    /**\n     * @notice Adds a new community\n     *\n     * @param _tokenAddress         address of the token used by the community\n     * @param _managers             addresses of the community managers\n     * @param _ambassador           address of the ambassador\n     * @param _originalClaimAmount  maximum base amount to be claim by the beneficiary\n     * @param _maxTotalClaim        limit that a beneficiary can claim at in total\n     * @param _decreaseStep         value decreased from maxTotalClaim for every beneficiary added\n     * @param _baseInterval         base interval to start claiming\n     * @param _incrementInterval    increment interval used in each claim\n     * @param _minTranche           minimum amount that the community will receive when requesting funds\n     * @param _maxTranche           maximum amount that the community will receive when requesting funds\n     * @param _maxBeneficiaries     maximum number of valid beneficiaries\n     */\n    function addCommunity(\n        address _tokenAddress,\n        address[] memory _managers,\n        address _ambassador,\n        uint256 _originalClaimAmount,\n        uint256 _maxTotalClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval,\n        uint256 _minTranche,\n        uint256 _maxTranche,\n        uint256 _maxBeneficiaries\n    ) external override onlyOwnerOrImpactMarketCouncil {\n        require(\n            _managers.length > 0,\n            \"CommunityAdmin::addCommunity: Community should have at least one manager\"\n        );\n\n        address _communityAddress = _deployCommunity(\n            _tokenAddress,\n            _managers,\n            _originalClaimAmount,\n            _maxTotalClaim,\n            _decreaseStep,\n            _baseInterval,\n            _incrementInterval,\n            _minTranche,\n            _maxTranche,\n            _maxBeneficiaries,\n            ICommunity(address(0))\n        );\n        require(_communityAddress != address(0), \"CommunityAdmin::addCommunity: NOT_VALID\");\n        communities[_communityAddress] = CommunityState.Valid;\n        communityList.add(_communityAddress);\n        ambassadors.setCommunityToAmbassador(_ambassador, address(_communityAddress));\n\n        emit CommunityAdded(\n            _communityAddress,\n            _managers,\n            _originalClaimAmount,\n            _maxTotalClaim,\n            _decreaseStep,\n            _baseInterval,\n            _incrementInterval,\n            _minTranche,\n            _maxTranche\n        );\n\n        transferToCommunity(ICommunity(_communityAddress), _minTranche);\n\n        if (cUSD.balanceOf(address(treasury)) >= DEFAULT_AMOUNT) {\n            treasury.transfer(cUSD, address(_managers[0]), DEFAULT_AMOUNT);\n        }\n    }\n\n    /**\n     * @notice Migrates a community by deploying a new contract.\n     *\n     * @param _managers address of the community managers\n     * @param _previousCommunity address of the community to be migrated\n     */\n    function migrateCommunity(address[] memory _managers, ICommunity _previousCommunity)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n        nonReentrant\n    {\n        require(\n            communities[address(_previousCommunity)] != CommunityState.Migrated,\n            \"CommunityAdmin::migrateCommunity: this community has been migrated\"\n        );\n\n        communities[address(_previousCommunity)] = CommunityState.Migrated;\n\n        IERC20 _previousCommunityToken = (_previousCommunity.getVersion() == 1)\n            ? _previousCommunity.cUSD()\n            : _previousCommunity.token();\n\n        uint256 _previousOriginalClaimAmount = (_previousCommunity.getVersion() >= 3)\n            ? _previousCommunity.originalClaimAmount()\n            : IPreviousCommunity(address(_previousCommunity)).claimAmount();\n\n        address newCommunityAddress = _deployCommunity(\n            address(_previousCommunityToken),\n            _managers,\n            _previousOriginalClaimAmount,\n            _previousCommunity.getInitialMaxClaim(),\n            _previousCommunity.decreaseStep(),\n            _previousCommunity.baseInterval(),\n            _previousCommunity.incrementInterval(),\n            _previousCommunity.minTranche(),\n            _previousCommunity.maxTranche(),\n            _previousCommunity.getVersion() > 1 ? _previousCommunity.maxBeneficiaries() : 0,\n            _previousCommunity\n        );\n\n        require(newCommunityAddress != address(0), \"CommunityAdmin::migrateCommunity: NOT_VALID\");\n\n        uint256 balance = _previousCommunityToken.balanceOf(address(_previousCommunity));\n        _previousCommunity.transfer(_previousCommunityToken, newCommunityAddress, balance);\n\n        communities[newCommunityAddress] = CommunityState.Valid;\n        communityList.add(newCommunityAddress);\n\n        emit CommunityMigrated(_managers, newCommunityAddress, address(_previousCommunity));\n    }\n\n    /**\n     * @notice Migrates a community by deploying a new contract.\n     *\n     * @param _community       address of the community to be split\n     * @param _numberOfCopies  the number of communities that will copy the data\n     * @param _ambassador address of the ambassador\n     * @param _managers address of the community managers\n     */\n    function splitCommunity(\n        ICommunity _community,\n        uint256 _numberOfCopies,\n        address _ambassador,\n        address[] memory _managers\n    ) external override onlyOwnerOrImpactMarketCouncil nonReentrant {\n        require(\n            communities[address(_community)] == CommunityState.Valid,\n            \"CommunityAdmin::splitCommunity: invalid community state\"\n        );\n\n        require(\n            _community.getVersion() >= 3,\n            \"CommunityAdmin::splitCommunity: invalid community version\"\n        );\n\n        address _newCommunityAddress;\n        while (_numberOfCopies > 0) {\n            --_numberOfCopies;\n\n            _newCommunityAddress = _deployCommunity(\n                address(_community.token()),\n                _managers,\n                _community.originalClaimAmount(),\n                _community.getInitialMaxClaim(),\n                _community.decreaseStep(),\n                _community.baseInterval(),\n                _community.incrementInterval(),\n                _community.minTranche(),\n                _community.maxTranche(),\n                _community.maxBeneficiaries(),\n                ICommunity(address(0))\n            );\n\n            require(\n                _newCommunityAddress != address(0),\n                \"CommunityAdmin::migrateCommunity: NOT_VALID\"\n            );\n\n            communities[_newCommunityAddress] = CommunityState.Valid;\n            communityList.add(_newCommunityAddress);\n\n            _community.addCopy(ICommunity(_newCommunityAddress));\n            ICommunity(_newCommunityAddress).copyCommunityDetails(_community);\n\n            ambassadors.setCommunityToAmbassador(_ambassador, _newCommunityAddress);\n\n            emit CommunityCopied(address(_community), _newCommunityAddress);\n        }\n    }\n\n    /**\n     * @notice Removes an existing community. All community funds are transferred to the treasury\n     *\n     * @param _community address of the community\n     */\n    function removeCommunity(ICommunity _community)\n        external\n        override\n        onlyOwnerOrImpactMarketCouncil\n        nonReentrant\n    {\n        require(\n            communities[address(_community)] == CommunityState.Valid,\n            \"CommunityAdmin::removeCommunity: this isn't a valid community\"\n        );\n        communities[address(_community)] = CommunityState.Removed;\n\n        ambassadors.removeCommunity(address(_community));\n\n        IERC20 _token = (_community.getVersion() == 1) ? _community.cUSD() : _community.token();\n\n        _community.transfer(_token, address(treasury), _token.balanceOf(address(_community)));\n        emit CommunityRemoved(address(_community));\n    }\n\n    /**\n     * @dev Funds an existing community if it hasn't enough funds\n     */\n    function fundCommunity() external override onlyCommunities returns (uint256) {\n        ICommunity _community = ICommunity(msg.sender);\n        IERC20 _token = (_community.getVersion() == 1) ? _community.cUSD() : _community.token();\n        uint256 _balance = _token.balanceOf(msg.sender);\n\n        uint256 _amount = calculateCommunityTrancheAmount(ICommunity(msg.sender));\n\n        if (_amount > 0) {\n            transferToCommunity(_community, _amount);\n        }\n\n        return _amount;\n    }\n\n    /**\n     * @dev Transfers community tokens from the treasury to a community\n     *\n     * @param _beneficiary   address of the beneficiary\n     * @param _amount        amount to be transferred from treasury to community\n     */\n    function transferToBeneficiary(\n        IERC20 _token,\n        address _beneficiary,\n        uint256 _amount\n    ) external override onlyCommunities nonReentrant {\n        treasury.transfer(_token, _beneficiary, _amount);\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from this contract to an address\n     *\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyOwner nonReentrant {\n        IERC20Upgradeable(address(_token)).safeTransfer(_to, _amount);\n\n        emit TransferERC20(address(_token), _to, _amount);\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from community to an address\n     *\n     * @param _community address of the community\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transferFromCommunity(\n        ICommunity _community,\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyOwner nonReentrant {\n        _community.transfer(_token, _to, _amount);\n    }\n\n    /** @notice Updates the beneficiary params of a community\n     *\n     * @param _community address of the community\n     * @param _originalClaimAmount  maximum base amount to be claim by the beneficiary\n     * @param _maxTotalClaim limit that a beneficiary can claim  in total\n     * @param _decreaseStep value decreased from maxTotalClaim each time a is beneficiary added\n     * @param _baseInterval base interval to start claiming\n     * @param _incrementInterval increment interval used in each claim\n     * @param _maxBeneficiaries maximum number of beneficiaries\n     */\n    function updateBeneficiaryParams(\n        ICommunity _community,\n        uint256 _originalClaimAmount,\n        uint256 _maxTotalClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval,\n        uint256 _maxBeneficiaries\n    ) external override onlyOwnerOrImpactMarketCouncil {\n        _community.updateBeneficiaryParams(\n            _originalClaimAmount,\n            _maxTotalClaim,\n            _decreaseStep,\n            _baseInterval,\n            _incrementInterval\n        );\n\n        _community.updateMaxBeneficiaries(_maxBeneficiaries);\n    }\n\n    /** @notice Updates params of a community\n     *\n     * @param _community address of the community\n     * @param _minTranche minimum amount that the community will receive when requesting funds\n     * @param _maxTranche maximum amount that the community will receive when requesting funds\n     */\n    function updateCommunityParams(\n        ICommunity _community,\n        uint256 _minTranche,\n        uint256 _maxTranche\n    ) external override onlyOwnerOrImpactMarketCouncil {\n        _community.updateCommunityParams(_minTranche, _maxTranche);\n    }\n\n    /** @notice Updates token address of a community\n     *\n     * @param _community      address of the community\n     * @param _newToken       new token address\n     * @param _exchangePath   path used by uniswap to exchange the current tokens to the new tokens\n     */\n    function updateCommunityToken(\n        ICommunity _community,\n        IERC20 _newToken,\n        bytes memory _exchangePath,\n        uint256 _originalClaimAmount,\n        uint256 _maxTotalClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval\n    ) external override onlyOwnerOrImpactMarketCouncil {\n        _community.updateToken(\n            _newToken,\n            _exchangePath,\n            _originalClaimAmount,\n            _maxTotalClaim,\n            _decreaseStep,\n            _baseInterval,\n            _incrementInterval\n        );\n    }\n\n    /**\n     * @notice Updates proxy implementation address of a community\n     * use this only for changing the implementation for one community\n     * for updating the implementation for (almost) all communities, just update the communityImplementation param\n     *\n     * @param _communityMiddleProxy address of the community\n     * @param _newCommunityImplementation address of new implementation contract\n     */\n    function updateProxyImplementation(\n        address _communityMiddleProxy,\n        address _newCommunityImplementation\n    ) external override onlyOwnerOrImpactMarketCouncil {\n        communityProxyAdmin.upgrade(\n            TransparentUpgradeableProxy(payable(_communityMiddleProxy)),\n            _newCommunityImplementation\n        );\n    }\n\n    /**\n     * @notice Updates proxy implementation address of impactMarket council\n     *\n     * @param _newImpactMarketCouncil address of new implementation contract\n     */\n    function updateImpactMarketCouncil(IImpactMarketCouncil _newImpactMarketCouncil)\n        external\n        override\n        onlyOwner\n    {\n        emit ImpactMarketCouncilUpdated(\n            address(impactMarketCouncil),\n            address(_newImpactMarketCouncil)\n        );\n        impactMarketCouncil = _newImpactMarketCouncil;\n    }\n\n    /**\n     * @notice Updates proxy implementation address of ambassadors\n     *\n     * @param _newAmbassadors address of new implementation contract\n     */\n    function updateAmbassadors(IAmbassadors _newAmbassadors) external override onlyOwner {\n        emit AmbassadorsUpdated(address(ambassadors), address(_newAmbassadors));\n        ambassadors = _newAmbassadors;\n    }\n\n    /**\n     * @notice Updates communityMiddleProxy address\n     *\n     * @param _newCommunityMiddleProxy address of new implementation contract\n     */\n    function updateCommunityMiddleProxy(address _newCommunityMiddleProxy)\n        external\n        override\n        onlyOwner\n    {\n        emit CommunityMiddleProxyUpdated(communityMiddleProxy, _newCommunityMiddleProxy);\n        communityMiddleProxy = _newCommunityMiddleProxy;\n    }\n\n    /**\n     * @notice Gets a community implementation address\n     *\n     * @param _communityProxyAddress  address of the community\n     */\n    function getCommunityProxyImplementation(address _communityProxyAddress)\n        external\n        view\n        override\n        returns (address)\n    {\n        return\n            communityProxyAdmin.getProxyImplementation(\n                TransparentUpgradeableProxy(payable(_communityProxyAddress))\n            );\n    }\n\n    /**\n     * @dev Transfers community tokens from the treasury to a community\n     *\n     * @param _community address of the community\n     * @param _amount amount of the transaction\n     */\n    function transferToCommunity(ICommunity _community, uint256 _amount) internal nonReentrant {\n        IERC20 _token = (_community.getVersion() == 1) ? _community.cUSD() : _community.token();\n\n        if (_token.balanceOf(address(treasury)) >= _amount) {\n            treasury.transfer(_token, address(_community), _amount);\n\n            emit CommunityFunded(address(_community), _amount);\n        }\n    }\n\n    /**\n     * @dev Internal implementation of deploying a new community\n     *\n     * @param _tokenAddress        Address of the token used by the community\n     * @param _managers addresses of the community managers\n     * @param _originalClaimAmount base amount to be claim by the beneficiary\n     * @param _maxTotalClaim limit that a beneficiary can claim at in total\n     * @param _decreaseStep value decreased from maxTotalClaim for every beneficiary added\n     * @param _baseInterval base interval to start claiming\n     * @param _incrementInterval increment interval used in each claim\n     * @param _minTranche minimum amount that the community will receive when requesting funds\n     * @param _maxTranche maximum amount that the community will receive when requesting funds\n     * @param _maxBeneficiaries maximum number of valid beneficiaries\n     * @param _previousCommunity address of the previous community. Used for migrating communities\n     */\n    function _deployCommunity(\n        address _tokenAddress,\n        address[] memory _managers,\n        uint256 _originalClaimAmount,\n        uint256 _maxTotalClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval,\n        uint256 _minTranche,\n        uint256 _maxTranche,\n        uint256 _maxBeneficiaries,\n        ICommunity _previousCommunity\n    ) internal returns (address) {\n        TransparentUpgradeableProxy _community = new TransparentUpgradeableProxy(\n            address(communityMiddleProxy),\n            address(communityProxyAdmin),\n            \"\"\n        );\n\n        ICommunity(address(_community)).initialize(\n            _tokenAddress,\n            _managers,\n            _originalClaimAmount,\n            _maxTotalClaim,\n            _decreaseStep,\n            _baseInterval,\n            _incrementInterval,\n            _minTranche,\n            _maxTranche,\n            _maxBeneficiaries,\n            _previousCommunity\n        );\n\n        return address(_community);\n    }\n\n    /** @dev Calculates the tranche amount of a community.\n     *\n     * @param _community      address of the community\n     * @return uint256        the value of the tranche amount\n     */\n    function calculateCommunityTrancheAmount(ICommunity _community)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        IERC20 _token = (_community.getVersion() == 1) ? _community.cUSD() : _community.token();\n        uint256 _communityBalance = _token.balanceOf(address(_community));\n        uint256 _minTranche = _community.minTranche();\n        uint256 _maxTranche = _community.maxTranche();\n\n        if (\n            _communityBalance >= _minTranche ||\n            block.number <= _community.lastFundRequest() + _community.baseInterval() ||\n            _token.balanceOf(address(treasury)) < treasuryMinBalance ||\n            _maxTranche == 0\n        ) {\n            return 0;\n        }\n\n        uint256 _validBeneficiaries = _community.validBeneficiaryCount();\n        uint256 _originalClaimAmount = (_community.getVersion() >= 3)\n            ? _community.originalClaimAmount()\n            : IPreviousCommunity(address(_community)).claimAmount();\n\n        uint256 _trancheAmount = _validBeneficiaries * _originalClaimAmount;\n\n        // no need to have a minTranche, considering that every claim triggers the request fund\n        //        if (_trancheAmount < _minTranche) {\n        //            _trancheAmount = _minTranche;\n        //        }\n\n        if (_trancheAmount > _maxTranche) {\n            _trancheAmount = _maxTranche;\n        }\n\n        uint256 _amount;\n        if (_trancheAmount > _communityBalance) {\n            _amount = _trancheAmount - _communityBalance;\n\n            uint256 _treasurySafetyBalance = (_token.balanceOf(address(treasury)) *\n                treasurySafetyPercentage) / 100;\n\n            if (_amount > _treasurySafetyBalance) {\n                _amount = _treasurySafetyBalance;\n            }\n        }\n\n        return _amount;\n    }\n}\n"
    },
    "contracts/community/interfaces/IPreviousCommunity.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IPreviousCommunity {\n    function getVersion() external pure returns(uint256);\n    function claimAmount() external view returns(uint256);\n    function cUSD() external view  returns(IERC20);\n}\n"
    },
    "contracts/community/interfaces/CommunityAdminStorageV3.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./CommunityAdminStorageV2.sol\";\n\n/**\n * @title Storage for CommunityAdmin\n * @notice For future upgrades, do not change CommunityAdminStorageV2. Create a new\n * contract which implements CommunityAdminStorageV2 and following the naming convention\n * CommunityAdminStorageVX.\n */\nabstract contract CommunityAdminStorageV3 is CommunityAdminStorageV2 {\n    address public override authorizedWalletAddress;\n    // when there aren't enough funds into treasury, we want to limit the beneficiary claimAmount\n    // the claim amount will be calculated based on the community funds and the number of beneficiary\n    // originalClaimAmount * MIN_CLAIM_AMOUNT_RATIO_PRECISION / minClaimAmountRatio <=  claimAmount <= originalClaimAmount\n    uint256 public override minClaimAmountRatio;\n    uint256 public override treasurySafetyPercentage;\n    uint256 public override treasuryMinBalance;\n}\n"
    },
    "contracts/community/interfaces/CommunityStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./ICommunity.sol\";\nimport \"./ICommunityAdmin.sol\";\n\n/**\n * @title Storage for Community\n * @notice For future upgrades, do not change CommunityStorageV1. Create a new\n * contract which implements CommunityStorageV1 and following the naming convention\n * CommunityStorageVX.\n */\nabstract contract CommunityStorageV1 is ICommunity {\n    bool public override locked;\n    uint256 public override originalClaimAmount; //the maximum amount that can be claimed by a beneficiary once\n    uint256 public override baseInterval;\n    uint256 public override incrementInterval;\n    uint256 public override maxTotalClaim; //the total amount that can be claimed by a beneficiary over time\n    uint256 public override validBeneficiaryCount;\n    uint256 public override treasuryFunds;\n    uint256 public override privateFunds;\n    uint256 public override decreaseStep;\n    uint256 public override minTranche;\n    uint256 public override maxTranche;\n    uint256 public override lastFundRequest;\n\n    ICommunity public override previousCommunity;\n    ICommunityAdmin public override communityAdmin;\n\n    mapping(address => Beneficiary) internal _beneficiaries;\n    EnumerableSet.AddressSet internal beneficiaryList;\n}\n"
    },
    "contracts/community/interfaces/CommunityStorageV2.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./CommunityStorageV1.sol\";\n\n/**\n * @title Storage for Community\n * @notice For future upgrades, do not change CommunityStorageV2. Create a new\n * contract which implements CommunityStorageV2 and following the naming convention\n * CommunityStorageVX.\n */\nabstract contract CommunityStorageV2 is CommunityStorageV1 {\n    IERC20 public _token;\n    uint256 public override maxBeneficiaries;\n}\n"
    },
    "contracts/community/interfaces/CommunityStorageV3.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./CommunityStorageV2.sol\";\n\n/**\n * @title Storage for Community\n * @notice For future upgrades, do not change CommunityStorageV3. Create a new\n * contract which implements CommunityStorageV3 and following the naming convention\n * CommunityStorageVX.\n */\nabstract contract CommunityStorageV3 is CommunityStorageV2 {\n    TokenUpdates[] public override tokenUpdates;\n    EnumerableSet.AddressSet internal _tokenList;\n    uint256 public override claimAmount;\n}\n"
    },
    "contracts/community/interfaces/CommunityStorageV4.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./CommunityStorageV3.sol\";\n\n/**\n * @title Storage for Community\n * @notice For future upgrades, do not change CommunityStorageV4. Create a new\n * contract which implements CommunityStorageV4 and following the naming convention\n * CommunityStorageVX.\n */\nabstract contract CommunityStorageV4 is CommunityStorageV3 {\n    ICommunity public override copyOf;\n    EnumerableSet.AddressSet internal _copies;\n}\n"
    },
    "contracts/community/CommunityImplementation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./interfaces/ICommunity.sol\";\nimport \"./interfaces/ICommunityAdmin.sol\";\nimport \"./interfaces/CommunityStorageV4.sol\";\n\n/**\n * @notice Welcome to the Community contract. For each community\n * there will be one proxy contract deployed by CommunityAdmin.\n * The implementation of the proxy is this contract. This enable\n * us to save tokens on the contract itself, and avoid the problems\n * of having everything in one single contract.\n *Each community has it's own members and and managers.\n */\ncontract CommunityImplementation is\n    Initializable,\n    AccessControlUpgradeable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    CommunityStorageV4\n{\n    using SafeERC20Upgradeable for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using ECDSA for bytes32;\n\n    bytes32 private constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n    uint256 private constant DEFAULT_AMOUNT = 1e16;\n    uint256 private constant MAX_TOKEN_LIST_LENGTH = 10;\n\n    /**\n     * @notice Triggered when a manager has been added\n     *\n     * @param manager           Address of the manager that triggered the event\n     *                          or address of the CommunityAdmin if it's first manager\n     * @param account           Address of the manager that has been added\n     */\n    event ManagerAdded(address indexed manager, address indexed account);\n\n    /**\n     * @notice Triggered when a manager has been removed\n     *\n     * @param manager           Address of the manager that triggered the event\n     * @param account           Address of the manager that has been removed\n     */\n    event ManagerRemoved(address indexed manager, address indexed account);\n\n    /**\n     * @notice Triggered when a beneficiary has been added\n     *\n     * @param manager           Address of the manager that triggered the event\n     * @param beneficiary       Address of the beneficiary that has been added\n     */\n    event BeneficiaryAdded(address indexed manager, address indexed beneficiary);\n\n    /**\n     * @notice Triggered when a beneficiary has been copied\n     *\n     * @param manager           Address of the manager that triggered the event\n     * @param beneficiary       Address of the beneficiary that has been added\n     */\n    event BeneficiaryCopied(address indexed manager, address indexed beneficiary);\n\n    /**\n     * @notice Triggered when a beneficiary has been locked\n     *\n     * @param manager           Address of the manager that triggered the event\n     * @param beneficiary       Address of the beneficiary that has been locked\n     */\n    event BeneficiaryLocked(address indexed manager, address indexed beneficiary);\n\n    /**\n     * @notice Triggered when a beneficiary has been unlocked\n     *\n     * @param manager           Address of the manager that triggered the event\n     * @param beneficiary       Address of the beneficiary that has been unlocked\n     */\n    event BeneficiaryUnlocked(address indexed manager, address indexed beneficiary);\n\n    /**\n     * @notice Triggered when a beneficiary has been removed\n     *\n     * @param manager           Address of the manager that triggered the event\n     * @param beneficiary       Address of the beneficiary that has been removed\n     */\n    event BeneficiaryRemoved(address indexed manager, address indexed beneficiary);\n\n    /**\n     * @notice Triggered when a beneficiary has claimed\n     *\n     * @param beneficiary       Address of the beneficiary that has claimed\n     * @param amount            Amount of the claim\n     */\n    event BeneficiaryClaim(address indexed beneficiary, uint256 amount);\n\n    /**\n     * @notice Triggered when a community has been locked\n     *\n     * @param manager           Address of the manager that triggered the event\n     */\n    event CommunityLocked(address indexed manager);\n\n    /**\n     * @notice Triggered when a community has been unlocked\n     *\n     * @param manager           Address of the manager that triggered the event\n     */\n    event CommunityUnlocked(address indexed manager);\n\n    /**\n     * @notice Triggered when a manager has requested funds for community\n     *\n     * @param manager           Address of the manager that triggered the event\n     */\n    event FundsRequested(address indexed manager);\n\n    /**\n     * @notice Triggered when someone has donated token\n     *\n     * @param donor             Address of the donor\n     * @param amount            Amount of the donation\n     */\n    event Donate(address indexed donor, uint256 amount);\n\n    /**\n     * @notice Triggered when a beneficiary from previous community has joined in the current community\n     *\n     * @param beneficiary       Address of the beneficiary\n     */\n    event BeneficiaryJoined(address indexed beneficiary);\n\n    /**\n     * @notice Triggered when two beneficiaries has been merged\n     *\n     * @param beneficiary1       Address of the first beneficiary\n     * @param beneficiary2       Address of the second beneficiary\n     */\n    event BeneficiaryAddressChanged(address indexed beneficiary1, address indexed beneficiary2);\n\n    /**\n     * @notice Triggered when beneficiary params has been updated\n     *\n     * @param oldOriginalClaimAmount    Old originalClaimAmount value\n     * @param oldMaxTotalClaim          Old maxTotalClaim value\n     * @param oldDecreaseStep           Old decreaseStep value\n     * @param oldBaseInterval           Old baseInterval value\n     * @param oldIncrementInterval      Old incrementInterval value\n     * @param newOriginalClaimAmount    New originalClaimAmount value\n     * @param newMaxTotalClaim          New maxTotalClaim value\n     * @param newDecreaseStep           New decreaseStep value\n     * @param newBaseInterval           New baseInterval value\n     * @param newIncrementInterval      New incrementInterval value\n     *\n     * For further information regarding each parameter, see\n     * *Community* smart contract initialize method.\n     */\n    event BeneficiaryParamsUpdated(\n        uint256 oldOriginalClaimAmount,\n        uint256 oldMaxTotalClaim,\n        uint256 oldDecreaseStep,\n        uint256 oldBaseInterval,\n        uint256 oldIncrementInterval,\n        uint256 newOriginalClaimAmount,\n        uint256 newMaxTotalClaim,\n        uint256 newDecreaseStep,\n        uint256 newBaseInterval,\n        uint256 newIncrementInterval\n    );\n\n    /**\n     * @notice Triggered when community params has been updated\n     *\n     * @param oldMinTranche        Old minTranche value\n     * @param oldMaxTranche        Old maxTranche value\n     * @param newMinTranche        New minTranche value\n     * @param newMaxTranche        New maxTranche value\n     *\n     * For further information regarding each parameter, see\n     * *Community* smart contract initialize method.\n     */\n    event CommunityParamsUpdated(\n        uint256 oldMinTranche,\n        uint256 oldMaxTranche,\n        uint256 newMinTranche,\n        uint256 newMaxTranche\n    );\n\n    /**\n     * @notice Triggered when communityAdmin has been updated\n     *\n     * @param oldCommunityAdmin   Old communityAdmin address\n     * @param newCommunityAdmin   New communityAdmin address\n     */\n    event CommunityAdminUpdated(\n        address indexed oldCommunityAdmin,\n        address indexed newCommunityAdmin\n    );\n\n    /**\n     * @notice Triggered when previousCommunity has been updated\n     *\n     * @param oldPreviousCommunity   Old previousCommunity address\n     * @param newPreviousCommunity   New previousCommunity address\n     */\n    event PreviousCommunityUpdated(\n        address indexed oldPreviousCommunity,\n        address indexed newPreviousCommunity\n    );\n\n    /**\n     * @notice Triggered when maxBeneficiaries has been updated\n     *\n     * @param oldMaxBeneficiaries   Old maxBeneficiaries value\n     * @param newMaxBeneficiaries   New maxBeneficiaries value\n     */\n    event MaxBeneficiariesUpdated(uint256 oldMaxBeneficiaries, uint256 newMaxBeneficiaries);\n\n    /**\n     * @notice Triggered when token address has been updated\n     *\n     * @param oldTokenAddress   Old token address\n     * @param newTokenAddress   New token address\n     */\n    event TokenUpdated(address indexed oldTokenAddress, address indexed newTokenAddress);\n\n    /**\n     * @notice Triggered when an amount of an ERC20 has been transferred from this contract to an address\n     *\n     * @param token               ERC20 token address\n     * @param to                  Address of the receiver\n     * @param amount              Amount of the transaction\n     */\n    event TransferERC20(address indexed token, address indexed to, uint256 amount);\n\n    /**\n     * @notice Triggered when claimAmount has been changed\n     *\n     * @param oldClaimAmount   Old claimAmount value\n     * @param newClaimAmount   New claimAmount value\n     */\n    event ClaimAmountUpdated(uint256 oldClaimAmount, uint256 newClaimAmount);\n\n    /**\n     * @notice Enforces sender to be a valid beneficiary\n     */\n    modifier onlyValidBeneficiary() {\n        require(\n            _beneficiaries[msg.sender].state == BeneficiaryState.Valid,\n            \"Community: NOT_VALID_BENEFICIARY\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Enforces sender to have manager role\n     */\n    modifier onlyManagers() {\n        require(hasRole(MANAGER_ROLE, msg.sender), \"Community: NOT_MANAGER\");\n        _;\n    }\n\n    /**\n     * @notice Enforces sender to be the community ambassador or entity ambassador responsible\n     */\n    modifier onlyAmbassadorOrEntity() {\n        require(\n            communityAdmin.isAmbassadorOrEntityOfCommunity(address(this), msg.sender),\n            \"Community: NOT_AMBASSADOR_OR_ENTITY\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Enforces sender to be the owner or community ambassador or entity ambassador responsible\n     */\n    modifier onlyOwnerOrAmbassadorOrEntity() {\n        require(\n            msg.sender == owner() ||\n                communityAdmin.isAmbassadorOrEntityOfCommunity(address(this), msg.sender),\n            \"Community: NOT_OWNER_OR_AMBASSADOR_OR_ENTITY\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not locked\n     *\n     * Requirements:\n     *\n     * - The contract must not be locked.\n     */\n    modifier whenNotLocked() {\n        require(!locked, \"Community: locked\");\n        _;\n    }\n\n    /**\n     * @notice Enforces sender to be a valid beneficiary\n     */\n    modifier onlyCommunityCopy() {\n        require(_copies.contains(msg.sender), \"Community: Invalid community copy\");\n        _;\n    }\n\n    /**\n     * @notice Used to initialize a new Community contract\n     *\n     * @param _tokenAddress        Address of the token used by the community\n     * @param _managers            Community's initial managers\n     *                             Will be able to add others\n     * @param _originalClaimAmount      Maximum base amount to be claim by the beneficiary\n     * @param _maxTotalClaim       Limit that a beneficiary can claim in total\n     * @param _decreaseStep        Value decreased from maxTotalClaim each time a beneficiary is added\n     * @param _baseInterval        Base interval to start claiming\n     * @param _incrementInterval   Increment interval used in each claim\n     * @param _minTranche          Minimum amount that the community will receive when requesting funds\n     * @param _maxTranche          Maximum amount that the community will receive when requesting funds\n     * @param _maxBeneficiaries    Maximum valid beneficiaries number\n     * @param _previousCommunity   Previous smart contract address of community\n     */\n    function initialize(\n        address _tokenAddress,\n        address[] memory _managers,\n        uint256 _originalClaimAmount,\n        uint256 _maxTotalClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval,\n        uint256 _minTranche,\n        uint256 _maxTranche,\n        uint256 _maxBeneficiaries,\n        ICommunity _previousCommunity\n    ) external override initializer {\n        require(\n            _baseInterval > _incrementInterval,\n            \"Community::initialize: baseInterval must be greater than incrementInterval\"\n        );\n\n        require(\n            _maxTotalClaim >= _originalClaimAmount,\n            \"Community::initialize: originalClaimAmount to big\"\n        );\n\n        require(\n            _minTranche <= _maxTranche,\n            \"Community::initialize: minTranche should not be greater than maxTranche\"\n        );\n\n        communityAdmin = ICommunityAdmin(msg.sender);\n\n        __AccessControl_init();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        _token = IERC20(_tokenAddress);\n        originalClaimAmount = _originalClaimAmount;\n        claimAmount = _originalClaimAmount;\n        baseInterval = _baseInterval;\n        incrementInterval = _incrementInterval;\n        maxTotalClaim = _maxTotalClaim;\n        minTranche = _minTranche;\n        maxTranche = _maxTranche;\n        previousCommunity = _previousCommunity;\n        decreaseStep = _decreaseStep;\n        maxBeneficiaries = _maxBeneficiaries;\n        locked = false;\n\n        transferOwnership(msg.sender);\n\n        // MANAGER_ROLE is the admin for the MANAGER_ROLE\n        // so every manager is able to add or remove other managers\n        _setRoleAdmin(MANAGER_ROLE, MANAGER_ROLE);\n\n        _setupRole(MANAGER_ROLE, msg.sender);\n        emit ManagerAdded(msg.sender, msg.sender);\n\n        uint256 _i;\n        uint256 _numberOfManagers = _managers.length;\n        for (; _i < _numberOfManagers; _i++) {\n            _addManager(_managers[_i]);\n        }\n\n        treasuryFunds += minTranche;\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 4;\n    }\n\n    /**\n     * @notice Returns the cUSD contract address\n     * todo: to be removed, use token() instead\n     */\n    function cUSD() public view override returns (IERC20) {\n        return address(_token) != address(0) ? _token : communityAdmin.cUSD();\n    }\n\n    /**\n     * @notice Returns the address of the token used by this community\n     */\n    function token() public view override returns (IERC20) {\n        return address(_token) != address(0) ? _token : communityAdmin.cUSD();\n    }\n\n    /**\n     * @notice Returns the length of the beneficiaryList\n     */\n    function beneficiaryListLength() external view override returns (uint256) {\n        return beneficiaryList.length();\n    }\n\n    /**\n     * @notice Returns an address from the beneficiaryList\n     *\n     * @param index_ index value\n     * @return address of the beneficiary\n     */\n    function beneficiaryListAt(uint256 index_) external view override returns (address) {\n        return beneficiaryList.at(index_);\n    }\n\n    /**\n     * @notice Returns the 0 address\n     * only used for backwards compatibility\n     */\n    function impactMarketAddress() public pure override returns (address) {\n        return address(0);\n    }\n\n    /**\n     * @notice Returns the data of a beneficiary\n     *\n     * @param _beneficiaryAddress    address of the beneficiary\n     * @return state                 the status of the beneficiary\n     * @return claims                how many times the beneficiary has claimed\n     * @return claimedAmount         the amount he has claimed\n     * @return lastClaim             block number of the last claim\n     */\n    function beneficiaries(address _beneficiaryAddress)\n        external\n        view\n        override\n        returns (\n            BeneficiaryState state,\n            uint256 claims,\n            uint256 claimedAmount,\n            uint256 lastClaim\n        )\n    {\n        Beneficiary storage _beneficiary = _beneficiaries[_beneficiaryAddress];\n\n        return (\n            _beneficiary.state,\n            _beneficiary.claims,\n            _calculateBeneficiaryClaimedAmount(_beneficiary, block.number),\n            _beneficiary.lastClaim\n        );\n    }\n\n    /**\n     * @notice Returns the beneficiary's claimed amounts for each token\n     *\n     * @param _beneficiaryAddress    address of the beneficiary\n     * @return claimedAmounts        a uint256 array with all claimed amounts in the same order as tokenList array\n     */\n    function beneficiaryClaimedAmounts(address _beneficiaryAddress)\n        external\n        view\n        override\n        returns (uint256[] memory claimedAmounts)\n    {\n        Beneficiary storage _beneficiary = _beneficiaries[_beneficiaryAddress];\n\n        uint256[] memory _claimedAmounts = new uint256[](_tokenList.length());\n        uint256 _length = _tokenList.length();\n\n        for (uint256 _index = 0; _index < _length; _index++) {\n            _claimedAmounts[_index] = _beneficiary.claimedAmounts[_tokenList.at(_index)];\n        }\n\n        if (_claimedAmounts.length == 0) {\n            _claimedAmounts = new uint256[](1);\n            _claimedAmounts[0] = _beneficiary.claimedAmount;\n        }\n\n        return _claimedAmounts;\n    }\n\n    /**\n     * @notice Returns the length of the tokenList\n     */\n    function tokenUpdatesLength() external view override returns (uint256) {\n        return tokenUpdates.length;\n    }\n\n    //    function tokenList() external view override returns (address[] memory) {\n    //        uint256 _length = _tokenList.length();\n    //        address[] memory _tokenListArray = new address[](_length);\n    //\n    //        for (uint256 _index = 0; _index < _length; _index++) {\n    //            _tokenListArray[_index] = _tokenList.at(_index);\n    //        }\n    //\n    //        if (_tokenListArray.length == 0) {\n    //            _tokenListArray = new address[](1);\n    //            _tokenListArray[0] = address(token());\n    //        }\n    //\n    //        return _tokenListArray;\n    //    }\n\n    function tokenList() external view override returns (address[] memory) {\n        if (_tokenList.length() == 0) {\n            address[] memory _tokenListArray = new address[](1);\n            _tokenListArray[0] = address(token());\n            return _tokenListArray;\n        }\n\n        return _tokenList.values();\n    }\n\n    /**\n     * @notice Returns the list with all communities copies\n     */\n    function copies() external view override returns (address[] memory) {\n        return _copies.values();\n    }\n\n    /**\n     * @notice Returns the amount that can be claimed by a beneficiary in total\n     * todo: remove it after the frontend is updated to the new function: maxTotalClaim()\n     */\n    function maxClaim() external view override returns (uint256) {\n        return maxTotalClaim;\n    }\n\n    function isSelfFunding() public view override returns (bool) {\n        return maxTranche == 0;\n    }\n\n    /** Updates the address of the communityAdmin\n     *\n     * @param _newCommunityAdmin address of the new communityAdmin\n     */\n    function updateCommunityAdmin(ICommunityAdmin _newCommunityAdmin) external override onlyOwner {\n        emit CommunityAdminUpdated(address(communityAdmin), address(_newCommunityAdmin));\n        communityAdmin = _newCommunityAdmin;\n\n        _addManager(address(communityAdmin));\n    }\n\n    /** Updates the address of the previousCommunity\n     *\n     * @param _newPreviousCommunity address of the new previousCommunity\n     */\n    function updatePreviousCommunity(ICommunity _newPreviousCommunity) external override onlyOwner {\n        emit PreviousCommunityUpdated(address(previousCommunity), address(_newPreviousCommunity));\n        previousCommunity = _newPreviousCommunity;\n    }\n\n    /** Updates beneficiary params\n     *\n     * @param _originalClaimAmount maximum base amount to be claim by the beneficiary\n     * @param _maxTotalClaim limit that a beneficiary can claim  in total\n     * @param _decreaseStep value decreased from maxTotalClaim each time a is beneficiary added\n     * @param _baseInterval base interval to start claiming\n     * @param _incrementInterval increment interval used in each claim\n     *\n     * @notice be aware that max claim will not be the same with the value you've provided\n     *             maxTotalClaim = _maxTotalClaim - validBeneficiaryCount * _decreaseStep\n     */\n    function updateBeneficiaryParams(\n        uint256 _originalClaimAmount,\n        uint256 _maxTotalClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval\n    ) public override onlyOwner {\n        require(\n            _baseInterval > _incrementInterval,\n            \"Community::updateBeneficiaryParams: baseInterval must be greater than incrementInterval\"\n        );\n        require(\n            _maxTotalClaim >= _originalClaimAmount + validBeneficiaryCount * _decreaseStep,\n            \"Community::updateBeneficiaryParams: originalClaimAmount too big\"\n        );\n\n        emit BeneficiaryParamsUpdated(\n            originalClaimAmount,\n            maxTotalClaim,\n            decreaseStep,\n            baseInterval,\n            incrementInterval,\n            _originalClaimAmount,\n            _maxTotalClaim,\n            _decreaseStep,\n            _baseInterval,\n            _incrementInterval\n        );\n\n        originalClaimAmount = _originalClaimAmount;\n        maxTotalClaim = _maxTotalClaim - validBeneficiaryCount * _decreaseStep;\n        decreaseStep = _decreaseStep;\n        baseInterval = _baseInterval;\n        incrementInterval = _incrementInterval;\n\n        _updateClaimAmount();\n    }\n\n    /** @notice Updates params of a community\n     *\n     * @param _minTranche minimum amount that the community will receive when requesting funds\n     * @param _maxTranche maximum amount that the community will receive when requesting funds\n     */\n    function updateCommunityParams(uint256 _minTranche, uint256 _maxTranche)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            _minTranche <= _maxTranche,\n            \"Community::updateCommunityParams: minTranche should not be greater than maxTranche\"\n        );\n\n        emit CommunityParamsUpdated(minTranche, maxTranche, _minTranche, _maxTranche);\n\n        minTranche = _minTranche;\n        maxTranche = _maxTranche;\n    }\n\n    /** @notice Updates maxBeneficiaries\n     *\n     * @param _newMaxBeneficiaries new _maxBeneficiaries value\n     */\n    function updateMaxBeneficiaries(uint256 _newMaxBeneficiaries)\n        external\n        override\n        onlyOwnerOrAmbassadorOrEntity\n    {\n        emit MaxBeneficiariesUpdated(maxBeneficiaries, _newMaxBeneficiaries);\n        maxBeneficiaries = _newMaxBeneficiaries;\n    }\n\n    /** @notice Updates token address\n     *   !!!!!! you must be careful about _maxTotalClaim value. This value determines all beneficiaries claimedAmounts\n     */\n    function updateToken(\n        IERC20 _newToken,\n        bytes calldata _exchangePath,\n        uint256 _originalClaimAmount,\n        uint256 _maxTotalClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval\n    ) external override onlyOwner {\n        ITreasury _treasury = communityAdmin.treasury();\n\n        require(\n            tokenUpdates.length < MAX_TOKEN_LIST_LENGTH,\n            \"Community::updateToken: Token list length too big\"\n        );\n\n        require(\n            _newToken != token(),\n            \"Community::updateToken: New token cannot be the same as the current token\"\n        );\n\n        require(\n            _newToken == communityAdmin.cUSD() || _treasury.isToken(address(_newToken)),\n            \"Community::updateToken: Invalid token\"\n        );\n\n        //for communities deployed before this functionality, we need to add the current token before changing it\n        if (tokenUpdates.length == 0) {\n            tokenUpdates.push(TokenUpdates(address(token()), 1e18, 0));\n            _tokenList.add(address(token()));\n        }\n\n        uint256 _conversionRatio = (1e18 * _maxTotalClaim) / getInitialMaxTotalClaim();\n\n        tokenUpdates.push(TokenUpdates(address(_newToken), _conversionRatio, block.number));\n        _tokenList.add(address(_newToken));\n\n        uint256 _balance = token().balanceOf(address(this));\n\n        if (_balance > 0) {\n            IUniswapRouter02 _uniswapRouter = _treasury.lpSwap().uniswapRouter();\n\n            token().approve(address(_uniswapRouter), _balance);\n\n            IUniswapRouter02.ExactInputParams memory params = IUniswapRouter02.ExactInputParams({\n                path: _exchangePath,\n                recipient: address(this),\n                amountIn: _balance,\n                amountOutMinimum: 0\n            });\n\n            // Executes the swap.\n            uint256 amountOut = _uniswapRouter.exactInput(params);\n        }\n\n        emit TokenUpdated(address(_token), address(_newToken));\n        _token = _newToken;\n\n        updateBeneficiaryParams(\n            _originalClaimAmount,\n            _maxTotalClaim,\n            _decreaseStep,\n            _baseInterval,\n            _incrementInterval\n        );\n    }\n\n    /**\n     * @notice Adds a new copy of this community\n     *\n     * @param _copy  address of the 'child' community\n     */\n    function addCopy(ICommunity _copy) external override onlyOwner {\n        _copies.add(address(_copy));\n    }\n\n    /**\n     * @notice Copies the original community details that haven't been copied in the initialize method\n     *  !!used only by communityAdmin.copyCommunity method\n     *\n     * @param _originalCommunity  address of the 'parent' community\n     */\n    function copyCommunityDetails(ICommunity _originalCommunity) external override onlyOwner {\n        copyOf = _originalCommunity;\n\n        uint256 _index;\n\n        //copy tokens\n        uint256 _tokenUpdatesLength = copyOf.tokenUpdatesLength();\n\n        uint256 _initialCommunityCopyTokensLength = tokenUpdates.length;\n        for (_index = 0; _index < _initialCommunityCopyTokensLength; _index++) {\n            tokenUpdates.pop();\n        }\n\n        address _tokenAddress;\n        uint256 _ratio;\n        uint256 _startBlock;\n        for (_index = 0; _index < _tokenUpdatesLength; _index++) {\n            (_tokenAddress, _ratio, _startBlock) = copyOf.tokenUpdates(_index);\n            tokenUpdates.push(TokenUpdates(_tokenAddress, _ratio, _startBlock));\n        }\n\n        //        copy tokenList\n        uint256 _initialCommunityCopyTokenListLength = _tokenList.length();\n\n        while (_initialCommunityCopyTokenListLength > 0) {\n            _tokenList.remove(_tokenList.at(0));\n            --_initialCommunityCopyTokenListLength;\n        }\n\n        address[] memory _tokenListToCopy = copyOf.tokenList();\n        uint256 _tokenListLength = _tokenListToCopy.length;\n\n        for (_index = 0; _index < _tokenListLength; _index++) {\n            _tokenList.add(_tokenListToCopy[_index]);\n        }\n\n        treasuryFunds = 0;\n    }\n\n    /**\n     * @notice Adds a new manager\n     *\n     * @param _account address of the manager to be added\n     */\n    function addManager(address _account) public override onlyAmbassadorOrEntity {\n        _addManager(_account);\n    }\n\n    /**\n     * @notice Remove an existing manager\n     *\n     * @param _account address of the manager to be removed\n     */\n    function removeManager(address _account) external override onlyAmbassadorOrEntity {\n        require(\n            hasRole(MANAGER_ROLE, _account),\n            \"Community::removeManager: This account doesn't have manager role\"\n        );\n        require(\n            _account != address(communityAdmin),\n            \"Community::removeManager: You are not allow to remove communityAdmin\"\n        );\n        super._revokeRole(MANAGER_ROLE, _account);\n        emit ManagerRemoved(msg.sender, _account);\n    }\n\n    /**\n     * @notice Enforces managers to use addManager method\n     */\n    function grantRole(bytes32, address) public pure override {\n        require(false, \"Community::grantRole: You are not allow to use this method\");\n    }\n\n    /**\n     * @notice Enforces managers to use removeManager method\n     */\n    function revokeRole(bytes32, address) public pure override {\n        require(false, \"Community::revokeRole: You are not allow to use this method\");\n    }\n\n    /**\n     * @notice Adds a new beneficiary\n     *\n     * @param _beneficiaryAddress address of the beneficiary to be added\n     */\n    function addBeneficiary(address _beneficiaryAddress)\n        external\n        override\n        whenNotLocked\n        onlyManagers\n        nonReentrant\n    {\n        _addBeneficiary(_beneficiaryAddress);\n\n        emit BeneficiaryAdded(msg.sender, _beneficiaryAddress);\n    }\n\n    /**\n     * @notice Adds new beneficiaries\n     *\n     * @param _beneficiaryAddresses addresses of the beneficiaries to be added\n     */\n    function addBeneficiaries(address[] memory _beneficiaryAddresses)\n        external\n        override\n        whenNotLocked\n        onlyManagers\n        nonReentrant\n    {\n        _addBeneficiaries(_beneficiaryAddresses);\n    }\n\n    /**\n     * @notice Adds new beneficiaries using a manager signature\n     *\n     * @param _beneficiaryAddresses addresses of the beneficiaries to be added\n     * @param _expirationTimestamp  timestamp when the signature will expire/expired\n     * @param _signature            the signature of a manager\n     */\n    function addBeneficiariesUsingSignature(\n        address[] memory _beneficiaryAddresses,\n        uint256 _expirationTimestamp,\n        bytes calldata _signature\n    ) external override whenNotLocked nonReentrant {\n        _checkManagerSignature(_expirationTimestamp, _signature);\n\n        _addBeneficiaries(_beneficiaryAddresses);\n    }\n\n    /**\n     * @notice Copies beneficiaries from the original community\n     *\n     * @param _beneficiaryAddresses addresses of the beneficiaries to be copied\n     */\n    function copyBeneficiaries(address[] memory _beneficiaryAddresses)\n        external\n        override\n        whenNotLocked\n        onlyManagers\n        nonReentrant\n    {\n        require(\n            address(copyOf) != address(0),\n            \"Community::copyBeneficiaries: Invalid parent community\"\n        );\n        _copyBeneficiaries(_beneficiaryAddresses);\n    }\n\n    /**\n     * @notice Sets a beneficiary's state\n     *\n     * @param _beneficiaryAddress address of the beneficiary\n     * @param _state  beneficiary's state\n     */\n    function setBeneficiaryState(address _beneficiaryAddress, BeneficiaryState _state)\n        external\n        override\n        whenNotLocked\n        onlyCommunityCopy\n        nonReentrant\n    {\n        Beneficiary storage _beneficiary = _beneficiaries[_beneficiaryAddress];\n\n        _changeBeneficiaryState(_beneficiary, _state);\n    }\n\n    /**\n     * @notice Locks a valid beneficiary\n     *\n     * @param _beneficiaryAddress address of the beneficiary to be locked\n     */\n    function lockBeneficiary(address _beneficiaryAddress)\n        external\n        override\n        whenNotLocked\n        onlyManagers\n    {\n        _lockBeneficiary(_beneficiaryAddress);\n    }\n\n    /**\n     * @notice Locks a list of beneficiaries\n     *\n     * @param _beneficiaryAddresses       addresses of the beneficiaries to be locked\n     */\n    function lockBeneficiaries(address[] memory _beneficiaryAddresses)\n        external\n        override\n        whenNotLocked\n        onlyManagers\n    {\n        _lockBeneficiaries(_beneficiaryAddresses);\n    }\n\n    /**\n     * @notice Locks a list of beneficiaries using a manager signature\n     *\n     * @param _beneficiaryAddresses addresses of the beneficiaries to be locked\n     * @param _expirationTimestamp  timestamp when the signature will expire/expired\n     * @param _signature            the signature of a manager\n     */\n    function lockBeneficiariesUsingSignature(\n        address[] memory _beneficiaryAddresses,\n        uint256 _expirationTimestamp,\n        bytes calldata _signature\n    ) external override whenNotLocked {\n        _checkManagerSignature(_expirationTimestamp, _signature);\n        _lockBeneficiaries(_beneficiaryAddresses);\n    }\n\n    /**\n     * @notice  Unlocks a locked beneficiary\n     *\n     * @param _beneficiaryAddress address of the beneficiary to be unlocked\n     */\n    function unlockBeneficiary(address _beneficiaryAddress)\n        external\n        override\n        whenNotLocked\n        onlyManagers\n    {\n        _unlockBeneficiary(_beneficiaryAddress);\n    }\n\n    /**\n     * @notice Unlocks a list of beneficiaries\n     *\n     * @param _beneficiaryAddresses       addresses of the beneficiaries to be unlocked\n     */\n    function unlockBeneficiaries(address[] memory _beneficiaryAddresses)\n        external\n        override\n        whenNotLocked\n        onlyManagers\n    {\n        _unlockBeneficiaries(_beneficiaryAddresses);\n    }\n\n    /**\n     * @notice Unlocks a list of beneficiaries using a manager signature\n     *\n     * @param _beneficiaryAddresses addresses of the beneficiaries to be unlocked\n     * @param _expirationTimestamp  timestamp when the signature will expire/expired\n     * @param _signature            the signature of a manager\n     */\n    function unlockBeneficiariesUsingSignature(\n        address[] memory _beneficiaryAddresses,\n        uint256 _expirationTimestamp,\n        bytes calldata _signature\n    ) external override whenNotLocked {\n        _checkManagerSignature(_expirationTimestamp, _signature);\n        _unlockBeneficiaries(_beneficiaryAddresses);\n    }\n\n    /**\n     * @notice Remove an existing beneficiary\n     *\n     * @param _beneficiaryAddress address of the beneficiary to be removed\n     */\n    function removeBeneficiary(address _beneficiaryAddress) external override onlyManagers {\n        _removeBeneficiary(_beneficiaryAddress);\n    }\n\n    /**\n     * @notice Removes a list of beneficiaries\n     *\n     * @param _beneficiaryAddresses       addresses of the beneficiaries to be removed\n     */\n    function removeBeneficiaries(address[] memory _beneficiaryAddresses)\n        external\n        override\n        onlyManagers\n    {\n        _removeBeneficiaries(_beneficiaryAddresses);\n    }\n\n    /**\n     * @notice Removes a list of beneficiaries using a manager signature\n     *\n     * @param _beneficiaryAddresses addresses of the beneficiaries to be removed\n     * @param _expirationTimestamp  timestamp when the signature will expire/expired\n     * @param _signature            the signature of a manager\n     */\n    function removeBeneficiariesUsingSignature(\n        address[] memory _beneficiaryAddresses,\n        uint256 _expirationTimestamp,\n        bytes calldata _signature\n    ) external override {\n        _checkManagerSignature(_expirationTimestamp, _signature);\n        _removeBeneficiaries(_beneficiaryAddresses);\n    }\n\n    /**\n     * @notice Allows a beneficiary from the previousCommunity to join in this community\n     */\n    function beneficiaryJoinFromMigrated(address _beneficiaryAddress) external override {\n        // no need to check if it's a beneficiary, as the state is copied\n        Beneficiary storage _beneficiary = _beneficiaries[_beneficiaryAddress];\n\n        require(\n            _beneficiary.state == BeneficiaryState.NONE,\n            \"Community::beneficiaryJoinFromMigrated: Beneficiary exists\"\n        );\n\n        (\n            BeneficiaryState _oldBeneficiaryState,\n            uint256 _oldBeneficiaryClaims,\n            uint256 _oldBeneficiaryClaimedAmount,\n            uint256 _oldBeneficiaryLastClaim\n        ) = previousCommunity.beneficiaries(_beneficiaryAddress);\n\n        _changeBeneficiaryState(_beneficiary, _oldBeneficiaryState);\n        _beneficiary.claims = _oldBeneficiaryClaims;\n        _beneficiary.lastClaim = _oldBeneficiaryLastClaim;\n        _beneficiary.claimedAmount = _oldBeneficiaryClaimedAmount;\n\n        beneficiaryList.add(_beneficiaryAddress);\n\n        emit BeneficiaryJoined(_beneficiaryAddress);\n    }\n\n    /**\n     * @notice Changes the address of a beneficiary\n     * this action adds claim details from both addresses\n     *\n     * @dev used by managers\n     */\n    function changeBeneficiaryAddressByManager(\n        address _oldBeneficiaryAddress,\n        address _newBeneficiaryAddress\n    ) external override onlyManagers {\n        _changeBeneficiaryAddress(_oldBeneficiaryAddress, _newBeneficiaryAddress);\n    }\n\n    /**\n     * @notice Allows a beneficiary to use another address\n     * this action adds claim details from both addresses\n     *\n     * @dev used by beneficiaries\n     */\n    function changeBeneficiaryAddress(address _newBeneficiaryAddress) external override {\n        require(\n            _beneficiaries[_newBeneficiaryAddress].state == BeneficiaryState.NONE,\n            \"Community::changeBeneficiaryAddress: Invalid beneficiary\"\n        );\n\n        _changeBeneficiaryAddress(msg.sender, _newBeneficiaryAddress);\n    }\n\n    /**\n     * @dev Transfers tokens to a valid beneficiary\n     */\n    function claim() external override whenNotLocked onlyValidBeneficiary nonReentrant {\n        _requestFunds();\n\n        Beneficiary storage _beneficiary = _beneficiaries[msg.sender];\n\n        uint256 _totalClaimedAmount = _calculateBeneficiaryClaimedAmount(\n            _beneficiary,\n            block.number\n        );\n\n        require(claimCooldown(msg.sender) <= block.number, \"Community::claim: NOT_YET\");\n        require(\n            _totalClaimedAmount < maxTotalClaim,\n            \"Community::claim: Already claimed everything\"\n        );\n\n        uint256 _claimAmount = claimAmount > 0 ? claimAmount : originalClaimAmount;\n\n        uint256 _toClaim = _claimAmount <= maxTotalClaim - _totalClaimedAmount\n            ? _claimAmount\n            : maxTotalClaim - _totalClaimedAmount;\n\n        //this is necessary for communities with version < 3\n        //and for beneficiaries that haven't claimed after updating to v3\n        if (tokenUpdates.length > 1 && _beneficiary.lastClaim < tokenUpdates[1].startBlock) {\n            _beneficiary.claimedAmounts[tokenUpdates[0].tokenAddress] = _beneficiary.claimedAmount;\n        }\n\n        _beneficiary.claimedAmount = _totalClaimedAmount + _toClaim;\n        _beneficiary.claims++;\n        _beneficiary.lastClaim = block.number;\n\n        if (tokenUpdates.length > 1) {\n            _beneficiary.claimedAmounts[address(token())] += _toClaim;\n        }\n\n        IERC20Upgradeable(address(token())).safeTransfer(msg.sender, _toClaim);\n        emit BeneficiaryClaim(msg.sender, _toClaim);\n    }\n\n    /**\n     * @notice Returns the number of blocks that a beneficiary have to wait between claims\n     *\n     * @param _beneficiaryAddress address of the beneficiary\n     * @return uint256 number of blocks for the lastInterval\n     */\n    function lastInterval(address _beneficiaryAddress) public view override returns (uint256) {\n        Beneficiary storage _beneficiary = _beneficiaries[_beneficiaryAddress];\n        if (_beneficiary.claims == 0) {\n            return 0;\n        }\n        return baseInterval + (_beneficiary.claims - 1) * incrementInterval;\n    }\n\n    /**\n     * @notice Returns the block number when a beneficiary can claim again\n     *\n     * @param _beneficiaryAddress address of the beneficiary\n     * @return uint256 number of block when the beneficiary can claim\n     */\n    function claimCooldown(address _beneficiaryAddress) public view override returns (uint256) {\n        return _beneficiaries[_beneficiaryAddress].lastClaim + lastInterval(_beneficiaryAddress);\n    }\n\n    /**\n     * @notice Locks the community\n     */\n    function lock() external override onlyAmbassadorOrEntity {\n        locked = true;\n        emit CommunityLocked(msg.sender);\n    }\n\n    /**\n     * @notice Unlocks the community\n     */\n    function unlock() external override onlyAmbassadorOrEntity {\n        locked = false;\n        emit CommunityUnlocked(msg.sender);\n    }\n\n    /**\n     * @notice Requests treasury funds from the communityAdmin\n     */\n    function requestFunds() external override whenNotLocked onlyManagers {\n        _requestFunds();\n    }\n\n    /**\n     * @notice Transfers tokens from donor to this community\n     * Used by donationToCommunity method from DonationMiner contract\n     *\n     * @param _sender address of the sender\n     * @param _amount amount to be donated\n     */\n    function donate(address _sender, uint256 _amount) external override nonReentrant {\n        IERC20Upgradeable(address(token())).safeTransferFrom(_sender, address(this), _amount);\n        privateFunds += _amount;\n\n        _updateClaimAmount();\n\n        emit Donate(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from this contract to an address\n     *\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyOwner nonReentrant {\n        IERC20Upgradeable(address(_token)).safeTransfer(_to, _amount);\n\n        if (address(_token) == address(token())) {\n            _updateClaimAmount();\n        }\n\n        emit TransferERC20(address(_token), _to, _amount);\n    }\n\n    /**\n     * @notice Returns the initial maxTotalClaim\n     * todo: do be deleted after updating all communities to v3\n     */\n    function getInitialMaxClaim() public view override returns (uint256) {\n        return maxTotalClaim + validBeneficiaryCount * decreaseStep;\n    }\n\n    /**\n     * @notice Returns the initial maxTotalClaim\n     */\n    function getInitialMaxTotalClaim() public view returns (uint256) {\n        return maxTotalClaim + validBeneficiaryCount * decreaseStep;\n    }\n\n    /**\n     * @notice Adds a new beneficiary\n     *\n     * @param _beneficiaryAddress address of the beneficiary to be added\n     */\n    function _addBeneficiary(address _beneficiaryAddress) internal {\n        Beneficiary storage _beneficiary = _beneficiaries[_beneficiaryAddress];\n\n        if (_beneficiary.state != BeneficiaryState.NONE) {\n            return;\n        }\n\n        if (address(copyOf) != address(0)) {\n            BeneficiaryState _originalState;\n            (_originalState, , , ) = copyOf.beneficiaries(_beneficiaryAddress);\n            require(\n                _originalState == BeneficiaryState.NONE,\n                \"Community::addBeneficiary: Invalid beneficiary state\"\n            );\n        }\n\n        _changeBeneficiaryState(_beneficiary, BeneficiaryState.Valid);\n        _beneficiary.lastClaim = block.number;\n\n        beneficiaryList.add(_beneficiaryAddress);\n\n        // send default amount when adding a new beneficiary\n        if (token().balanceOf(address(this)) < DEFAULT_AMOUNT) {\n            communityAdmin.transferToBeneficiary(token(), _beneficiaryAddress, DEFAULT_AMOUNT);\n            treasuryFunds += DEFAULT_AMOUNT;\n        } else {\n            token().safeTransfer(_beneficiaryAddress, DEFAULT_AMOUNT);\n        }\n    }\n\n    /**\n     * @notice Adds new beneficiaries\n     *\n     * @param _beneficiaryAddresses addresses of beneficiaries to be added\n     */\n    function _addBeneficiaries(address[] memory _beneficiaryAddresses) internal {\n        uint256 _index;\n        uint256 _numberOfBeneficiaries = _beneficiaryAddresses.length;\n        for (; _index < _numberOfBeneficiaries; _index++) {\n            _addBeneficiary(_beneficiaryAddresses[_index]);\n            emit BeneficiaryAdded(msg.sender, _beneficiaryAddresses[_index]);\n        }\n    }\n\n    /**\n     * @notice Copy a beneficiary\n     *\n     * @param _beneficiaryAddress address of the beneficiary to be copied\n     */\n    function _copyBeneficiary(address _beneficiaryAddress) internal {\n        Beneficiary storage _beneficiary = _beneficiaries[_beneficiaryAddress];\n\n        if (_beneficiary.state != BeneficiaryState.NONE) {\n            return;\n        }\n\n        BeneficiaryState _originalState;\n        uint256 _originalClaims;\n        uint256 _originalClaimedAmount;\n        uint256 _originalLastClaim;\n        (_originalState, _originalClaims, _originalClaimedAmount, _originalLastClaim) = copyOf\n            .beneficiaries(_beneficiaryAddress);\n\n        require(\n            _originalState != BeneficiaryState.Copied,\n            \"Community::copyBeneficiary: Beneficiary already copied\"\n        );\n\n        _changeBeneficiaryState(_beneficiary, _originalState);\n        _beneficiary.claims = _originalClaims;\n        _beneficiary.claimedAmount = _originalClaimedAmount;\n        _beneficiary.lastClaim = _originalLastClaim;\n\n        uint256[] memory _originalClaimedAmounts = copyOf.beneficiaryClaimedAmounts(\n            _beneficiaryAddress\n        );\n        address[] memory _originalTokens = copyOf.tokenList();\n        uint256 _originalLength = _originalClaimedAmounts.length;\n\n        for (uint256 _index = 0; _index < _originalLength; _index++) {\n            if (_tokenList.contains(_originalTokens[_index])) {\n                _beneficiary.claimedAmounts[_originalTokens[_index]] = _originalClaimedAmounts[\n                    _index\n                ];\n            }\n        }\n\n        copyOf.setBeneficiaryState(_beneficiaryAddress, BeneficiaryState.Copied);\n\n        beneficiaryList.add(_beneficiaryAddress);\n\n        emit BeneficiaryCopied(msg.sender, _beneficiaryAddress);\n    }\n\n    /**\n     * @notice Copies beneficiaries\n     *\n     * @param _beneficiaryAddresses addresses of beneficiaries to be copied\n     */\n    function _copyBeneficiaries(address[] memory _beneficiaryAddresses) internal {\n        uint256 _index;\n        uint256 _numberOfBeneficiaries = _beneficiaryAddresses.length;\n        for (; _index < _numberOfBeneficiaries; _index++) {\n            _copyBeneficiary(_beneficiaryAddresses[_index]);\n        }\n    }\n\n    /**\n     * @notice Locks beneficiary\n     *\n     * @param _beneficiaryAddress address of beneficiary to be locked\n     */\n    function _lockBeneficiary(address _beneficiaryAddress) internal {\n        Beneficiary storage _beneficiary = _beneficiaries[_beneficiaryAddress];\n\n        if (_beneficiary.state == BeneficiaryState.Valid) {\n            _changeBeneficiaryState(_beneficiary, BeneficiaryState.Locked);\n            emit BeneficiaryLocked(msg.sender, _beneficiaryAddress);\n        }\n    }\n\n    /**\n     * @notice Locks beneficiaries\n     *\n     * @param _beneficiaryAddresses addresses of beneficiaries to be locked\n     */\n    function _lockBeneficiaries(address[] memory _beneficiaryAddresses) internal {\n        uint256 _index;\n        uint256 _numberOfBeneficiaries = _beneficiaryAddresses.length;\n\n        for (; _index < _numberOfBeneficiaries; _index++) {\n            _lockBeneficiary(_beneficiaryAddresses[_index]);\n        }\n    }\n\n    /**\n     * @notice Unlocks beneficiary\n     *\n     * @param _beneficiaryAddress address of beneficiary to be unlocked\n     */\n    function _unlockBeneficiary(address _beneficiaryAddress) internal {\n        Beneficiary storage _beneficiary = _beneficiaries[_beneficiaryAddress];\n\n        if (_beneficiary.state == BeneficiaryState.Locked) {\n            _changeBeneficiaryState(_beneficiary, BeneficiaryState.Valid);\n            emit BeneficiaryUnlocked(msg.sender, _beneficiaryAddress);\n        }\n    }\n\n    /**\n     * @notice Unlocks beneficiaries\n     *\n     * @param _beneficiaryAddresses addresses of beneficiaries to be unlocked\n     */\n    function _unlockBeneficiaries(address[] memory _beneficiaryAddresses) internal {\n        uint256 _index;\n        uint256 _numberOfBeneficiaries = _beneficiaryAddresses.length;\n\n        for (; _index < _numberOfBeneficiaries; _index++) {\n            _unlockBeneficiary(_beneficiaryAddresses[_index]);\n        }\n    }\n\n    /**\n     * @notice Removes beneficiary\n     *\n     * @param _beneficiaryAddress address of beneficiary to be removed\n     */\n    function _removeBeneficiary(address _beneficiaryAddress) internal {\n        Beneficiary storage _beneficiary = _beneficiaries[_beneficiaryAddress];\n\n        if (\n            _beneficiary.state == BeneficiaryState.Valid ||\n            _beneficiary.state == BeneficiaryState.Locked\n        ) {\n            _changeBeneficiaryState(_beneficiary, BeneficiaryState.Removed);\n            emit BeneficiaryRemoved(msg.sender, _beneficiaryAddress);\n        }\n    }\n\n    /**\n     * @notice Removes beneficiaries\n     *\n     * @param _beneficiaryAddresses addresses of beneficiaries to be removed\n     */\n    function _removeBeneficiaries(address[] memory _beneficiaryAddresses) internal {\n        uint256 _index;\n        uint256 _numberOfBeneficiaries = _beneficiaryAddresses.length;\n\n        for (; _index < _numberOfBeneficiaries; _index++) {\n            _removeBeneficiary(_beneficiaryAddresses[_index]);\n        }\n    }\n\n    /**\n     * @notice Changes the address of a beneficiary\n     * this action adds claim details from both addresses\n     */\n    function _changeBeneficiaryAddress(\n        address _oldBeneficiaryAddress,\n        address _newBeneficiaryAddress\n    ) internal {\n        require(\n            _oldBeneficiaryAddress != _newBeneficiaryAddress,\n            \"Community::changeBeneficiaryAddress: Beneficiaries must be different\"\n        );\n\n        Beneficiary storage _oldBeneficiary = _beneficiaries[_oldBeneficiaryAddress];\n        Beneficiary storage _newBeneficiary = _beneficiaries[_newBeneficiaryAddress];\n\n        require(\n            _oldBeneficiary.state != BeneficiaryState.AddressChanged &&\n                _oldBeneficiary.state != BeneficiaryState.NONE,\n            \"Community::changeBeneficiaryAddress: Invalid beneficiary\"\n        );\n        require(\n            _newBeneficiary.state != BeneficiaryState.AddressChanged,\n            \"Community::changeBeneficiaryAddress: Invalid target beneficiary\"\n        );\n\n        if (_newBeneficiary.state == BeneficiaryState.NONE) {\n            _changeBeneficiaryState(_newBeneficiary, _oldBeneficiary.state);\n        }\n\n        _changeBeneficiaryState(_oldBeneficiary, BeneficiaryState.AddressChanged);\n\n        _newBeneficiary.claims += _oldBeneficiary.claims;\n\n        // we have to align both beneficiaries lastClaim and claimedAmount\n        // we choose the bigger lastClaim as the alignment point\n        if (_newBeneficiary.lastClaim > _oldBeneficiary.lastClaim) {\n            // _newBeneficiary.claimedAmount was updated later than _oldBeneficiary.claimedAmount\n            // we have to _calculateBeneficiaryClaimedAmount for _oldBeneficiary\n            //      taking into account all token updates between  _oldBeneficiary.lasClaim and _newBeneficiary.lastClaim\n            _newBeneficiary.claimedAmount += _calculateBeneficiaryClaimedAmount(\n                _oldBeneficiary,\n                _newBeneficiary.lastClaim\n            );\n        } else {\n            // _oldBeneficiary.claimedAmount was updated later than _newBeneficiary.claimedAmount\n            // we have to _calculateBeneficiaryClaimedAmount for _newBeneficiary\n            //      taking into account all token updates between _newBeneficiary.lasClaim and _oldBeneficiary.lastClaim\n            _newBeneficiary.claimedAmount =\n                _oldBeneficiary.claimedAmount +\n                _calculateBeneficiaryClaimedAmount(_newBeneficiary, _oldBeneficiary.lastClaim);\n            _newBeneficiary.lastClaim = _oldBeneficiary.lastClaim;\n        }\n\n        uint256 _tokensLength = _tokenList.length();\n        address _tokenAddress;\n        for (uint256 _index = 0; _index < _tokensLength; _index++) {\n            _tokenAddress = _tokenList.at(_index);\n            _newBeneficiary.claimedAmounts[_tokenAddress] += _oldBeneficiary.claimedAmounts[\n                _tokenAddress\n            ];\n        }\n\n        emit BeneficiaryAddressChanged(_oldBeneficiaryAddress, _newBeneficiaryAddress);\n    }\n\n    /**\n     * @notice Checks a manager signature\n     *\n     * @param _expirationTimestamp  timestamp when the signature will expire/expired\n     * @param _signature            the signature of a manager\n     */\n    function _checkManagerSignature(uint256 _expirationTimestamp, bytes calldata _signature)\n        internal\n    {\n        require(\n            msg.sender == communityAdmin.authorizedWalletAddress(),\n            \"Community: Sender must be the backend wallet\"\n        );\n        require(_expirationTimestamp >= block.timestamp, \"Community: Signature too old\");\n\n        bytes32 _messageHash = keccak256(\n            abi.encode(msg.sender, address(this), _expirationTimestamp)\n        );\n\n        address _signerAddress = _messageHash.toEthSignedMessageHash().recover(_signature);\n        require(hasRole(MANAGER_ROLE, _signerAddress), \"Community: Invalid signature\");\n    }\n\n    /**\n     * @notice Calculates the claimed amount of a beneficiary based on all currencies\n     *\n     * @param _beneficiary                 the beneficiary\n     * @param _skipTokenUpdatesAfterBlock  the method will ignore all token updates made after this block\n     *                                     used only by merge beneficiaries methods\n     */\n    function _calculateBeneficiaryClaimedAmount(\n        Beneficiary storage _beneficiary,\n        uint256 _skipTokenUpdatesAfterBlock\n    ) internal view returns (uint256) {\n        uint256 _tokenUpdatesLength = tokenUpdates.length;\n        if (_tokenUpdatesLength < 2) {\n            return _beneficiary.claimedAmount;\n        }\n\n        uint256 _computedClaimAmount = _beneficiary.claimedAmount;\n\n        //if beneficiary didn't claim for a long time and the token has been changed,\n        //we multiply the claimed amount with all token ratios that user haven't claimed\n        for (\n            uint256 _index = _tokenUpdatesLength - 1;\n            tokenUpdates[_index].startBlock > _beneficiary.lastClaim;\n            _index--\n        ) {\n            if (_skipTokenUpdatesAfterBlock < tokenUpdates[_index].startBlock) {\n                continue;\n            }\n            _computedClaimAmount = (_computedClaimAmount * tokenUpdates[_index].ratio) / 1e18;\n        }\n\n        return _computedClaimAmount;\n    }\n\n    /**\n     * @notice Adds a new manager\n     *\n     * @param _account address of the manager to be added\n     */\n    function _addManager(address _account) internal {\n        if (!hasRole(MANAGER_ROLE, _account)) {\n            super._grantRole(MANAGER_ROLE, _account);\n            emit ManagerAdded(msg.sender, _account);\n        }\n    }\n\n    function _updateClaimAmount() internal {\n        uint256 _newClaimAmount;\n        uint256 _minClaimAmountRatio = communityAdmin.minClaimAmountRatio();\n        uint256 _minClaimAmountRatioPrecision = communityAdmin.minClaimAmountRatioPrecision();\n\n        if (\n            validBeneficiaryCount == 0 ||\n            isSelfFunding() ||\n            _minClaimAmountRatio <= _minClaimAmountRatioPrecision\n        ) {\n            _newClaimAmount = originalClaimAmount;\n        } else {\n            _newClaimAmount = token().balanceOf(address(this)) / validBeneficiaryCount;\n\n            uint256 _minimumClaimAmount = (originalClaimAmount * _minClaimAmountRatioPrecision) /\n                _minClaimAmountRatio;\n\n            if (_newClaimAmount < _minimumClaimAmount) {\n                _newClaimAmount = _minimumClaimAmount;\n            } else if (_newClaimAmount > originalClaimAmount) {\n                _newClaimAmount = originalClaimAmount;\n            }\n        }\n\n        if (_newClaimAmount != claimAmount) {\n            emit ClaimAmountUpdated(claimAmount, _newClaimAmount);\n            claimAmount = _newClaimAmount;\n            claimAmount = _newClaimAmount;\n        }\n    }\n\n    /**\n     * @notice Changes the state of a beneficiary\n     *\n     * @param _beneficiary address of the beneficiary\n     * @param _newState new state\n     */\n    function _changeBeneficiaryState(Beneficiary storage _beneficiary, BeneficiaryState _newState)\n        internal\n    {\n        if (_beneficiary.state == _newState) {\n            return;\n        }\n\n        if (_newState == BeneficiaryState.Valid) {\n            require(\n                maxTotalClaim - decreaseStep >= originalClaimAmount,\n                \"Community::_changeBeneficiaryState: Max claim too low\"\n            );\n            require(\n                maxBeneficiaries == 0 || validBeneficiaryCount < maxBeneficiaries,\n                \"Community::_changeBeneficiaryState: This community has reached the maximum number of valid beneficiaries\"\n            );\n            validBeneficiaryCount++;\n            maxTotalClaim -= decreaseStep;\n        } else if (_beneficiary.state == BeneficiaryState.Valid) {\n            validBeneficiaryCount--;\n            maxTotalClaim += decreaseStep;\n        }\n\n        _beneficiary.state = _newState;\n    }\n\n    function _requestFunds() internal {\n        if (isSelfFunding()) {\n            return;\n        }\n\n        uint256 _amount = communityAdmin.fundCommunity();\n\n        if (_amount > 0) {\n            lastFundRequest = block.number;\n\n            _updateClaimAmount();\n\n            treasuryFunds += _amount;\n\n            emit FundsRequested(msg.sender);\n        }\n    }\n}\n"
    },
    "contracts/microcredit/MicrocreditImplementation.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./interfaces/MicrocreditStorageV1.sol\";\n\ncontract MicrocreditImplementation is\n    Initializable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    MicrocreditStorageV1\n{\n    using SafeERC20Upgradeable for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    event ManagerAdded(address indexed managerAddress, uint256 currentLentAmountLimit);\n\n    event ManagerRemoved(address indexed managerAddress);\n\n    event LoanAdded(\n        address indexed userAddress,\n        uint256 loanId,\n        uint256 amount,\n        uint256 period,\n        uint256 dailyInterest,\n        uint256 claimDeadline\n    );\n\n    event LoanCanceled(address indexed userAddress, uint256 loanId);\n\n    event UserAddressChanged(address indexed oldWalletAddress, address indexed newWalletAddress);\n\n    event LoanClaimed(address indexed userAddress, uint256 loanId);\n\n    event RepaymentAdded(\n        address indexed userAddress,\n        uint256 loanId,\n        uint256 repaymentAmount,\n        uint256 currentDebt\n    );\n\n    /**\n     * @notice Triggered when a borrower's manager has been changed\n     *\n     * @param borrowerAddress   The address of the borrower\n     * @param managerAddress    The address of the new manager\n     */\n    event ManagerChanged(address indexed borrowerAddress, address indexed managerAddress);\n\n    modifier onlyManagers() {\n        require(_managerList.contains(msg.sender), \"Microcredit: caller is not a manager\");\n        _;\n    }\n\n    /**\n     * @notice Used to initialize the Microcredit contract\n     *\n     * @param _cUSDAddress      The address of the cUSD token\n     * @param _revenueAddress   The address that collects all the interest\n     */\n    function initialize(address _cUSDAddress, address _revenueAddress) public initializer {\n        __Ownable_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        cUSD = IERC20(_cUSDAddress);\n        revenueAddress = _revenueAddress;\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice Returns the information of a user\n     *\n     * @param _userAddress           address of the user\n     * @return userId                the userId\n     * @return movedTo               the number of the user's loans\n     * @return loansLength           the number of the user's loans\n     */\n    function walletMetadata(address _userAddress)\n        external\n        view\n        override\n        returns (\n            uint256 userId,\n            address movedTo,\n            uint256 loansLength\n        )\n    {\n        WalletMetadata memory _metadata = _walletMetadata[_userAddress];\n\n        userId = _metadata.userId;\n        movedTo = _metadata.movedTo;\n        loansLength = _users[_metadata.userId].loans.length;\n    }\n\n    /**\n     * @notice Returns the length of the walletList\n     */\n    function walletListLength() external view override returns (uint256) {\n        return _walletList.length();\n    }\n\n    /**\n     * @notice Returns an address from the walletList\n     *\n     * @param _index index value\n     * @return address of the user\n     */\n    function walletListAt(uint256 _index) external view override returns (address) {\n        return _walletList.at(_index);\n    }\n\n    /**\n     * @notice Returns an address from the managerList\n     *\n     * @param _index index value\n     * @return address of the manager\n     */\n    function managerListAt(uint256 _index) external view override returns (address) {\n        return _managerList.at(_index);\n    }\n\n    /**\n     * @notice Returns the length of the managerList\n     */\n    function managerListLength() external view override returns (uint256) {\n        return _managerList.length();\n    }\n\n    function userLoans(address _userAddress, uint256 _loanId)\n        external\n        view\n        override\n        returns (\n            uint256 amountBorrowed,\n            uint256 period,\n            uint256 dailyInterest,\n            uint256 claimDeadline,\n            uint256 startDate,\n            uint256 currentDebt,\n            uint256 lastComputedDebt,\n            uint256 amountRepayed,\n            uint256 repaymentsLength,\n            uint256 lastComputedDate,\n            address managerAddress\n        )\n    {\n        _checkUserLoan(_userAddress, _loanId);\n\n        WalletMetadata memory _metadata = _walletMetadata[_userAddress];\n        User memory _user = _users[_metadata.userId];\n        Loan memory _loan = _user.loans[_loanId];\n\n        amountBorrowed = _loan.amountBorrowed;\n        period = _loan.period;\n        dailyInterest = _loan.dailyInterest;\n        claimDeadline = _loan.claimDeadline;\n        startDate = _loan.startDate;\n        lastComputedDebt = _loan.lastComputedDebt;\n        currentDebt = _calculateCurrentDebt(_loan);\n        amountRepayed = _loan.amountRepayed;\n        repaymentsLength = _loan.repayments.length;\n        lastComputedDate = _loan.lastComputedDate;\n        managerAddress = _loan.managerAddress;\n    }\n\n    function userLoanRepayments(\n        address _userAddress,\n        uint256 _loanId,\n        uint256 _repaymentId\n    ) external view override returns (uint256 date, uint256 amount) {\n        _checkUserLoan(_userAddress, _loanId);\n\n        WalletMetadata memory _metadata = _walletMetadata[_userAddress];\n        User memory _user = _users[_metadata.userId];\n        Loan memory _loan = _user.loans[_loanId];\n\n        require(_loan.repayments.length > _repaymentId, \"Microcredit: Repayment doesn't exist\");\n\n        date = _loan.repayments[_repaymentId].date;\n        amount = _loan.repayments[_repaymentId].amount;\n    }\n\n    function updateRevenueAddress(address _newRevenueAddress) external override onlyOwner {\n        revenueAddress = _newRevenueAddress;\n    }\n\n    function updateDonationMiner(IDonationMiner _newDonationMiner) external override onlyOwner {\n        donationMiner = _newDonationMiner;\n    }\n\n    /**\n     * @notice Adds managers\n     *\n     * @param _managerAddresses      addresses of the managers\n     */\n    function addManagers(\n        address[] calldata _managerAddresses,\n        uint256[] calldata _currentLentAmountLimit\n    ) external override onlyOwner {\n        uint256 _length = _managerAddresses.length;\n        uint256 _index;\n\n        for (_index = 0; _index < _length; _index++) {\n            _managerList.add(_managerAddresses[_index]);\n\n            managers[_managerAddresses[_index]].currentLentAmountLimit = _currentLentAmountLimit[\n                _index\n            ];\n            emit ManagerAdded(_managerAddresses[_index], _currentLentAmountLimit[_index]);\n        }\n    }\n\n    /**\n     * @notice Removes managers\n     *\n     * @param _managerAddresses     addresses of the managers\n     */\n    function removeManagers(address[] calldata _managerAddresses) external override onlyOwner {\n        uint256 _length = _managerAddresses.length;\n        uint256 _index;\n\n        for (_index = 0; _index < _length; _index++) {\n            _managerList.remove(_managerAddresses[_index]);\n            emit ManagerRemoved(_managerAddresses[_index]);\n        }\n    }\n\n    /**\n     * @notice Adds a loan\n     *\n     * @param _userAddress           address of the user\n     * @param _amount                amount of the loan\n     * @param _period                period of the loan\n     * @param _dailyInterest         daily interest of the loan\n     * @param _claimDeadline         claim deadline of the loan\n     */\n    function addLoan(\n        address _userAddress,\n        uint256 _amount,\n        uint256 _period,\n        uint256 _dailyInterest,\n        uint256 _claimDeadline\n    ) external override onlyManagers {\n        _addLoan(_userAddress, _amount, _period, _dailyInterest, _claimDeadline);\n    }\n\n    /**\n     * @notice Adds multiples loans\n     *\n     * @param _userAddresses          addresses of the user\n     * @param _amounts                amounts of the loan\n     * @param _periods                periods of the loan\n     * @param _dailyInterests         daily interests of the loan\n     * @param _claimDeadlines         claim deadlines of the loan\n     */\n    function addLoans(\n        address[] calldata _userAddresses,\n        uint256[] calldata _amounts,\n        uint256[] calldata _periods,\n        uint256[] calldata _dailyInterests,\n        uint256[] calldata _claimDeadlines\n    ) external override onlyManagers {\n        uint256 _loansNumber = _userAddresses.length;\n        require(\n            _loansNumber == _amounts.length,\n            \"Microcredit: calldata information arity mismatch\"\n        );\n        require(\n            _loansNumber == _periods.length,\n            \"Microcredit: calldata information arity mismatch\"\n        );\n        require(\n            _loansNumber == _dailyInterests.length,\n            \"Microcredit: calldata information arity mismatch\"\n        );\n        require(\n            _loansNumber == _claimDeadlines.length,\n            \"Microcredit: calldata information arity mismatch\"\n        );\n\n        uint256 _index;\n\n        for (_index = 0; _index < _loansNumber; _index++) {\n            _addLoan(\n                _userAddresses[_index],\n                _amounts[_index],\n                _periods[_index],\n                _dailyInterests[_index],\n                _claimDeadlines[_index]\n            );\n        }\n    }\n\n    /**\n     * @notice Cancel a loan\n     *\n     * @param _userAddresses    User addresses\n     * @param _loansIds Loan ids\n     */\n    function cancelLoans(address[] calldata _userAddresses, uint256[] calldata _loansIds)\n        external\n        override\n        onlyManagers\n    {\n        require(\n            _userAddresses.length == _loansIds.length,\n            \"Microcredit: calldata information arity mismatch\"\n        );\n\n        uint256 _index;\n\n        for (_index = 0; _index < _userAddresses.length; _index++) {\n            _cancelLoan(_userAddresses[_index], _loansIds[_index]);\n        }\n    }\n\n    /**\n     * @notice Change user address\n     *\n     * @param _oldWalletAddress Old wallet address\n     * @param _newWalletAddress New wallet address\n     */\n    function changeUserAddress(address _oldWalletAddress, address _newWalletAddress)\n        external\n        override\n        onlyManagers\n    {\n        WalletMetadata storage _oldWalletMetadata = _walletMetadata[_oldWalletAddress];\n        require(\n            _oldWalletMetadata.userId > 0 && _oldWalletMetadata.movedTo == address(0),\n            \"Microcredit: This user cannot be moved\"\n        );\n\n        WalletMetadata storage _newWalletMetadata = _walletMetadata[_newWalletAddress];\n        require(_newWalletMetadata.userId == 0, \"Microcredit: Target wallet address is invalid\");\n\n        _oldWalletMetadata.movedTo = _newWalletAddress;\n        _newWalletMetadata.userId = _oldWalletMetadata.userId;\n\n        _walletList.add(_newWalletAddress);\n\n        emit UserAddressChanged(_oldWalletAddress, _newWalletAddress);\n    }\n\n    /**\n     * @notice Claim a loan\n     *\n     * @param _loanId Loan ID\n     */\n    function claimLoan(uint256 _loanId) external override nonReentrant {\n        _checkUserLoan(msg.sender, _loanId);\n\n        WalletMetadata memory _metadata = _walletMetadata[msg.sender];\n        User storage _user = _users[_metadata.userId];\n        Loan storage _loan = _user.loans[_loanId];\n\n        require(_loan.startDate == 0, \"Microcredit: Loan already claimed\");\n        require(_loan.claimDeadline != 0, \"Microcredit: Loan canceled\");\n        require(_loan.claimDeadline >= block.timestamp, \"Microcredit: Loan expired\");\n\n        _loan.startDate = block.timestamp;\n\n        _loan.lastComputedDebt = (_loan.amountBorrowed * (1e18 + _loan.dailyInterest / 100)) / 1e18;\n        _loan.lastComputedDate = block.timestamp;\n\n        cUSD.safeTransfer(msg.sender, _loan.amountBorrowed);\n\n        emit LoanClaimed(msg.sender, _loanId);\n    }\n\n    /**\n     * @notice Repay a loan\n     *\n     * @param _loanId Loan ID\n     * @param _repaymentAmount Repayment amount\n     */\n    function repayLoan(uint256 _loanId, uint256 _repaymentAmount) external override nonReentrant {\n        require(_repaymentAmount > 0, \"Microcredit: Invalid amount\");\n\n        _checkUserLoan(msg.sender, _loanId);\n\n        WalletMetadata memory _metadata = _walletMetadata[msg.sender];\n        User storage _user = _users[_metadata.userId];\n        Loan storage _loan = _user.loans[_loanId];\n\n        require(_loan.startDate > 0, \"Microcredit: Loan not claimed\");\n        require(_loan.lastComputedDebt > 0, \"Microcredit: Loan has already been fully repayed\");\n\n        uint256 _currentDebt = _calculateCurrentDebt(_loan);\n\n        if (_currentDebt < _repaymentAmount) {\n            _repaymentAmount = _currentDebt;\n        }\n\n        if (_loan.amountRepayed + _repaymentAmount <= _loan.amountBorrowed) {\n            //all repaymentAmount should go to microcredit address\n            cUSD.safeTransferFrom(msg.sender, address(this), _repaymentAmount);\n            _registerRepaymentToManager(_loan.managerAddress, _repaymentAmount);\n        } else if (_loan.amountRepayed >= _loan.amountBorrowed) {\n            //all repaymentAmount should go to revenue address\n            cUSD.safeTransferFrom(msg.sender, revenueAddress, _repaymentAmount);\n        } else {\n            //a part of the repayment should go to microcredit address and the rest should go to the revenue address\n\n            uint256 _loanDiff = _loan.amountBorrowed - _loan.amountRepayed;\n\n            if (revenueAddress == address(0)) {\n                cUSD.safeTransferFrom(msg.sender, address(this), _repaymentAmount);\n            } else {\n                cUSD.safeTransferFrom(msg.sender, address(this), _loanDiff);\n                cUSD.safeTransferFrom(msg.sender, revenueAddress, _repaymentAmount - _loanDiff);\n            }\n\n            _registerRepaymentToManager(_loan.managerAddress, _loanDiff);\n        }\n\n        Repayment storage _repayment = _loan.repayments.push();\n        _repayment.date = block.timestamp;\n        _repayment.amount = _repaymentAmount;\n\n        _loan.lastComputedDebt = _currentDebt - _repaymentAmount;\n        _loan.amountRepayed += _repaymentAmount;\n\n        uint256 _days = (block.timestamp - _loan.lastComputedDate) / 86400; //86400 = 1 day in seconds\n\n        _loan.lastComputedDate = _loan.lastComputedDate + _days * 86400;\n\n        if (_loan.lastComputedDebt == 0 && address(donationMiner) != address(0)) {\n            donationMiner.donateVirtual(\n                _loan.amountRepayed - _loan.amountBorrowed,\n                msg.sender\n            );\n        }\n\n        emit RepaymentAdded(msg.sender, _loanId, _repaymentAmount, _loan.lastComputedDebt);\n    }\n\n    /**\n     * @notice Changes the borrowers manager address\n     * @dev This method doesn't change anything on the contract state, it just emits events to be used by the off-chain system\n     *\n     * @param _borrowerAddresses address of the borrowers\n     * @param _managerAddress address of the new manager\n     */\n    function changeManager(address[] memory _borrowerAddresses, address _managerAddress)\n        external\n        override\n        onlyManagers\n    {\n        uint256 _index;\n        require(_managerList.contains(_managerAddress), \"Microcredit: invalid manager address\");\n\n        for (_index = 0; _index < _borrowerAddresses.length; _index++) {\n            require(\n                _walletList.contains(_borrowerAddresses[_index]),\n                \"Microcredit: invalid borrower address\"\n            );\n            emit ManagerChanged(_borrowerAddresses[_index], _managerAddress);\n        }\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from this contract to an address\n     *\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transferERC20(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override nonReentrant onlyOwner {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    function _checkUserLoan(address _userAddress, uint256 _loanId) internal view {\n        WalletMetadata memory _metadata = _walletMetadata[_userAddress];\n\n        require(\n            _metadata.userId > 0 && _metadata.movedTo == address(0),\n            \"Microcredit: Invalid wallet address\"\n        );\n\n        User memory _user = _users[_metadata.userId];\n\n        require(_user.loans.length > _loanId, \"Microcredit: Loan doesn't exist\");\n    }\n\n    function _calculateCurrentDebt(Loan memory _loan) internal view returns (uint256) {\n        if (_loan.lastComputedDebt == 0) {\n            return 0;\n        }\n\n        uint256 _days = (block.timestamp - _loan.lastComputedDate) / 86400; //86400 = 1 day in seconds\n\n        uint256 _currentDebt = _loan.lastComputedDebt;\n\n        while (_days > 0) {\n            _currentDebt = (_currentDebt * (1e18 + _loan.dailyInterest / 100)) / 1e18;\n            _days--;\n        }\n\n        return _currentDebt;\n    }\n\n    function _addLoan(\n        address _userAddress,\n        uint256 _amount,\n        uint256 _period,\n        uint256 _dailyInterest,\n        uint256 _claimDeadline\n    ) internal {\n        require(_claimDeadline > block.timestamp, \"Microcredit: invalid claimDeadline\");\n\n        WalletMetadata storage _metadata = _walletMetadata[_userAddress];\n        require(_metadata.movedTo == address(0), \"Microcredit: The user has been moved\");\n\n        Manager storage _manager = managers[msg.sender];\n        require(\n            _manager.currentLentAmount + _amount <= _manager.currentLentAmountLimit,\n            \"Microcredit: Manager don't have enough funds to borrow this amount\"\n        );\n\n        if (_metadata.userId == 0) {\n            _usersLength++;\n            _metadata.userId = _usersLength;\n            _walletList.add(_userAddress);\n        }\n\n        User storage _user = _users[_metadata.userId];\n\n        uint256 _loansLength = _user.loans.length;\n\n        if (_loansLength > 0) {\n            Loan memory _previousLoan = _user.loans[_loansLength - 1];\n            require(\n                (_previousLoan.startDate > 0 && _previousLoan.lastComputedDebt == 0) || // loan claimed and fully paid\n                    (_previousLoan.startDate == 0 &&\n                        _previousLoan.claimDeadline < block.timestamp) || //loan unclaimed and expired\n                    (_previousLoan.claimDeadline == 0), //loan canceled\n                \"Microcredit: The user already has an active loan\"\n            );\n        }\n\n        Loan storage _loan = _user.loans.push();\n\n        _loan.amountBorrowed = _amount;\n        _loan.period = _period;\n        _loan.dailyInterest = _dailyInterest;\n        _loan.claimDeadline = _claimDeadline;\n        _loan.managerAddress = msg.sender;\n\n        _manager.currentLentAmount += _amount;\n\n        emit LoanAdded(\n            _userAddress,\n            _user.loans.length - 1,\n            _amount,\n            _period,\n            _dailyInterest,\n            _claimDeadline\n        );\n    }\n\n    function _cancelLoan(address _userAddress, uint256 _loanId) internal {\n        _checkUserLoan(_userAddress, _loanId);\n\n        WalletMetadata memory _metadata = _walletMetadata[_userAddress];\n        User storage _user = _users[_metadata.userId];\n        Loan storage _loan = _user.loans[_loanId];\n\n        require(_loan.startDate == 0, \"Microcredit: Loan already claimed\");\n        require(_loan.claimDeadline != 0, \"Microcredit: Loan already canceled\");\n\n        _loan.claimDeadline = 0; //set claimDeadline to 0 to prevent claiming (cancel the loan)\n\n        Manager storage _manager = managers[_loan.managerAddress];\n\n        _manager.currentLentAmount -= _loan.amountBorrowed;\n\n        emit LoanCanceled(_userAddress, _loanId);\n    }\n\n    function _registerRepaymentToManager(address _managerAddress, uint256 _repaymentAmount)\n        internal\n    {\n        if (_managerAddress != address(0)) {\n            if (managers[_managerAddress].currentLentAmount > _repaymentAmount) {\n                managers[_managerAddress].currentLentAmount -= _repaymentAmount;\n            } else {\n                managers[_managerAddress].currentLentAmount = 0;\n            }\n        }\n    }\n}\n"
    },
    "contracts/microcredit/interfaces/MicrocreditStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./IMicrocredit.sol\";\n\n/**\n * @title Storage for Microcredit\n * @notice For future upgrades, do not change MicrocreditStorageV1. Create a new\n * contract which implements MicrocreditStorageV1 and following the naming convention\n * MicrocreditStorageVx.\n */\nabstract contract MicrocreditStorageV1 is IMicrocredit {\n    IERC20 public override cUSD;\n\n    uint256 internal  _usersLength;\n    mapping(uint256 => User) internal _users;\n\n    mapping(address => WalletMetadata) internal _walletMetadata;\n    EnumerableSet.AddressSet internal _walletList;\n\n    EnumerableSet.AddressSet internal _managerList;\n    address public override revenueAddress;\n\n    mapping(address => Manager) public override managers;\n\n    IDonationMiner public override donationMiner;\n}\n"
    },
    "contracts/deposit/DepositImplementation.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./interfaces/DepositStorageV1.sol\";\nimport \"../externalInterfaces/aave/IAToken.sol\";\n\ncontract DepositImplementation is\n    Initializable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    DepositStorageV1\n{\n    using SafeERC20Upgradeable for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /**\n     * @notice Triggered when a token has been added\n     *\n     * @param tokenAddress        Address of the token\n     */\n    event TokenAdded(address indexed tokenAddress);\n\n    /**\n     * @notice Triggered when a token has been removed\n     *\n     * @param tokenAddress        Address of the token\n     */\n    event TokenRemoved(address indexed tokenAddress);\n\n    /**\n     * @notice Triggered when the treasury address has been updated\n     *\n     * @param oldTreasury             Old treasury address\n     * @param newTreasury             New treasury address\n     */\n    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    /**\n     * @notice Triggered when the donationMiner address has been updated\n     *\n     * @param oldDonationMiner             Old donationMiner address\n     * @param newDonationMiner             New donationMiner address\n     */\n    event DonationMinerUpdated(address indexed oldDonationMiner, address indexed newDonationMiner);\n\n    /**\n     * @notice Triggered when LendingPool has been updated\n     *\n     * @param oldLendingPool   Old lendingPool address\n     * @param newLendingPool   New lendingPool address\n     */\n    event LendingPoolUpdated(address indexed oldLendingPool, address indexed newLendingPool);\n\n    /**\n     * @notice Triggered when an amount of an ERC20 has been deposited\n     *\n     * @param depositorAddress    The address of the depositor that makes the deposit\n     * @param token               ERC20 token address\n     * @param amount              Amount of the deposit\n     */\n    event DepositAdded(address indexed depositorAddress, address indexed token, uint256 amount);\n\n    /**\n     * @notice Triggered when an amount of an ERC20 has been withdrawn\n     *\n     * @param depositorAddress    The address of the depositor that makes the withdrawal\n     * @param token               ERC20 token address\n     * @param amount              Amount of the withdrawal\n     * @param interest            Interest earned (and donated to DonationMiner)\n     */\n    event Withdraw(\n        address indexed depositorAddress,\n        address indexed token,\n        uint256 amount,\n        uint256 interest\n    );\n\n    /**\n     * @notice Triggered when the interest of an amount of an ERC20 has been donated\n     *\n     * @param depositorAddress    The address of the depositor\n     * @param token               ERC20 token address\n     * @param amount              Amount of the withdrawal\n     * @param interest            Interest earned (and donated to DonationMiner)\n     */\n    event DonateInterest(\n        address indexed depositorAddress,\n        address indexed token,\n        uint256 amount,\n        uint256 interest\n    );\n\n    /**\n     * @notice Used to initialize a new DonationMiner contract\n     *\n     * @param _treasury             Address of the Treasury\n     * @param _lendingPool          Address of the LendingPool\n     */\n    function initialize(\n        ITreasury _treasury,\n        IDonationMiner _donationMiner,\n        ILendingPool _lendingPool,\n        address[] memory _tokenListAddresses\n    ) public initializer {\n        require(address(_treasury) != address(0), \"Deposit::initialize: invalid _treasury address\");\n        require(\n            address(_lendingPool) != address(0),\n            \"Deposit::initialize: invalid _lendingPool address\"\n        );\n\n        __Ownable_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        treasury = _treasury;\n        donationMiner = _donationMiner;\n        lendingPool = _lendingPool;\n\n        uint256 _index;\n        uint256 _numberOfTokens = _tokenListAddresses.length;\n        for (; _index < _numberOfTokens; _index++) {\n            _tokenList.add(_tokenListAddresses[_index]);\n\n            IERC20(_tokenListAddresses[_index]).approve(address(lendingPool), type(uint256).max);\n            IERC20(_tokenListAddresses[_index]).approve(address(donationMiner), type(uint256).max);\n\n            emit TokenAdded(_tokenListAddresses[_index]);\n        }\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 1;\n    }\n\n    function token(address _tokenAddress)\n        external\n        view\n        override\n        returns (uint256 totalAmount, uint256 depositorListLength)\n    {\n        Token storage _token = _tokens[_tokenAddress];\n\n        return (_token.totalAmount, _token.depositorList.length());\n    }\n\n    function tokenDepositorListAt(address _tokenAddress, uint256 _index)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _tokens[_tokenAddress].depositorList.at(_index);\n    }\n\n    /**\n     * @notice Returns the number of tokens\n     *\n     * @return uint256 number of tokens\n     */\n    function tokenListLength() external view override returns (uint256) {\n        return _tokenList.length();\n    }\n\n    /**\n     * @notice Returns the address of a token from tokenList\n     *\n     * @param _index index of the token\n     * @return address of the token\n     */\n    function tokenListAt(uint256 _index) external view override returns (address) {\n        return _tokenList.at(_index);\n    }\n\n    /**\n     * @notice Returns if an address is an accepted token\n     *\n     * @param _tokenAddress token address to be checked\n     * @return bool true if the tokenAddress is an accepted token\n     */\n    function isToken(address _tokenAddress) public view override returns (bool) {\n        return _tokenList.contains(_tokenAddress);\n    }\n\n    function tokenDepositor(address _tokenAddress, address _depositorAddress)\n        external\n        view\n        override\n        returns (uint256 amount, uint256 scaledBalance)\n    {\n        Depositor memory _depositor = _tokens[_tokenAddress].depositors[_depositorAddress];\n\n        return (_depositor.amount, _depositor.scaledBalance);\n    }\n\n    /**\n     * @notice Updates Treasury address\n     *\n     * @param _newTreasury address of new treasury contract\n     */\n    function updateTreasury(ITreasury _newTreasury) external override onlyOwner {\n        emit TreasuryUpdated(address(treasury), address(_newTreasury));\n        treasury = _newTreasury;\n    }\n\n    /**\n     * @notice Updates DonationMiner address\n     *\n     * @param _newDonationMiner address of new donationMiner contract\n     */\n    function updateDonationMiner(IDonationMiner _newDonationMiner) external override onlyOwner {\n        emit DonationMinerUpdated(address(donationMiner), address(_newDonationMiner));\n        donationMiner = _newDonationMiner;\n    }\n\n    /**\n     * @notice Updates the LendingPool contract address\n     *\n     * @param _newLendingPool address of the new LendingPool contract\n     */\n    function updateLendingPool(ILendingPool _newLendingPool) external override onlyOwner {\n        emit LendingPoolUpdated(address(lendingPool), address(_newLendingPool));\n        lendingPool = _newLendingPool;\n    }\n\n    function addToken(address _tokenAddress) public override onlyOwner {\n        require(!isToken(_tokenAddress), \"Deposit::addToken: token already added\");\n        require(\n            treasury.isToken(_tokenAddress),\n            \"Deposit::addToken: it must be a valid treasury token\"\n        );\n\n        require(\n            lendingPool.getReserveData(_tokenAddress).aTokenAddress != address(0),\n            \"Deposit::addToken: it must be a valid lendingPool token\"\n        );\n\n        _tokenList.add(_tokenAddress);\n\n        IERC20(_tokenAddress).approve(address(lendingPool), type(uint256).max);\n        IERC20(_tokenAddress).approve(address(donationMiner), type(uint256).max);\n\n        emit TokenAdded(_tokenAddress);\n    }\n\n    function removeToken(address _tokenAddress) external override onlyOwner {\n        require(isToken(_tokenAddress), \"Deposit::removeToken: this is not a token\");\n\n        _tokenList.remove(_tokenAddress);\n        emit TokenRemoved(_tokenAddress);\n    }\n\n    function deposit(address _tokenAddress, uint256 _amount)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n    {\n        require(isToken(_tokenAddress), \"Deposit::deposit: this is not a token\");\n        require(_amount > 0, \"Deposit::deposit: invalid amount\");\n\n        IERC20Upgradeable(_tokenAddress).safeTransferFrom(msg.sender, address(this), _amount);\n\n        IAToken aToken = IAToken(lendingPool.getReserveData(_tokenAddress).aTokenAddress);\n\n        uint256 _beforeScaledBalance = aToken.scaledBalanceOf(address(this));\n        lendingPool.deposit(_tokenAddress, _amount, address(this), 0);\n\n        uint256 _afterScaledBalance = aToken.scaledBalanceOf(address(this));\n\n        Token storage _token = _tokens[_tokenAddress];\n        _token.depositorList.add(msg.sender);\n        _token.totalAmount += _amount;\n\n        Depositor storage _depositor = _token.depositors[msg.sender];\n        _depositor.amount += _amount;\n        _depositor.scaledBalance += _afterScaledBalance - _beforeScaledBalance;\n\n        emit DepositAdded(msg.sender, _tokenAddress, _amount);\n    }\n\n    function withdraw(address _tokenAddress, uint256 _amount)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n    {\n        Token storage _token = _tokens[_tokenAddress];\n        Depositor storage _depositor = _token.depositors[msg.sender];\n\n        require(_amount <= _depositor.amount, \"Deposit::withdraw: invalid amount\");\n\n        if (_amount == _depositor.amount) {\n            _token.depositorList.remove(msg.sender);\n        }\n\n        IAToken aToken = IAToken(lendingPool.getReserveData(_tokenAddress).aTokenAddress);\n\n        uint256 _beforeScaledBalance = aToken.scaledBalanceOf(address(this));\n        uint256 _withdrawScaledBalanceShare = (_amount * _depositor.scaledBalance) /\n            _depositor.amount;\n        uint256 _withdrawBalanceShare = (_withdrawScaledBalanceShare *\n            aToken.balanceOf(address(this))) / _beforeScaledBalance;\n\n        uint256 _interest = _withdrawBalanceShare - _amount;\n\n        lendingPool.withdraw(_tokenAddress, _amount, msg.sender);\n        lendingPool.withdraw(_tokenAddress, _interest, address(this));\n        donationMiner.donate(IERC20(_tokenAddress), _interest, msg.sender);\n\n        _token.totalAmount -= _amount;\n        _depositor.amount -= _amount;\n        _depositor.scaledBalance -= _withdrawScaledBalanceShare;\n\n        emit Withdraw(msg.sender, _tokenAddress, _amount, _interest);\n    }\n\n    function donateInterest(\n        address _depositorAddress,\n        address _tokenAddress,\n        uint256 _amount\n    ) external override whenNotPaused nonReentrant {\n        Token storage _token = _tokens[_tokenAddress];\n        Depositor storage _depositor = _token.depositors[_depositorAddress];\n\n        require(_amount <= _depositor.amount, \"Deposit::donateInterest: invalid amount\");\n\n        IAToken aToken = IAToken(lendingPool.getReserveData(_tokenAddress).aTokenAddress);\n\n        uint256 _beforeScaledBalance = aToken.scaledBalanceOf(address(this));\n        uint256 _withdrawScaledBalanceShare = (_amount * _depositor.scaledBalance) /\n            _depositor.amount;\n        uint256 _withdrawBalanceShare = (_withdrawScaledBalanceShare *\n            aToken.balanceOf(address(this))) / _beforeScaledBalance;\n\n        uint256 _interest = _withdrawBalanceShare - _amount;\n\n        lendingPool.withdraw(_tokenAddress, _interest, address(this));\n\n        uint256 _afterScaledBalance = aToken.scaledBalanceOf(address(this));\n\n        donationMiner.donate(IERC20(_tokenAddress), _interest, _depositorAddress);\n\n        _depositor.scaledBalance -= _beforeScaledBalance - _afterScaledBalance;\n\n        emit DonateInterest(_depositorAddress, _tokenAddress, _amount, _interest);\n    }\n\n    function interest(\n        address _depositorAddress,\n        address _tokenAddress,\n        uint256 _amount\n    ) external view override returns (uint256) {\n        Token storage _token = _tokens[_tokenAddress];\n        Depositor storage _depositor = _token.depositors[_depositorAddress];\n\n        require(_amount <= _depositor.amount, \"Deposit::donateInterest: invalid amount\");\n\n        IAToken aToken = IAToken(lendingPool.getReserveData(_tokenAddress).aTokenAddress);\n\n        uint256 _beforeScaledBalance = aToken.scaledBalanceOf(address(this));\n        uint256 _withdrawScaledBalanceShare = (_amount * _depositor.scaledBalance) /\n            _depositor.amount;\n        uint256 _withdrawBalanceShare = (_withdrawScaledBalanceShare *\n            aToken.balanceOf(address(this))) / _beforeScaledBalance;\n\n        return _withdrawBalanceShare - _amount;\n    }\n}\n"
    },
    "contracts/deposit/interfaces/DepositStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./IDeposit.sol\";\n\n/**\n * @title Storage for Deposit\n * @notice For future upgrades, do not change DepositStorageV1. Create a new\n * contract which implements DepositStorageV1 and following the naming convention\n * DepositStorageVx.\n */\nabstract contract DepositStorageV1 is IDeposit {\n    ITreasury public override treasury;\n    IDonationMiner public override donationMiner;\n    ILendingPool public override lendingPool;\n    EnumerableSet.AddressSet internal _tokenList;\n    mapping(address => Token) internal _tokens;\n}\n"
    },
    "contracts/externalInterfaces/aave/IAToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20 as IERC20Aave} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\nimport {IInitializableAToken} from './IInitializableAToken.sol';\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\n\ninterface IAToken is IERC20Aave, IScaledBalanceToken, IInitializableAToken {\n  /**\n   * @dev Emitted after the mint action\n   * @param from The address performing the mint\n   * @param value The amount being\n   * @param index The new liquidity index of the reserve\n   **/\n  event Mint(address indexed from, uint256 value, uint256 index);\n\n  /**\n   * @dev Mints `amount` aTokens to `user`\n   * @param user The address receiving the minted tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(\n    address user,\n    uint256 amount,\n    uint256 index\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted after aTokens are burned\n   * @param from The owner of the aTokens, getting them burned\n   * @param target The address that will receive the underlying\n   * @param value The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\n\n  /**\n   * @dev Emitted during the transfer action\n   * @param from The user whose tokens are being transferred\n   * @param to The recipient\n   * @param value The amount being transferred\n   * @param index The new liquidity index of the reserve\n   **/\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n  /**\n   * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * @param user The owner of the aTokens, getting them burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  function burn(\n    address user,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external;\n\n  /**\n   * @dev Mints aTokens to the reserve treasury\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external;\n\n  /**\n   * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n   * @param from The address getting liquidated, current owner of the aTokens\n   * @param to The recipient\n   * @param value The amount of tokens getting transferred\n   **/\n  function transferOnLiquidation(\n    address from,\n    address to,\n    uint256 value\n  ) external;\n\n  /**\n   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n   * assets in borrow(), withdraw() and flashLoan()\n   * @param user The recipient of the underlying\n   * @param amount The amount getting transferred\n   * @return The amount transferred\n   **/\n  function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\n\n  /**\n   * @dev Invoked to execute actions on the aToken side after a repayment.\n   * @param user The user executing the repayment\n   * @param amount The amount getting repaid\n   **/\n  function handleRepayment(address user, uint256 amount) external;\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view returns (IAaveIncentivesController);\n\n  /**\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   **/\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "contracts/deposit/interfaces/IDeposit.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../../externalInterfaces/aave/ILendingPool.sol\";\nimport \"../../donationMiner/interfaces/IDonationMiner.sol\";\n\ninterface IDeposit {\n    struct Depositor {\n        uint256 amount;\n        uint256 scaledBalance;\n    }\n\n    struct Token {\n        uint256 totalAmount;\n        EnumerableSet.AddressSet depositorList;\n        mapping(address => Depositor) depositors;\n    }\n\n    function getVersion() external pure returns(uint256);\n    function lendingPool() external view returns(ILendingPool);\n    function treasury() external view returns (ITreasury);\n    function donationMiner() external view returns (IDonationMiner);\n    function token(address _tokenAddress) external view returns(uint256 totalAmount, uint256 depositorListLength);\n    function tokenDepositorListAt(address _tokenAddress, uint256 _index) external view returns(address);\n    function tokenListLength() external view returns (uint256);\n    function tokenListAt(uint256 _index) external view returns (address);\n    function isToken(address _tokenAddress) external view returns (bool);\n    function tokenDepositor(address _tokenAddress, address _depositorAddress)\n        external view returns (uint256 amount, uint256 scaledBalance);\n    function updateTreasury(ITreasury _newTreasury) external;\n    function updateDonationMiner(IDonationMiner _newDonationMiner) external;\n    function updateLendingPool(ILendingPool _lendingPool) external;\n    function addToken(address _tokenAddress) external;\n    function removeToken(address _tokenAddress) external;\n    function deposit(address _tokenAddress, uint256 _amount) external;\n    function withdraw(address _tokenAddress, uint256 _amount) external;\n    function donateInterest(address _depositorAddress, address _tokenAddress, uint256 _amount) external;\n    function interest(address _depositorAddress, address _tokenAddress, uint256 _amount) external view returns (uint256);\n}\n"
    },
    "contracts/externalInterfaces/aave/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\nimport {DataTypes} from './DataTypes.sol';\n\ninterface ILendingPool {\n  /**\n   * @dev Emitted on deposit()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the deposit\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n   * @param amount The amount deposited\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to Address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint256 borrowRateMode,\n    uint256 borrowRate,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    address indexed asset,\n    uint256 amount,\n    uint256 premium,\n    uint16 referralCode\n  );\n\n  /**\n   * @dev Emitted when the pause is triggered.\n   */\n  event Paused();\n\n  /**\n   * @dev Emitted when the pause is lifted.\n   */\n  event Unpaused();\n\n  /**\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n   * LendingPoolCollateral manager using a DELEGATECALL\n   * This allows to have the events in the generated ABI for LendingPool.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n   * gets added to the LendingPool ABI\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The new liquidity rate\n   * @param stableBorrowRate The new stable borrow rate\n   * @param variableBorrowRate The new variable borrow rate\n   * @param liquidityIndex The new liquidity index\n   * @param variableBorrowIndex The new variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 rateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n   * @param asset The address of the underlying asset borrowed\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n  /**\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n   *        borrowed at a stable rate and depositors are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n   * @param asset The address of the underlying asset deposited\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralETH the total collateral in ETH of the user\n   * @return totalDebtETH the total debt in ETH of the user\n   * @return availableBorrowsETH the borrowing power left of the user\n   * @return currentLiquidationThreshold the liquidation threshold of the user\n   * @return ltv the loan to value of the user\n   * @return healthFactor the current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralETH,\n      uint256 totalDebtETH,\n      uint256 availableBorrowsETH,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  function initReserve(\n    address reserve,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\n    external;\n\n  function setConfiguration(address reserve, uint256 configuration) external;\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @dev Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @dev Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromAfter,\n    uint256 balanceToBefore\n  ) external;\n\n  function getReservesList() external view returns (address[] memory);\n\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n  function setPause(bool val) external;\n\n  function paused() external view returns (bool);\n}\n"
    },
    "contracts/externalInterfaces/aave/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n  event MarketIdSet(string newMarketId);\n  event LendingPoolUpdated(address indexed newAddress);\n  event ConfigurationAdminUpdated(address indexed newAddress);\n  event EmergencyAdminUpdated(address indexed newAddress);\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n  event PriceOracleUpdated(address indexed newAddress);\n  event LendingRateOracleUpdated(address indexed newAddress);\n  event ProxyCreated(bytes32 id, address indexed newAddress);\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n  function getMarketId() external view returns (string memory);\n\n  function setMarketId(string calldata marketId) external;\n\n  function setAddress(bytes32 id, address newAddress) external;\n\n  function setAddressAsProxy(bytes32 id, address impl) external;\n\n  function getAddress(bytes32 id) external view returns (address);\n\n  function getLendingPool() external view returns (address);\n\n  function setLendingPoolImpl(address pool) external;\n\n  function getLendingPoolConfigurator() external view returns (address);\n\n  function setLendingPoolConfiguratorImpl(address configurator) external;\n\n  function getLendingPoolCollateralManager() external view returns (address);\n\n  function setLendingPoolCollateralManager(address manager) external;\n\n  function getPoolAdmin() external view returns (address);\n\n  function setPoolAdmin(address admin) external;\n\n  function getEmergencyAdmin() external view returns (address);\n\n  function setEmergencyAdmin(address admin) external;\n\n  function getPriceOracle() external view returns (address);\n\n  function setPriceOracle(address priceOracle) external;\n\n  function getLendingRateOracle() external view returns (address);\n\n  function setLendingRateOracle(address lendingRateOracle) external;\n}\n"
    },
    "contracts/externalInterfaces/aave/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    uint256 data;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/externalInterfaces/aave/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\ninterface IScaledBalanceToken {\n  /**\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   **/\n  function scaledBalanceOf(address user) external view returns (uint256);\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled balance and the scaled total supply\n   **/\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n  /**\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n   * @return The scaled total supply\n   **/\n  function scaledTotalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/externalInterfaces/aave/IInitializableAToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {ILendingPool} from './ILendingPool.sol';\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\n\n/**\n * @title IInitializableAToken\n * @notice Interface for the initialize function on AToken\n * @author Aave\n **/\ninterface IInitializableAToken {\n  /**\n   * @dev Emitted when an aToken is initialized\n   * @param underlyingAsset The address of the underlying asset\n   * @param pool The address of the associated lending pool\n   * @param treasury The address of the treasury\n   * @param incentivesController The address of the incentives controller for this aToken\n   * @param aTokenDecimals the decimals of the underlying\n   * @param aTokenName the name of the aToken\n   * @param aTokenSymbol the symbol of the aToken\n   * @param params A set of encoded parameters for additional initialization\n   **/\n  event Initialized(\n    address indexed underlyingAsset,\n    address indexed pool,\n    address treasury,\n    address incentivesController,\n    uint8 aTokenDecimals,\n    string aTokenName,\n    string aTokenSymbol,\n    bytes params\n  );\n\n  /**\n   * @dev Initializes the aToken\n   * @param pool The address of the lending pool where this aToken will be used\n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @param incentivesController The smart contract managing potential incentives distribution\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n   * @param aTokenName The name of the aToken\n   * @param aTokenSymbol The symbol of the aToken\n   */\n  function initialize(\n    ILendingPool pool,\n    address treasury,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 aTokenDecimals,\n    string calldata aTokenName,\n    string calldata aTokenSymbol,\n    bytes calldata params\n  ) external;\n}\n"
    },
    "contracts/externalInterfaces/aave/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\ninterface IAaveIncentivesController {\n  event RewardsAccrued(address indexed user, uint256 amount);\n\n  event RewardsClaimed(address indexed user, address indexed to, uint256 amount);\n\n  event RewardsClaimed(\n    address indexed user,\n    address indexed to,\n    address indexed claimer,\n    uint256 amount\n  );\n\n  event ClaimerSet(address indexed user, address indexed claimer);\n\n  /*\n   * @dev Returns the configuration of the distribution for a certain asset\n   * @param asset The address of the reference asset of the distribution\n   * @return The asset index, the emission per second and the last updated timestamp\n   **/\n  function getAssetData(address asset)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  /*\n   * LEGACY **************************\n   * @dev Returns the configuration of the distribution for a certain asset\n   * @param asset The address of the reference asset of the distribution\n   * @return The asset index, the emission per second and the last updated timestamp\n   **/\n  function assets(address asset)\n    external\n    view\n    returns (\n      uint128,\n      uint128,\n      uint256\n    );\n\n  /**\n   * @dev Whitelists an address to claim the rewards on behalf of another address\n   * @param user The address of the user\n   * @param claimer The address of the claimer\n   */\n  function setClaimer(address user, address claimer) external;\n\n  /**\n   * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n   * @param user The address of the user\n   * @return The claimer address\n   */\n  function getClaimer(address user) external view returns (address);\n\n  /**\n   * @dev Configure assets for a certain rewards emission\n   * @param assets The assets to incentivize\n   * @param emissionsPerSecond The emission for each asset\n   */\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\n    external;\n\n  /**\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\n   * @param asset The address of the user\n   * @param userBalance The balance of the user of the asset in the lending pool\n   * @param totalSupply The total supply of the asset in the lending pool\n   **/\n  function handleAction(\n    address asset,\n    uint256 userBalance,\n    uint256 totalSupply\n  ) external;\n\n  /**\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n   * @param user The address of the user\n   * @return The rewards\n   **/\n  function getRewardsBalance(address[] calldata assets, address user)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n   * @param amount Amount of rewards to claim\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\n   * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n   * @param amount Amount of rewards to claim\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n  function claimRewardsOnBehalf(\n    address[] calldata assets,\n    uint256 amount,\n    address user,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev returns the unclaimed rewards of the user\n   * @param user the address of the user\n   * @return the unclaimed user rewards\n   */\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\n\n  /**\n   * @dev returns the unclaimed rewards of the user\n   * @param user the address of the user\n   * @param asset The asset to incentivize\n   * @return the user index for the asset\n   */\n  function getUserAssetData(address user, address asset) external view returns (uint256);\n\n  /**\n   * @dev for backward compatibility with previous implementation of the Incentives controller\n   */\n  function REWARD_TOKEN() external view returns (address);\n\n  /**\n   * @dev for backward compatibility with previous implementation of the Incentives controller\n   */\n  function PRECISION() external view returns (uint8);\n\n  /**\n   * @dev Gets the distribution end timestamp of the emissions\n   */\n  function DISTRIBUTION_END() external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/presets/ERC20PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../extensions/ERC20Burnable.sol\";\nimport \"../extensions/ERC20Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n */\ncontract ERC20PresetMinterPauser is Context, AccessControlEnumerable, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/mocks/token/TokenMock.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\n\n//used only for testing\ncontract TokenMock is ERC20PresetMinterPauser {\n    constructor(string memory name, string memory symbol) ERC20PresetMinterPauser(name, symbol) {}\n}\n"
    },
    "contracts/airdropV3/AirdropV3Implementation.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"./interfaces/AirdropV3StorageV1.sol\";\n\ncontract AirdropV3Implementation is\n    Initializable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    AirdropV3StorageV1\n{\n    /**\n     * @notice Triggered after a claim\n     *\n     * @param beneficiary         The address of the beneficiary that has claimed\n     * @param community           The address of the beneficiary's community\n     * @param amount              The amount to be registered as donation\n     */\n    event Registered(address indexed beneficiary, address indexed community, uint256 amount);\n\n    /**\n     * @notice Used to initialize a new Airdrop contract\n     *\n     * @param _donationMiner         The address of the DonationMiner\n     * @param _socialConnectAddress  The address of the socialConnect contract\n     * @param _socialConnectIssuer   The address of impactMarket issuer\n     * @param _amount                The amount to be registered as donation\n     */\n    function initialize(\n        address _donationMiner,\n        address _socialConnectAddress,\n        address _socialConnectIssuer,\n        uint256 _amount\n    ) public initializer {\n        __Ownable_init();\n        __Pausable_init();\n\n        donationMiner = IDonationMiner(_donationMiner);\n        socialConnect = ISocialConnect(_socialConnectAddress);\n        socialConnectIssuer = _socialConnectIssuer;\n        amount = _amount;\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice Updates the amount value\n     *\n     * @param _newAmount    the new amount value\n     */\n    function updateAmount(uint256 _newAmount) external override onlyOwner {\n        amount = _newAmount;\n    }\n\n    /**\n     * @notice Register new beneficiaries\n     *\n     * @param _beneficiaryAddresses    the addresses of the beneficiaries\n     * @param _communityAddresses      the addresses of the beneficiaries communities\n     */\n    function register(address[] memory _beneficiaryAddresses, address[] memory _communityAddresses)\n        external\n        override\n    {\n        uint256 _length = _beneficiaryAddresses.length;\n        require(_length == _communityAddresses.length, \"AirdropV3: Invalid data\");\n\n        ICommunity.BeneficiaryState _state;\n\n        for (uint256 _index; _index < _length; _index++) {\n            Beneficiary storage _beneficiary = beneficiaries[_beneficiaryAddresses[_index]];\n\n            require(_beneficiary.amount == 0, \"AirdropV3: Beneficiary already registered\");\n\n            require(\n                donationMiner.treasury().communityAdmin().communities(\n                    _communityAddresses[_index]\n                ) == ICommunityAdmin.CommunityState.Valid,\n                \"AirdropV3: Invalid community\"\n            );\n\n            (_state, , , ) = ICommunity(_communityAddresses[_index]).beneficiaries(\n                _beneficiaryAddresses[_index]\n            );\n            require(\n                _state == ICommunity.BeneficiaryState.Valid,\n                \"AirdropV3: Invalid beneficiary - community pair\"\n            );\n\n            require(\n                _isSocialConnectVerified(_beneficiaryAddresses[_index]),\n                \"AirdropV3: User has not been verified\"\n            );\n\n            _beneficiary.amount = amount;\n\n            donationMiner.donateVirtual(\n                amount,\n                _beneficiaryAddresses[_index]\n            );\n\n            emit Registered(_beneficiaryAddresses[_index], _communityAddresses[_index], amount);\n        }\n    }\n\n    function _isSocialConnectVerified(address _userAddress) internal view returns (bool) {\n        address[] memory _issuers = new address[](1);\n        _issuers[0] = address(socialConnectIssuer);\n        (uint256[] memory _countsPerIssuer, ) = socialConnect.lookupIdentifiers(\n            _userAddress,\n            _issuers\n        );\n\n        return _countsPerIssuer[0] > 0;\n    }\n}\n"
    },
    "contracts/airdropV3/interfaces/AirdropV3StorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./IAirdropV3.sol\";\n\n/**\n * @title Storage for AirdropV3\n * @notice For future upgrades, do not change AirdropV3StorageV1. Create a new\n * contract which implements AirdropV3StorageV1 and following the naming convention\n * AirdropV3StorageVx.\n */\nabstract contract AirdropV3StorageV1 is IAirdropV3 {\n    IDonationMiner public override donationMiner;\n    ISocialConnect public override socialConnect;\n    address public override socialConnectIssuer;\n\n    uint256 public override amount;\n\n    mapping(address => Beneficiary) public beneficiaries;\n}\n"
    },
    "contracts/airdropV2/AirdropV2Implementation.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"./interfaces/AirdropV2StorageV1.sol\";\n\ncontract AirdropV2Implementation is\n    Initializable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    AirdropV2StorageV1\n{\n    using SafeERC20Upgradeable for IERC20;\n\n    /**\n     * @notice Triggered after a claim\n     *\n     * @param beneficiary         The address of the beneficiary that has claimed\n     * @param amount              The amount of the claim\n     */\n    event Claimed(address indexed beneficiary, uint256 amount);\n\n    /**\n     * @notice Used to initialize a new Airdrop contract\n     *\n     * @param _PACTAddress      The address of the PACT token\n     * @param _startTime        The timestamp when the airdrop will be available\n     * @param _trancheAmount    The number of PACTs to be claimed in one transaction\n     * @param _totalAmount      The total number of PACTs to be claimed by a beneficiary\n     * @param _cooldown         The minimum number of seconds between two claims\n     * @param _merkleRoot       The root of the merkle tree\n     */\n    function initialize(\n        address _PACTAddress,\n        uint256 _startTime,\n        uint256 _trancheAmount,\n        uint256 _totalAmount,\n        uint256 _cooldown,\n        bytes32 _merkleRoot\n    ) public initializer {\n        __Ownable_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        PACT = IERC20(_PACTAddress);\n        startTime = _startTime;\n        trancheAmount = _trancheAmount;\n        totalAmount = _totalAmount;\n        cooldown = _cooldown;\n        merkleRoot = _merkleRoot;\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice Updates the startTime value\n     *\n     * @param _newStartTime the new start timestamp\n     */\n    function updateStartTime(uint256 _newStartTime) external override onlyOwner {\n        startTime = _newStartTime;\n    }\n\n    /**\n     * @notice Updates the trancheAmount value\n     *\n     * @param _newTrancheAmount the new trancheAmount\n     */\n    function updateTrancheAmount(uint256 _newTrancheAmount) external override onlyOwner {\n        trancheAmount = _newTrancheAmount;\n    }\n\n    /**\n     * @notice Updates the totalAmount value\n     *\n     * @param _newTotalAmount the new totalAmount\n     */\n    function updateTotalAmount(uint256 _newTotalAmount) external override onlyOwner {\n        totalAmount = _newTotalAmount;\n    }\n\n    /**\n     * @notice Updates the cooldown value\n     *\n     * @param _newCooldown the new cooldown timestamp\n     */\n    function updateCooldown(uint256 _newCooldown) external override onlyOwner {\n        cooldown = _newCooldown;\n    }\n\n    /**\n     * @notice Updates the merkleRoot\n     *\n     * @param _newMerkleRoot the new merkleRoot\n     */\n    function updateMerkleRoot(bytes32 _newMerkleRoot) external override onlyOwner {\n        merkleRoot = _newMerkleRoot;\n    }\n\n    /**\n     * @notice Transfers PACTs to a beneficiary\n     *\n     * @param _beneficiaryAddress the address of the beneficiary\n     * @param _merkleProof the proof vor validating the beneficiary\n     */\n    function claim(address _beneficiaryAddress, bytes32[] calldata _merkleProof) external override {\n        require(startTime <= block.timestamp, \"AirdropV2Implementation::claim: Not yet\");\n\n        Beneficiary storage _beneficiary = beneficiaries[_beneficiaryAddress];\n\n        //we have to check if the address is a beneficiary only first time\n        if (_beneficiary.claimedAmount == 0) {\n            // Verify the merkle proof.\n            bytes32 _leafToCheck = keccak256(abi.encodePacked(_beneficiaryAddress));\n            require(\n                MerkleProof.verify(_merkleProof, merkleRoot, _leafToCheck),\n                \"AirdropV2Implementation::claim: Incorrect proof\"\n            );\n        }\n\n        require(\n            _beneficiary.lastClaimTime + cooldown <= block.timestamp,\n            \"AirdropV2Implementation::claim: Not yet\"\n        );\n\n        require(\n            _beneficiary.claimedAmount < totalAmount,\n            \"AirdropV2Implementation::claim: Beneficiary's claimed all amount\"\n        );\n\n        uint256 _toClaim = totalAmount - _beneficiary.claimedAmount;\n\n        uint256 _claimAmount = _toClaim > trancheAmount ? trancheAmount : _toClaim;\n\n        _beneficiary.claimedAmount += _claimAmount;\n        _beneficiary.lastClaimTime = block.timestamp;\n\n        // Send the token\n        PACT.safeTransfer(_beneficiaryAddress, _claimAmount);\n\n        emit Claimed(_beneficiaryAddress, _claimAmount);\n    }\n}\n"
    },
    "contracts/airdropV2/interfaces/AirdropV2StorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./IAirdropV2.sol\";\n\n/**\n * @title Storage for Deposit\n * @notice For future upgrades, do not change DepositStorageV1. Create a new\n * contract which implements DepositStorageV1 and following the naming convention\n * DepositStorageVx.\n */\nabstract contract AirdropV2StorageV1 is IAirdropV2 {\n    IERC20 public override PACT;\n    bytes32 public override merkleRoot;\n\n    uint256 public override startTime;\n    uint256 public override trancheAmount;\n    uint256 public override totalAmount;\n    uint256 public override cooldown;\n\n    mapping(address => Beneficiary) public beneficiaries;\n}\n"
    },
    "contracts/airdropV2/interfaces/IAirdropV2.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IAirdropV2 {\n    struct Beneficiary {\n        uint256 claimedAmount;\n        uint256 lastClaimTime;\n    }\n\n    function getVersion() external pure returns(uint256);\n    function PACT() external view returns(IERC20);\n    function startTime() external view returns(uint256);\n    function trancheAmount() external view returns(uint256);\n    function totalAmount() external view returns(uint256);\n    function cooldown() external view returns(uint256);\n    function merkleRoot() external view returns(bytes32);\n\n    function updateStartTime(uint256 _newStartTime) external;\n    function updateTrancheAmount(uint256 _newTrancheAmount) external;\n    function updateTotalAmount(uint256 _newTotalAmount) external;\n    function updateCooldown(uint256 _newCooldown) external;\n    function updateMerkleRoot(bytes32 _newMerkleRoot) external;\n\n    function claim(\n        address _beneficiaryAddress,\n        bytes32[] calldata _merkleProof\n    ) external;\n}\n"
    },
    "contracts/mocks/community/CommunityAdminImplementationOld.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./interfaces/ICommunity.sol\";\nimport \"./interfaces/CommunityAdminStorageV1.sol\";\n\n/**\n * @notice Welcome to CommunityAdmin, the main contract. This is an\n * administrative (for now) contract where the admins have control\n * over the list of communities. Being only able to add and\n * remove communities\n */\ncontract CommunityAdminImplementationOld is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    CommunityAdminStorageV1\n{\n    using SafeERC20Upgradeable for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant DEFAULT_AMOUNT = 5e16;\n    uint256 private constant TREASURY_SAFETY_FACTOR = 10;\n\n    /**\n     * @notice Triggered when a community has been added\n     *\n     * @param communityAddress  Address of the community that has been added\n     * @param managers          Addresses of the initial managers\n     * @param claimAmount       Value of the claimAmount\n     * @param maxClaim          Value of the maxClaim\n     * @param decreaseStep      Value of the decreaseStep\n     * @param baseInterval      Value of the baseInterval\n     * @param incrementInterval Value of the incrementInterval\n     * @param minTranche        Value of the minTranche\n     * @param maxTranche        Value of the maxTranche\n     *\n     * For further information regarding each parameter, see\n     * *Community* smart contract initialize method.\n     */\n    event CommunityAdded(\n        address indexed communityAddress,\n        address[] managers,\n        uint256 claimAmount,\n        uint256 maxClaim,\n        uint256 decreaseStep,\n        uint256 baseInterval,\n        uint256 incrementInterval,\n        uint256 minTranche,\n        uint256 maxTranche\n    );\n\n    /**\n     * @notice Triggered when a community has been removed\n     *\n     * @param communityAddress  Address of the community that has been removed\n     */\n    event CommunityRemoved(address indexed communityAddress);\n\n    /**\n     * @notice Triggered when a community has been migrated\n     *\n     * @param managers                 Addresses of the new community's initial managers\n     * @param communityAddress         New community address\n     * @param previousCommunityAddress Old community address\n     */\n    event CommunityMigrated(\n        address[] managers,\n        address indexed communityAddress,\n        address indexed previousCommunityAddress\n    );\n\n    /**\n     * @notice Triggered when the treasury address has been updated\n     *\n     * @param oldTreasury             Old treasury address\n     * @param newTreasury             New treasury address\n     */\n    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    /**\n     * @notice Triggered when the communityTemplate address has been updated\n     *\n     * @param oldCommunityTemplate    Old communityTemplate address\n     * @param newCommunityTemplate    New communityTemplate address\n     */\n    event CommunityTemplateUpdated(\n        address indexed oldCommunityTemplate,\n        address indexed newCommunityTemplate\n    );\n\n    /**\n     * @notice Triggered when a community has been funded\n     *\n     * @param community           Address of the community\n     * @param amount              Amount of the funding\n     */\n    event CommunityFunded(address indexed community, uint256 amount);\n\n    /**\n     * @notice Triggered when an amount of an ERC20 has been transferred from this contract to an address\n     *\n     * @param token               ERC20 token address\n     * @param to                  Address of the receiver\n     * @param amount              Amount of the transaction\n     */\n    event TransferERC20(address indexed token, address indexed to, uint256 amount);\n\n    /**\n     * @notice Enforces sender to be a valid community\n     */\n    modifier onlyCommunities() {\n        require(communities[msg.sender] == CommunityState.Valid, \"CommunityAdmin: NOT_COMMUNITY\");\n        _;\n    }\n\n    /**\n     * @notice Used to initialize a new CommunityAdmin contract\n     *\n     * @param _communityTemplate    Address of the Community implementation\n     *                              used for deploying new communities\n     * @param _cUSD                 Address of the cUSD token\n     */\n    function initialize(ICommunity _communityTemplate, IERC20 _cUSD) external initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        communityTemplate = _communityTemplate;\n        cUSD = _cUSD;\n\n        communityProxyAdmin = new ProxyAdmin();\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice Returns the address of a community from communityList\n     *\n     * @param _index index of the community\n     * @return address of the community\n     */\n    function communityListAt(uint256 _index) external view override returns (address) {\n        return communityList.at(_index);\n    }\n\n    /**\n     * @notice Returns the number of communities\n     *\n     * @return uint256 number of communities\n     */\n    function communityListLength() external view override returns (uint256) {\n        return communityList.length();\n    }\n\n    /**\n     * @notice Updates the address of the treasury\n     *\n     * @param _newTreasury address of the new treasury contract\n     */\n    function updateTreasury(ITreasury _newTreasury) external override onlyOwner {\n        address oldTreasuryAddress = address(treasury);\n        treasury = _newTreasury;\n\n        emit TreasuryUpdated(oldTreasuryAddress, address(_newTreasury));\n    }\n\n    /**\n     * @notice Updates the address of the the communityTemplate\n     *\n     * @param _newCommunityTemplate address of the new communityTemplate contract\n     */\n    function updateCommunityTemplate(ICommunity _newCommunityTemplate) external override onlyOwner {\n        address _oldCommunityTemplateAddress = address(communityTemplate);\n        communityTemplate = _newCommunityTemplate;\n\n        emit CommunityTemplateUpdated(_oldCommunityTemplateAddress, address(_newCommunityTemplate));\n    }\n\n    /**\n     * @notice Adds a new community\n     *\n     * @param _managers addresses of the community managers\n     * @param _claimAmount base amount to be claim by the beneficiary\n     * @param _maxClaim limit that a beneficiary can claim at in total\n     * @param _decreaseStep value decreased from maxClaim for every beneficiary added\n     * @param _baseInterval base interval to start claiming\n     * @param _incrementInterval increment interval used in each claim\n     * @param _minTranche minimum amount that the community will receive when requesting funds\n     * @param _maxTranche maximum amount that the community will receive when requesting funds\n     */\n    function addCommunity(\n        address[] memory _managers,\n        uint256 _claimAmount,\n        uint256 _maxClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval,\n        uint256 _minTranche,\n        uint256 _maxTranche\n    ) external override onlyOwner {\n        require(\n            _managers.length > 0,\n            \"CommunityAdmin::addCommunity: Community should have at least one manager\"\n        );\n        address _communityAddress = deployCommunity(\n            _managers,\n            _claimAmount,\n            _maxClaim,\n            _decreaseStep,\n            _baseInterval,\n            _incrementInterval,\n            _minTranche,\n            _maxTranche,\n            ICommunity(address(0))\n        );\n        require(_communityAddress != address(0), \"CommunityAdmin::addCommunity: NOT_VALID\");\n        communities[_communityAddress] = CommunityState.Valid;\n        communityList.add(_communityAddress);\n\n        emit CommunityAdded(\n            _communityAddress,\n            _managers,\n            _claimAmount,\n            _maxClaim,\n            _decreaseStep,\n            _baseInterval,\n            _incrementInterval,\n            _minTranche,\n            _maxTranche\n        );\n\n        transferToCommunity(ICommunity(_communityAddress), _minTranche);\n        treasury.transfer(cUSD, address(_managers[0]), DEFAULT_AMOUNT);\n    }\n\n    /**\n     * @notice Migrates a community by deploying a new contract.\n     *\n     * @param _managers address of the community managers\n     * @param _previousCommunity address of the community to be migrated\n     */\n    function migrateCommunity(address[] memory _managers, ICommunity _previousCommunity)\n        external\n        override\n        onlyOwner\n        nonReentrant\n    {\n        require(\n            communities[address(_previousCommunity)] != CommunityState.Migrated,\n            \"CommunityAdmin::migrateCommunity: this community has been migrated\"\n        );\n\n        communities[address(_previousCommunity)] = CommunityState.Migrated;\n\n        bool _isCommunityNew = isCommunityNewType(_previousCommunity);\n\n        address newCommunityAddress;\n        if (_isCommunityNew) {\n            newCommunityAddress = deployCommunity(\n                _managers,\n                _previousCommunity.claimAmount(),\n                _previousCommunity.getInitialMaxClaim(),\n                _previousCommunity.decreaseStep(),\n                _previousCommunity.baseInterval(),\n                _previousCommunity.incrementInterval(),\n                _previousCommunity.minTranche(),\n                _previousCommunity.maxTranche(),\n                _previousCommunity\n            );\n        } else {\n            newCommunityAddress = deployCommunity(\n                _managers,\n                _previousCommunity.claimAmount(),\n                _previousCommunity.maxClaim(),\n                1e16,\n                (_previousCommunity.baseInterval() / 5),\n                (_previousCommunity.incrementInterval() / 5),\n                1e16,\n                5e18,\n                _previousCommunity\n            );\n        }\n\n        require(newCommunityAddress != address(0), \"CommunityAdmin::migrateCommunity: NOT_VALID\");\n\n        if (_isCommunityNew) {\n            uint256 balance = cUSD.balanceOf(address(_previousCommunity));\n            _previousCommunity.transfer(cUSD, newCommunityAddress, balance);\n        }\n\n        communities[newCommunityAddress] = CommunityState.Valid;\n        communityList.add(newCommunityAddress);\n\n        emit CommunityMigrated(_managers, newCommunityAddress, address(_previousCommunity));\n    }\n\n    /**\n     * @notice Adds a new manager to a community\n     *\n     * @param _community address of the community\n     * @param _account address to be added as community manager\n     */\n    function addManagerToCommunity(ICommunity _community, address _account)\n        external\n        override\n        onlyOwner\n    {\n        _community.addManager(_account);\n    }\n\n    /**\n     * @notice Removes an existing community. All community funds are transferred to the treasury\n     *\n     * @param _community address of the community\n     */\n    function removeCommunity(ICommunity _community) external override onlyOwner nonReentrant {\n        require(\n            communities[address(_community)] == CommunityState.Valid,\n            \"CommunityAdmin::removeCommunity: this isn't a valid community\"\n        );\n        communities[address(_community)] = CommunityState.Removed;\n\n        _community.transfer(cUSD, address(treasury), cUSD.balanceOf(address(_community)));\n        emit CommunityRemoved(address(_community));\n    }\n\n    /**\n     * @dev Funds an existing community if it hasn't enough funds\n     */\n    function fundCommunity() external override onlyCommunities {\n        ICommunity _community = ICommunity(msg.sender);\n        uint256 _balance = cUSD.balanceOf(msg.sender);\n        require(\n            _balance < _community.minTranche(),\n            \"CommunityAdmin::fundCommunity: this community has enough funds\"\n        );\n        require(\n            block.number > _community.lastFundRequest() + _community.baseInterval(),\n            \"CommunityAdmin::fundCommunity: this community is not allowed to request yet\"\n        );\n\n        uint256 _trancheAmount = calculateCommunityTrancheAmount(ICommunity(msg.sender));\n\n        if (_trancheAmount > _balance) {\n            uint256 _amount = _trancheAmount - _balance;\n            uint256 _treasurySafetyBalance = cUSD.balanceOf(address(treasury)) /\n                TREASURY_SAFETY_FACTOR;\n            require(\n                _amount <= _treasurySafetyBalance,\n                \"CommunityAdmin::fundCommunity: Not enough funds\"\n            );\n            transferToCommunity(_community, _amount);\n        }\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from this contract to an address\n     *\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyOwner nonReentrant {\n        _token.safeTransfer(_to, _amount);\n\n        emit TransferERC20(address(_token), _to, _amount);\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from  community to an address\n     *\n     * @param _community address of the community\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transferFromCommunity(\n        ICommunity _community,\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyOwner nonReentrant {\n        _community.transfer(_token, _to, _amount);\n    }\n\n    /** @notice Updates the beneficiary params of a community\n     *\n     * @param _community address of the community\n     * @param _claimAmount  base amount to be claim by the beneficiary\n     * @param _maxClaim limit that a beneficiary can claim  in total\n     * @param _decreaseStep value decreased from maxClaim each time a is beneficiary added\n     * @param _baseInterval base interval to start claiming\n     * @param _incrementInterval increment interval used in each claim\n     */\n    function updateBeneficiaryParams(\n        ICommunity _community,\n        uint256 _claimAmount,\n        uint256 _maxClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval\n    ) external override onlyOwner {\n        _community.updateBeneficiaryParams(\n            _claimAmount,\n            _maxClaim,\n            _decreaseStep,\n            _baseInterval,\n            _incrementInterval\n        );\n    }\n\n    /** @notice Updates params of a community\n     *\n     * @param _community address of the community\n     * @param _minTranche minimum amount that the community will receive when requesting funds\n     * @param _maxTranche maximum amount that the community will receive when requesting funds\n     */\n    function updateCommunityParams(\n        ICommunity _community,\n        uint256 _minTranche,\n        uint256 _maxTranche\n    ) external override onlyOwner {\n        _community.updateCommunityParams(_minTranche, _maxTranche);\n    }\n\n    /**\n     * @notice Updates proxy implementation address of a community\n     *\n     * @param _communityProxy address of the community\n     * @param _newCommunityTemplate address of new implementation contract\n     */\n    function updateProxyImplementation(address _communityProxy, address _newCommunityTemplate)\n        external\n        override\n        onlyOwner\n    {\n        communityProxyAdmin.upgrade(\n            TransparentUpgradeableProxy(payable(_communityProxy)),\n            _newCommunityTemplate\n        );\n    }\n\n    /**\n     * @dev Transfers cUSDs from the treasury to a community\n     *\n     * @param _community address of the community\n     * @param _amount amount of the transaction\n     */\n    function transferToCommunity(ICommunity _community, uint256 _amount) internal nonReentrant {\n        treasury.transfer(cUSD, address(_community), _amount);\n        _community.addTreasuryFunds(_amount);\n\n        emit CommunityFunded(address(_community), _amount);\n    }\n\n    /**\n     * @dev Internal implementation of deploying a new community\n     *\n     * @param _managers addresses of the community managers\n     * @param _claimAmount base amount to be claim by the beneficiary\n     * @param _maxClaim limit that a beneficiary can claim at in total\n     * @param _decreaseStep value decreased from maxClaim for every beneficiary added\n     * @param _baseInterval base interval to start claiming\n     * @param _incrementInterval increment interval used in each claim\n     * @param _minTranche minimum amount that the community will receive when requesting funds\n     * @param _maxTranche maximum amount that the community will receive when requesting funds\n     * @param _previousCommunity address of the previous community. Used for migrating communities\n     */\n    function deployCommunity(\n        address[] memory _managers,\n        uint256 _claimAmount,\n        uint256 _maxClaim,\n        uint256 _decreaseStep,\n        uint256 _baseInterval,\n        uint256 _incrementInterval,\n        uint256 _minTranche,\n        uint256 _maxTranche,\n        ICommunity _previousCommunity\n    ) internal returns (address) {\n        TransparentUpgradeableProxy _community = new TransparentUpgradeableProxy(\n            address(communityTemplate),\n            address(communityProxyAdmin),\n            abi.encodeWithSignature(\n                \"initialize(address[],uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)\",\n                _managers,\n                _claimAmount,\n                _maxClaim,\n                _decreaseStep,\n                _baseInterval,\n                _incrementInterval,\n                _minTranche,\n                _maxTranche,\n                address(_previousCommunity)\n            )\n        );\n\n        return address(_community);\n    }\n\n    /** @dev Calculates the tranche amount of a community.\n     *        Enforces the tranche amount to be between community minTranche and maxTranche\n     * @param _community address of the community\n     * @return uint256 the value of the tranche amount\n     */\n    function calculateCommunityTrancheAmount(ICommunity _community)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _validBeneficiaries = _community.validBeneficiaryCount();\n        uint256 _claimAmount = _community.claimAmount();\n        uint256 _treasuryFunds = _community.treasuryFunds();\n        uint256 _privateFunds = _community.privateFunds();\n        uint256 _minTranche = _community.minTranche();\n        uint256 _maxTranche = _community.maxTranche();\n\n        // `treasuryFunds` can't be zero.\n        // Otherwise, migrated communities will have zero.\n        _treasuryFunds = _treasuryFunds > 0 ? _treasuryFunds : 1e18;\n\n        uint256 _trancheAmount = (_validBeneficiaries *\n            _claimAmount *\n            (_treasuryFunds + _privateFunds)) / _treasuryFunds;\n\n        if (_trancheAmount < _minTranche) {\n            _trancheAmount = _minTranche;\n        } else if (_trancheAmount > _maxTranche) {\n            _trancheAmount = _maxTranche;\n        }\n\n        return _trancheAmount;\n    }\n\n    /**\n     * @notice Checks if a community is deployed with the new type of smart contract\n     *\n     * @param _community address of the community\n     * @return bool true if the community is deployed with the new type of smart contract\n     */\n    function isCommunityNewType(ICommunity _community) internal pure returns (bool) {\n        return _community.impactMarketAddress() == address(0);\n    }\n}\n"
    },
    "contracts/vesting/ImpactLabsVestingProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract ImpactLabsVestingProxy is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/treasuryLpSwap/TreasuryLpSwapProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract TreasuryLpSwapProxy is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/treasury/TreasuryProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract TreasuryProxy is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/staking/StakingProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract StakingProxy is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/referralLink/ReferralLinkProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract ReferralLinkProxy is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/microcredit/MicrocreditRevenueProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract MicrocreditRevenueProxy is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/microcredit/MicrocreditProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract MicrocreditProxy is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/learnAndEarn/LearnAndEarnProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract LearnAndEarnProxy is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/governor/PACTDelegator.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract PACTDelegator is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/governor/impactMarketCouncil/ImpactMarketCouncilProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract ImpactMarketCouncilProxy is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/governor/impactMarketCouncil/ImpactMarketCouncilImplementation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./interfaces/ImpactMarketCouncilStorageV1.sol\";\n\ncontract ImpactMarketCouncilImplementation is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ImpactMarketCouncilStorageV1\n{\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 518400; // About 30 days\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant PROPOSAL_MAX_OPERATIONS = 10; // 10 actions\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 endBlock,\n        string description\n    );\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    /// @param voter The address which casted a vote\n    /// @param proposalId The proposal id which was voted on\n    /// @param support Support value for the vote. 0=against, 1=for, 2=abstain\n    /// @param votes Number of votes which were cast by the voter\n    /// @param reason The reason given for the vote by the voter\n    event VoteCast(\n        address indexed voter,\n        uint256 proposalId,\n        uint8 support,\n        uint256 votes,\n        string reason\n    );\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    /// @notice Emitted when implementation is changed\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /// @notice An event emitted when the quorum votes is set\n    event QuorumVotesSet(uint256 oldQuorumVotes, uint256 newQuorumVotes);\n\n    /// @notice An event emitted when a member is added\n    event MemberAdded(address member);\n\n    /// @notice An event emitted when a member is removed\n    event MemberRemoved(address member);\n\n    /**\n     * @notice Triggered when an amount of an ERC20 has been transferred from this contract to an address\n     *\n     * @param token               ERC20 token address\n     * @param to                  Address of the receiver\n     * @param amount              Amount of the transaction\n     */\n    event TransferERC20(address indexed token, address indexed to, uint256 amount);\n\n    modifier onlyMember() {\n        require(members[msg.sender] == true, \"PACT:: Not a member\");\n        _;\n    }\n\n    /**\n     * @notice Used to initialize the contract during delegator constructor\n     * @param _quorumVotes The initial quorum votes\n     */\n    function initialize(\n        uint256 _quorumVotes,\n        ICommunityAdmin _communityAdmin,\n        address[] calldata _members\n    ) public initializer {\n        require(_quorumVotes >= 1, \"PACT::initialize: invalid proposal threshold\");\n        require(_quorumVotes <= _members.length, \"PACT::initialize: params mismatch\");\n\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        communityProxyAdmin = new ProxyAdmin();\n        communityAdmin = _communityAdmin;\n        quorumVotes = _quorumVotes;\n\n        // Create dummy proposal\n        Proposal memory _dummyProposal = Proposal({\n            id: proposalCount,\n            proposer: address(this),\n            endBlock: 0,\n            forVotes: 0,\n            againstVotes: 0,\n            abstainVotes: 0,\n            canceled: true,\n            executed: false\n        });\n        proposalCount++;\n\n        proposals[_dummyProposal.id] = _dummyProposal;\n        latestProposalIds[_dummyProposal.proposer] = _dummyProposal.id;\n\n        uint256 _index;\n        uint256 _numberOfMembers = _members.length;\n        for (; _index < _numberOfMembers; _index++) {\n            members[_members[_index]] = true;\n            emit MemberAdded(_members[_index]);\n        }\n\n        emit ProposalCreated(\n            _dummyProposal.id,\n            address(this),\n            proposalTargets[_dummyProposal.id],\n            proposalSignatures[_dummyProposal.id],\n            proposalCalldatas[_dummyProposal.id],\n            0,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Function used to add new members to the impactMarket Council.\n     * @param _member Member address.\n     */\n    function addMember(address _member) external onlyOwner {\n        require(members[_member] == false, \"PACT::addMember: already a member\");\n\n        members[_member] = true;\n\n        emit MemberAdded(_member);\n    }\n\n    /**\n     * @notice Function used to remove members from the impactMarket Council.\n     * @param _member Member address.\n     */\n    function removeMember(address _member) external onlyOwner {\n        require(members[_member] == true, \"PACT::removeMember: not a member\");\n\n        members[_member] = false;\n\n        emit MemberRemoved(_member);\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold.\n     * @param _targets Target addresses for proposal calls.\n     * @param _signatures Function signatures for proposal calls.\n     * @param _calldatas Calldatas for proposal calls.\n     * @param _description String description of the proposal.\n     * @return Proposal id of new proposal.\n     */\n    function propose(\n        address[] memory _targets,\n        string[] memory _signatures,\n        bytes[] memory _calldatas,\n        string memory _description\n    ) external onlyMember returns (uint256) {\n        require(\n            _targets.length == _calldatas.length &&\n            _signatures.length == _calldatas.length,\n            \"PACT::propose: proposal function information arity mismatch\"\n        );\n        require(_signatures.length != 0, \"PACT::propose: must provide actions\");\n        require(_signatures.length <= PROPOSAL_MAX_OPERATIONS, \"PACT::propose: too many actions\");\n\n        uint256 _endBlock = add256(block.number, MAX_VOTING_PERIOD); // (518400) 30 days\n\n        Proposal memory _newProposal = Proposal({\n            id: proposalCount,\n            proposer: msg.sender,\n            endBlock: _endBlock,\n            forVotes: 0,\n            againstVotes: 0,\n            abstainVotes: 0,\n            canceled: false,\n            executed: false\n        });\n        proposalCount++;\n\n        proposals[_newProposal.id] = _newProposal;\n        proposalTargets[_newProposal.id] = _targets;\n        proposalSignatures[_newProposal.id] = _signatures;\n        proposalCalldatas[_newProposal.id] = _calldatas;\n        latestProposalIds[_newProposal.proposer] = _newProposal.id;\n\n        emit ProposalCreated(\n            _newProposal.id,\n            msg.sender,\n            _targets,\n            _signatures,\n            _calldatas,\n            _endBlock,\n            _description\n        );\n        return _newProposal.id;\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param _proposalId The id of the proposal to execute\n     */\n    function execute(uint256 _proposalId) external onlyMember payable {\n        require(\n            state(_proposalId) == ProposalState.Succeeded,\n            \"PACT::execute: proposal can only be executed if it is succeeded\"\n        );\n        Proposal storage _proposal = proposals[_proposalId];\n        _proposal.executed = true;\n        uint256 _i;\n        uint256 _numberOfActions = proposalCalldatas[_proposalId].length;\n        for (; _i < _numberOfActions; _i++) {\n            bytes memory _callData;\n            if (bytes(proposalSignatures[_proposalId][_i]).length == 0) {\n                _callData = proposalCalldatas[_proposalId][_i];\n            } else {\n                _callData = abi.encodePacked(\n                    bytes4(keccak256(bytes(proposalSignatures[_proposalId][_i]))),\n                    proposalCalldatas[_proposalId][_i]\n                );\n            }\n\n            // solium-disable-next-line security/no-call-value\n            (bool _success, ) = proposalTargets[_proposalId][_i].call{value: 0}(_callData);\n            require(_success, \"PACT::execute: Transaction execution reverted.\");\n        }\n        emit ProposalExecuted(_proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param _proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 _proposalId) external onlyMember {\n        require(\n            state(_proposalId) != ProposalState.Executed,\n            \"PACT::cancel: cannot cancel executed proposal\"\n        );\n\n        Proposal storage _proposal = proposals[_proposalId];\n        require(msg.sender == _proposal.proposer, \"PACT::cancel: proposer not allowed\");\n\n        _proposal.canceled = true;\n\n        emit ProposalCanceled(_proposalId);\n    }\n\n    /**\n     * @notice Gets actions of a proposal.\n     * @param _proposalId Proposal to query.\n     * @return signatures Function signatures for proposal calls.\n     * @return calldatas Calldatas for proposal calls.\n     */\n    function getActions(uint256 _proposalId)\n        external\n        view\n        returns (string[] memory signatures, bytes[] memory calldatas)\n    {\n        return (proposalSignatures[_proposalId], proposalCalldatas[_proposalId]);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param _proposalId the id of proposal\n     * @param _voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 _proposalId, address _voter)\n        external\n        view\n        returns (Receipt memory)\n    {\n        return proposalReceipts[_proposalId][_voter];\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param _proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 _proposalId) public view returns (ProposalState) {\n        require(proposalCount > _proposalId, \"PACT::state: invalid proposal id\");\n        Proposal storage _proposal = proposals[_proposalId];\n\n        if (_proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (_proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.number > _proposal.endBlock) {\n            return ProposalState.Expired;\n        } else if (\n            _proposal.forVotes > _proposal.againstVotes && _proposal.forVotes >= quorumVotes\n        ) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Active;\n        }\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param _proposalId The id of the proposal to vote on\n     * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 _proposalId, uint8 _support) external onlyMember {\n        emit VoteCast(\n            msg.sender,\n            _proposalId,\n            _support,\n            castVoteInternal(msg.sender, _proposalId, _support),\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param _voter The voter that is casting their vote\n     * @param _proposalId The id of the proposal to vote on\n     * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(\n        address _voter,\n        uint256 _proposalId,\n        uint8 _support\n    ) internal returns (uint96) {\n        require(\n            state(_proposalId) == ProposalState.Active,\n            \"PACT::castVoteInternal: voting is closed\"\n        );\n        require(_support <= 2, \"PACT::castVoteInternal: invalid vote type\");\n        Proposal storage _proposal = proposals[_proposalId];\n        Receipt storage _receipt = proposalReceipts[_proposalId][_voter];\n        require(_receipt.hasVoted == false, \"PACT::castVoteInternal: voter already voted\");\n        uint96 _votes = 1;\n\n        if (_support == 0) {\n            _proposal.againstVotes = add256(_proposal.againstVotes, _votes);\n        } else if (_support == 1) {\n            _proposal.forVotes = add256(_proposal.forVotes, _votes);\n        } else if (_support == 2) {\n            _proposal.abstainVotes = add256(_proposal.abstainVotes, _votes);\n        }\n\n        _receipt.hasVoted = true;\n        _receipt.support = _support;\n        _receipt.votes = _votes;\n\n        return _votes;\n    }\n\n    /**\n     * @notice Owner function for setting the quorum votes\n     * @param _newQuorumVotes new quorum votes\n     */\n    function setQuorumVotes(uint256 _newQuorumVotes) external onlyOwner {\n        require(_newQuorumVotes >= 1, \"PACT::_setQuorumVotes: invalid quorum votes\");\n\n        emit QuorumVotesSet(quorumVotes, _newQuorumVotes);\n        quorumVotes = _newQuorumVotes;\n\n    }\n\n    function add256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 _c = _a + _b;\n        require(_c >= _a, \"addition overflow\");\n        return _c;\n    }\n\n    function sub256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, \"subtraction underflow\");\n        return _a - _b;\n    }\n\n    function add96(\n        uint96 _a,\n        uint96 _b,\n        string memory _errorMessage\n    ) internal pure returns (uint96) {\n        uint96 _c = _a + _b;\n        require(_c >= _a, _errorMessage);\n        return _c;\n    }\n}\n"
    },
    "contracts/donationMiner/DonationMinerProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract DonationMinerProxy is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/deposit/DepositProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract DepositProxy is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/externalInterfaces/openzeppelin/IProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ninterface IProxyAdmin {\n    function getProxyImplementation(TransparentUpgradeableProxy proxy)\n        external\n        view\n        virtual\n        returns (address);\n\n    function getProxyAdmin(TransparentUpgradeableProxy proxy)\n        external\n        view\n        virtual\n        returns (address);\n\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) external virtual;\n\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) external virtual;\n\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) external payable virtual;\n\n    function owner() external view virtual returns (address);\n}\n"
    },
    "contracts/community/CommunityMiddleProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"./interfaces/ICommunityAdmin.sol\";\nimport \"../externalInterfaces/openzeppelin/IProxyAdmin.sol\";\nimport \"../externalInterfaces/openzeppelin/ITransparentUpgradeableProxy.sol\";\n\ncontract CommunityMiddleProxy is TransparentUpgradeableProxy {\n    /** @notice Calls the TransparentUpgradeableProxy constructor\n     *\n     * @param _fakeLogic       any contract address\n     * @param _fakeProxyAdmin  any address\n     *\n     * @dev _fakeLogic, _fakeProxyAdmin are used only\n     *     to satisfy the TransparentUpgradeableProxy requirements.\n     *     Their values are not important because this is a middle proxy contract\n     *     the real logic and proxy admin values are stored into the CommunityProxy\n     */\n    constructor(address _fakeLogic, address _fakeProxyAdmin)\n        TransparentUpgradeableProxy(_fakeLogic, _fakeProxyAdmin, \"\")\n    {}\n\n    /**\n     * @notice Returns the community implementation address.\n     *\n     * @dev this is a custom method that gets the community implementation address from the CommunityAdmin\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        // Admin of the CommunityProxy is CommunityAdmin.communityProxyAdmin\n        // the owner of CommunityAdmin.communityProxyAdmin is CommunityAdmin\n        // so:\n        // CommunityAdmin.communityProxyAdmin = IProxyAdmin(_admin())\n        // CommunityAdmin = (CommunityAdmin.communityProxyAdmin).owner = (IProxyAdmin(_admin())).owner()\n        // communityImplementation = CommunityAdmin.communityImplementation\n        // communityImplementation = ICommunityAdmin(IProxyAdmin(_admin()).owner()).communityImplementation()\n        return address(ICommunityAdmin(IProxyAdmin(_admin()).owner()).communityImplementation());\n    }\n}\n"
    },
    "contracts/externalInterfaces/openzeppelin/ITransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\ninterface ITransparentUpgradeableProxy {\n    function admin() external view returns (address admin_);\n\n    function implementation() external returns (address implementation_);\n\n    function changeAdmin(address newAdmin) external virtual;\n\n    function upgradeTo(address newImplementation) external;\n\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;\n}\n"
    },
    "contracts/community/CommunityAdminProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract CommunityAdminProxy is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/ambassadors/AmbassadorsProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract AmbassadorsProxy is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/ambassadors/AmbassadorsImplementation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./interfaces/AmbassadorsStorageV1.sol\";\nimport \"../community/interfaces/ICommunityAdmin.sol\";\n\n/**\n * @notice Welcome to Ambassadors contract.\n */\ncontract AmbassadorsImplementation is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    AmbassadorsStorageV1\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /**\n     * @notice Triggered when an entity is added.\n     *\n     * @param entity Address of the entity added\n     *\n     */\n    event EntityAdded(address indexed entity);\n\n    /**\n     * @notice Triggered when an entity is removed.\n     *\n     * @param entity Address of the entity removed\n     *\n     */\n    event EntityRemoved(address indexed entity);\n\n    /**\n     * @notice Triggered when an entity replaced account address.\n     *\n     * @param entityIndex Entity index replacing account address\n     * @param oldAccount Old account address\n     * @param newAccount New account address\n     *\n     */\n    event EntityAccountReplaced(\n        uint256 entityIndex,\n        address indexed oldAccount,\n        address indexed newAccount\n    );\n\n    /**\n     * @notice Triggered when an ambassador is added to an entity.\n     *\n     * @param ambassador Address of the ambassador added\n     * @param entity Address of the entity where the ambassador is added\n     *\n     */\n    event AmbassadorAdded(address indexed ambassador, address indexed entity);\n\n    /**\n     * @notice Triggered when an ambassador is removed.\n     *\n     * @param ambassador Address of the ambassador removed\n     * @param entity Address of the entity where the ambassador is removed\n     *\n     */\n    event AmbassadorRemoved(address indexed ambassador, address indexed entity);\n\n    /**\n     * @notice Triggered when an ambassador is replaced by the entity.\n     *\n     * @param ambassadorIndex Index of the ambassador being replaced\n     * @param entityAccount Address of the entity where ambassador is being replaced\n     * @param oldAmbassador Ambassador's old account address\n     * @param newAmbassador Ambassador's new account address\n     *\n     */\n    event AmbassadorReplaced(\n        uint256 ambassadorIndex,\n        address indexed entityAccount,\n        address indexed oldAmbassador,\n        address indexed newAmbassador\n    );\n\n    /**\n     * @notice Triggered when an ambassador replaces it's own account.\n     *\n     * @param ambassadorIndex Index of the ambassador being replaced\n     * @param entityAccount Address of the entity where ambassador is being replaced\n     * @param oldAccount Ambassador's old account address\n     * @param newAccount Ambassador's new account address\n     *\n     */\n    event AmbassadorAccountReplaced(\n        uint256 ambassadorIndex,\n        address indexed entityAccount,\n        address indexed oldAccount,\n        address indexed newAccount\n    );\n\n    /**\n     * @notice Triggered when an ambassador is transfered to a new entity.\n     *\n     * @param ambassador Ambassador address being replaced\n     * @param oldEntity Entity's old account address\n     * @param newEntity Entity's new account address\n     *\n     */\n    event AmbassadorTransfered(\n        address indexed ambassador,\n        address indexed oldEntity,\n        address indexed newEntity\n    );\n\n    /**\n     * @notice Triggered when a community is transfered from one ambassador to another.\n     *\n     * @param fromAmbassador Ambassador address from which the community is being transfered from\n     * @param toAmbassador Ambassador address to which the community is being transfered to\n     * @param community Community address being transfered\n     *\n     */\n    event AmbassadorToCommunityUpdated(\n        address indexed fromAmbassador,\n        address indexed toAmbassador,\n        address indexed community\n    );\n\n    /**\n     * @notice Triggered when a community is removed.\n     *\n     * @param ambassador Ambassador of the community being removed\n     * @param community Community address being removed\n     *\n     */\n    event CommunityRemoved(address indexed ambassador, address indexed community);\n\n    /**\n     * @notice Enforces sender to be an ambassador\n     */\n    modifier onlyAmbassador() {\n        require(ambassadorByAddress[msg.sender] != 0, \"Ambassador:: ONLY_AMBASSADOR\");\n        _;\n    }\n\n    /**\n     * @notice Enforces sender to be an entity\n     */\n    modifier onlyEntity() {\n        require(entityByAddress[msg.sender] != 0, \"Ambassador:: ONLY_ENTITY\");\n        _;\n    }\n\n    /**\n     * @notice Enforces sender to be an entity or owner\n     */\n    modifier onlyEntityOrOwner() {\n        require(\n            entityByAddress[msg.sender] != 0 || owner() == msg.sender,\n            \"Ambassador:: ONLY_ENTITY_OR_OWNER\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Enforces sender to be te community admin contract\n     */\n    modifier onlyCommunityAdmin() {\n        require(address(communityAdmin) == msg.sender, \"Ambassador:: ONLY_COMMUNITY_ADMIN\");\n        _;\n    }\n\n    /**\n     * @notice Used to initialize a new Ambassadors contract\n     *\n     * @param _communityAdmin Address of the community admin contract\n     *\n     */\n    function initialize(ICommunityAdmin _communityAdmin) external initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        ambassadorIndex = 1;\n        entityIndex = 1;\n        communityAdmin = _communityAdmin;\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice Returns boolean whether an address is ambassador or not.\n     *\n     * @param _ambassador Address of the ambassador\n     * @return Boolean whether an address is ambassador or not\n     */\n    function isAmbassador(address _ambassador) public view override returns (bool) {\n        return ambassadorByAddress[_ambassador] != 0;\n    }\n\n    /**\n     * @notice Returns boolean whether an address is ambassador of a given community.\n     *\n     * @param _ambassador Address of the ambassador\n     * @param _community Address of the community\n     * @return Boolean whether an address is ambassador of a given community or not\n     */\n    function isAmbassadorOf(address _ambassador, address _community)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return ambassadorByAddress[_ambassador] == communityToAmbassador[_community];\n    }\n\n    /**\n     * @notice Returns boolean whether an address is entity responsible for ambassador of a given community.\n     *\n     * @param _entity Address of the entity\n     * @param _community Address of the community\n     * @return Boolean whether an address is entity responsible for ambassador of a given community or not\n     */\n    function isEntityOf(address _entity, address _community) public view override returns (bool) {\n        return entityByAddress[_entity] == ambassadorToEntity[communityToAmbassador[_community]];\n    }\n\n    /**\n     * @notice Returns boolean whether an address is ambassador at a given entity.\n     *\n     * @param _ambassador Address of the ambassador\n     * @param _entityAddress Address of the entity\n     * @return Boolean whether an address is ambassador at a given entity or not\n     */\n    function isAmbassadorAt(address _ambassador, address _entityAddress)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            ambassadorToEntity[ambassadorByAddress[_ambassador]] == entityByAddress[_entityAddress];\n    }\n\n    /** Updates the address of the communityAdmin\n     *\n     * @param _newCommunityAdmin address of the new communityAdmin\n     * @dev used only for testing the new community upgrade flow\n     */\n    function updateCommunityAdmin(ICommunityAdmin _newCommunityAdmin) external onlyOwner {\n        communityAdmin = _newCommunityAdmin;\n    }\n\n    /**\n     * @notice Registers an entity.\n     *\n     * @param _entity Address of the entity\n     */\n    function addEntity(address _entity) public override onlyOwner {\n        require(entityByAddress[_entity] == 0, \"Ambassador:: ALREADY_ENTITY\");\n\n        entityByAddress[_entity] = entityIndex;\n        entityByIndex[entityIndex] = _entity;\n        entityIndex++;\n\n        emit EntityAdded(_entity);\n    }\n\n    /**\n     * @notice Removes an entity.\n     *\n     * @param _entity Address of the entity\n     */\n    function removeEntity(address _entity) public override onlyOwner {\n        uint256 entityIndex = entityByAddress[_entity];\n\n        require(entityIndex != 0, \"Ambassador:: NOT_ENTITY\");\n        require(entityAmbassadors[entityIndex] == 0, \"Ambassador:: HAS_AMBASSADORS\");\n\n        entityByIndex[entityIndex] = address(0);\n        entityByAddress[_entity] = 0;\n\n        emit EntityRemoved(_entity);\n    }\n\n    /**\n     * @notice Replace entity account.\n     *\n     * @param _entity Address of the entity\n     * @param _newEntity New entity address\n     */\n    function replaceEntityAccount(address _entity, address _newEntity) external override {\n        uint256 entityIndex = entityByAddress[_entity];\n\n        require(msg.sender == _entity || msg.sender == owner(), \"Ambassador:: NOT_ALLOWED\");\n        require(entityIndex != 0, \"Ambassador:: NOT_ENTITY\");\n\n        entityByIndex[entityIndex] = _newEntity;\n        entityByAddress[_newEntity] = entityByAddress[_entity];\n        entityByAddress[_entity] = 0;\n\n        emit EntityAccountReplaced(entityIndex, _entity, _newEntity);\n    }\n\n    /**\n     * @notice Registers an ambassador.\n     *\n     * @param _ambassador Address of the ambassador\n     */\n    function addAmbassador(address _ambassador) external override onlyEntity {\n        require(!isAmbassador(_ambassador), \"Ambassador:: ALREADY_AMBASSADOR\");\n\n        uint256 entityIndex = entityByAddress[msg.sender];\n\n        ambassadorByAddress[_ambassador] = ambassadorIndex;\n        ambassadorByIndex[ambassadorIndex] = _ambassador;\n        ambassadorToEntity[ambassadorIndex] = entityIndex;\n        entityAmbassadors[entityIndex]++;\n        ambassadorIndex++;\n\n        emit AmbassadorAdded(_ambassador, msg.sender);\n    }\n\n    /**\n     * @notice Removes an ambassador.\n     *\n     * @param _ambassador Address of the ambassador\n     */\n    function removeAmbassador(address _ambassador) external override onlyEntity {\n        uint256 thisAmbassadorIndex = ambassadorByAddress[_ambassador];\n        uint256 entityIndex = entityByAddress[msg.sender];\n\n        require(isAmbassadorAt(_ambassador, msg.sender), \"Ambassador:: NOT_AMBASSADOR\");\n        require(\n            ambassadorCommunities[thisAmbassadorIndex].length() == 0,\n            \"Ambassador:: HAS_COMMUNITIES\"\n        );\n\n        entityAmbassadors[entityIndex]--;\n        ambassadorByAddress[_ambassador] = 0;\n\n        emit AmbassadorRemoved(_ambassador, msg.sender);\n    }\n\n    /**\n     * @notice Replace ambassador account. Called by ambassador.\n     *\n     * @param _ambassador Address of the ambassador\n     * @param _newAmbassador New ambassador address\n     */\n    function replaceAmbassadorAccount(address _ambassador, address _newAmbassador)\n        external\n        override\n    {\n        require(msg.sender == _ambassador || msg.sender == owner(), \"Ambassador:: NOT_ALLOWED\");\n        require(isAmbassador(_ambassador), \"Ambassador:: NOT_AMBASSADOR\");\n        require(!isAmbassador(_newAmbassador), \"Ambassador:: ALREADY_AMBASSADOR\");\n\n        uint256 thisAmbassadorIndex;\n        address entityAddress;\n        address oldAmbassador;\n        address newAmbassador;\n        (\n            thisAmbassadorIndex,\n            entityAddress,\n            oldAmbassador,\n            newAmbassador\n        ) = _replaceAmbassadorAccountInternal(_ambassador, _newAmbassador);\n\n        emit AmbassadorAccountReplaced(\n            thisAmbassadorIndex,\n            entityAddress,\n            oldAmbassador,\n            newAmbassador\n        );\n    }\n\n    /**\n     * @notice Replaces an ambassador. Called by entity.\n     *\n     * @param _oldAmbassador Address of the ambassador\n     * @param _newAmbassador New ambassador address\n     */\n    function replaceAmbassador(address _oldAmbassador, address _newAmbassador) external override {\n        require(\n            isAmbassadorAt(_oldAmbassador, msg.sender) || msg.sender == owner(),\n            \"Ambassador:: NOT_AMBASSADOR\"\n        );\n        require(!isAmbassador(_newAmbassador), \"Ambassador:: ALREADY_AMBASSADOR\");\n\n        uint256 thisAmbassadorIndex;\n        address entityAddress;\n        address oldAmbassador;\n        address newAmbassador;\n        (\n            thisAmbassadorIndex,\n            entityAddress,\n            oldAmbassador,\n            newAmbassador\n        ) = _replaceAmbassadorAccountInternal(_oldAmbassador, _newAmbassador);\n\n        emit AmbassadorReplaced(thisAmbassadorIndex, entityAddress, oldAmbassador, newAmbassador);\n    }\n\n    /**\n     * @notice Transfers an ambassador to another entity.\n     *\n     * @param _ambassador Address of the ambassador\n     * @param _toEntity Address of the entity\n     * @param _keepCommunities Boolean whether to keep the ambassador's communities or not\n     */\n    function transferAmbassador(\n        address _ambassador,\n        address _toEntity,\n        bool _keepCommunities\n    ) external override onlyEntityOrOwner {\n        uint256 thisAmbassadorIndex = ambassadorByAddress[_ambassador];\n        require(\n            isAmbassadorAt(_ambassador, msg.sender) || msg.sender == owner(),\n            \"Ambassador:: NOT_AMBASSADOR\"\n        );\n        require(\n            ambassadorCommunities[thisAmbassadorIndex].length() == 0 || _keepCommunities == true,\n            \"Ambassador:: HAS_COMMUNITIES\"\n        );\n\n        uint256 entityIndex = ambassadorToEntity[thisAmbassadorIndex];\n        uint256 entityToIndex = entityByAddress[_toEntity];\n\n        ambassadorToEntity[thisAmbassadorIndex] = entityToIndex;\n        entityAmbassadors[entityIndex]--;\n        entityAmbassadors[entityToIndex]++;\n\n        emit AmbassadorTransfered(_ambassador, entityByIndex[entityIndex], _toEntity);\n    }\n\n    /**\n     * @notice Transfers community from ambassador to another ambassador.\n     *\n     * @param _to Address of the ambassador to transfer the community to\n     * @param _community Community address\n     */\n    function transferCommunityToAmbassador(address _to, address _community)\n        external\n        override\n        onlyEntityOrOwner\n    {\n        address _from = ambassadorByIndex[communityToAmbassador[_community]];\n\n        require(isAmbassadorOf(_from, _community), \"Ambassador:: NOT_AMBASSADOR\");\n        require(!isAmbassadorOf(_to, _community), \"Ambassador:: ALREADY_AMBASSADOR\");\n        require(\n            isAmbassadorAt(_from, msg.sender) || msg.sender == owner(),\n            \"Ambassador:: NOT_AMBASSADOR\"\n        );\n        require(\n            isAmbassadorAt(_to, msg.sender) || msg.sender == owner(),\n            \"Ambassador:: NOT_AMBASSADOR\"\n        );\n\n        communityToAmbassador[_community] = ambassadorByAddress[_to];\n        ambassadorCommunities[ambassadorByAddress[_from]].remove(_community);\n        ambassadorCommunities[ambassadorByAddress[_to]].add(_community);\n\n        emit AmbassadorToCommunityUpdated(_from, _to, _community);\n    }\n\n    /**\n     * @notice Sets community to ambassador.\n     *\n     * @param _ambassador Address of the ambassador\n     * @param _community Community address\n     */\n    function setCommunityToAmbassador(address _ambassador, address _community)\n        external\n        override\n        onlyCommunityAdmin\n    {\n        require(isAmbassador(_ambassador), \"Ambassador:: NOT_AMBASSADOR\");\n        require(!isAmbassadorOf(_ambassador, _community), \"Ambassador:: ALREADY_AMBASSADOR\");\n\n        uint256 thisAmbassadorIndex = ambassadorByAddress[_ambassador];\n\n        communityToAmbassador[_community] = thisAmbassadorIndex;\n        ambassadorCommunities[thisAmbassadorIndex].add(_community);\n\n        emit AmbassadorToCommunityUpdated(address(0), _ambassador, _community);\n    }\n\n    /**\n     * @notice Removes community.\n     *\n     * @param _community Community address\n     */\n    function removeCommunity(address _community) external override onlyCommunityAdmin {\n        address _ambassador = ambassadorByIndex[communityToAmbassador[_community]];\n\n        require(isAmbassadorOf(_ambassador, _community), \"Ambassador:: NOT_AMBASSADOR\");\n\n        uint256 thisAmbassadorIndex = ambassadorByAddress[_ambassador];\n\n        communityToAmbassador[_community] = 0;\n        ambassadorCommunities[thisAmbassadorIndex].remove(_community);\n\n        emit CommunityRemoved(_ambassador, _community);\n    }\n\n    /**\n     * @notice Internal function, common to account replacement.\n     *\n     * @param _old Address of the ambassador\n     * @param _new New ambassador address\n     */\n    function _replaceAmbassadorAccountInternal(address _old, address _new)\n        private\n        returns (\n            uint256,\n            address,\n            address,\n            address\n        )\n    {\n        uint256 thisAmbassadorIndex = ambassadorByAddress[_old];\n        uint256 entityIndex = ambassadorToEntity[thisAmbassadorIndex];\n\n        ambassadorByIndex[thisAmbassadorIndex] = _new;\n        ambassadorByAddress[_new] = ambassadorByAddress[_old];\n        ambassadorByAddress[_old] = 0;\n\n        return (thisAmbassadorIndex, entityByIndex[entityIndex], _old, _new);\n    }\n}\n"
    },
    "contracts/airdropV3/AirdropV3Proxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract AirdropV3Proxy is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/airdropV2/AirdropV2Proxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract AirdropV2Proxy is TransparentUpgradeableProxy {\n    constructor(address _logic, address _proxyAdmin)\n        TransparentUpgradeableProxy(_logic, _proxyAdmin, \"\")\n    {}\n}\n"
    },
    "contracts/microcredit/MicrocreditRevenueImplementation.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./interfaces/MicrocreditRevenueStorageV1.sol\";\n\ncontract MicrocreditRevenueImplementation is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    MicrocreditRevenueStorageV1\n{\n    using SafeERC20Upgradeable for IERC20;\n\n    /**\n     * @notice Used to initialize the MicrocreditRevenue contract\n     */\n    function initialize() public initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n    }\n\n    /**\n     * @notice Returns the current implementation version\n     */\n    function getVersion() external pure override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @notice Transfers an amount of an ERC20 from this contract to an address\n     *\n     * @param _token address of the ERC20 token\n     * @param _to address of the receiver\n     * @param _amount amount of the transaction\n     */\n    function transferERC20(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyOwner nonReentrant {\n        _token.safeTransfer(_to, _amount);\n    }\n}\n"
    },
    "contracts/microcredit/interfaces/MicrocreditRevenueStorageV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./IMicrocreditRevenue.sol\";\n\n/**\n * @title Storage for MicrocreditRevenue\n * @notice For future upgrades, do not change MicrocreditRevenueStorageV1. Create a new\n * contract which implements MicrocreditRevenueStorageV1 and following the naming convention\n * MicrocreditRevenueStorageVx.\n */\nabstract contract MicrocreditRevenueStorageV1 is IMicrocreditRevenue {\n}\n"
    },
    "contracts/microcredit/interfaces/IMicrocreditRevenue.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IMicrocreditRevenue {\n    function getVersion() external returns (uint256);\n    function transferERC20(IERC20 _token, address _to, uint256 _amount) external;\n}\n"
    },
    "contracts/token/TransferrableVotingToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.3;\n\nimport \"./VotingToken.sol\";\n\ncontract TransferrableVotingToken is VotingToken {\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     * @param initialSupply_ Initial supply of tokens\n     * @param account_ The initial account to grant all the tokens\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        uint96 initialSupply_,\n        address account_\n    ) VotingToken(name_, symbol_, decimals_) {\n        _mintVotes(account_, initialSupply_);\n    }\n\n    ////////////////////////////////\n    //\n    // The below code is copied from Uniswap's Uni.sol.\n    // Changes are marked with \"XXX\".\n    //\n    ////////////////////////////////\n\n    // XXX: deleted name, symbol, decimals, totalSupply, minter, mintingAllowedAfter,\n    // minimumTimeBetweenMints, mintCap\n\n    // Allowance amounts on behalf of others\n    mapping(address => mapping(address => uint96)) internal allowances;\n\n    // XXX: balances, delegates, Checkpoint, checkpoints,\n    // numCheckpoints, DOMAIN_TYPEHASH, DELEGATION_TYPEHASH\n    // are inherited from VotingPower.sol\n\n    /// @notice The EIP-712 typehash for the permit struct used by the contract\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    // XXX: nonces is inherited from VotingPower.sol\n\n    // XXX: deleted MinterChanged\n\n    // XXX: deleted DelegateChanged, DelegateVotesChanged, Transfer and moved them to IVotingPower\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    // XXX: deleted constructor, setMinter, mint\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint256) {\n        return allowances[account][spender];\n    }\n\n    // XXX_ADDED: upgrade to Solidity 0.8.3, which doesn't allow use of uintn(-1)\n    uint256 internal constant MAX_INT = 2**256 - 1;\n    uint96 internal constant MAX_INT_96 = 2**96 - 1;\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 rawAmount) external returns (bool) {\n        uint96 amount;\n        // XXX: uint256(-1) => MAX_INT\n        if (rawAmount == MAX_INT) {\n            // XXX: uint96(-1) => MAX_INT_96\n            amount = MAX_INT_96;\n        } else {\n            amount = safe96(rawAmount, \"Uni::approve: amount exceeds 96 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Triggers an approval from owner to spends\n     * @param owner The address to approve from\n     * @param spender The address to be approved\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @param deadline The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 rawAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        uint96 amount;\n        // XXX: uint256(-1) => MAX_INT\n        if (rawAmount == MAX_INT) {\n            // XXX: uint96(-1) => MAX_INT_oy\n            amount = MAX_INT_96;\n        } else {\n            amount = safe96(rawAmount, \"Uni::permit: amount exceeds 96 bits\");\n        }\n\n        // XXX_CHANGED: name => name()\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this))\n        );\n        bytes32 structHash = keccak256(\n            abi.encode(PERMIT_TYPEHASH, owner, spender, rawAmount, nonces[owner]++, deadline)\n        );\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Uni::permit: invalid signature\");\n        require(signatory == owner, \"Uni::permit: unauthorized\");\n        // XXX: added linter disable\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp <= deadline, \"Uni::permit: signature expired\");\n\n        allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n    }\n\n    // XXX: deleted balanceOf\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 rawAmount) external returns (bool) {\n        // XXX_ADDED\n        require(\n            dst != address(this),\n            \"TransferrableVotingToken::transfer: cannot send tokens to contract\"\n        );\n        uint96 amount = safe96(rawAmount, \"Uni::transfer: amount exceeds 96 bits\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 rawAmount\n    ) external returns (bool) {\n        // XXX_ADDED\n        require(\n            dst != address(this),\n            \"TransferrableVotingToken::transferFrom: cannot send tokens to contract\"\n        );\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = safe96(rawAmount, \"Uni::approve: amount exceeds 96 bits\");\n\n        // XXX: uint96(-1) => MAX_INT_96\n        if (spender != src && spenderAllowance != MAX_INT_96) {\n            uint96 newAllowance = sub96(\n                spenderAllowance,\n                amount,\n                \"Uni::transferFrom: transfer amount exceeds spender allowance\"\n            );\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    // XXX: rest is in VotingPower.sol\n}\n"
    },
    "contracts/token/PACTToken.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.4;\n\nimport \"./TransferrableVotingToken.sol\";\n\ncontract PACTToken is TransferrableVotingToken {\n    /// @notice The maximum supply of PACT Tokens.\n    uint96 public constant MAX_SUPPLY = 10_000_000_000e18;\n\n    /**\n     * @notice Construct a new PACT Token\n     * Note: this contract doesn't specify an initial minter, so there is no way new\n     * tokens can get created.\n     * @param _initialOwner The initial account to grant all the tokens\n     */\n    constructor(address _initialOwner)\n        TransferrableVotingToken(\"PactToken\", \"PACT\", 18, MAX_SUPPLY, _initialOwner)\n    {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}